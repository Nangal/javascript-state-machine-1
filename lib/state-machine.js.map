{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///webpack/bootstrap 7ac199e0b0fe7236eeb7","webpack:///./src/StateMachine.js","webpack:///./src/utils/ValueMap.js","webpack:///./src/utils/utils.js","webpack:///./src/Transition.js","webpack:///./src/Events.js"],"names":["StateMachine","scope","config","state","states","transitions","actions","handlers","initialize","update","prototype","transition","addStates","events","initial","map","event","matches","match","name","from","op","to","add","hasOwnProperty","on","defer","order","namespace","type","dispatch","do","action","can","rest","create","exec","go","has","getActionForState","debug","console","info","warn","cannot","is","indexOf","getStatesFor","getActionsFor","Object","keys","asMap","get","isStarted","isTransitioning","isPaused","paused","isComplete","final","pause","resume","cancel","clear","end","reset","set","addState","remove","id","fn","parseHandler","targets","target","Error","path","getPath","insert","off","fsm","key","push","eventNamespaces","join","change","complete","leave","enter","start","ValueMap","data","value","undefined","values","obj","length","shift","index","String","split","pop","parent","arr","splice","isObject","isArray","isString","isFunction","isDefined","isUndefined","trim","toString","call","Array","Function","replace","Transition","callbacks","handler","params","queue","bind","apply","concat","token","source","test","ActionEvent","StateEvent","SystemEvent","TransitionEvent","noop"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;;;;;;;;;;;mBCjCwBA,Y;;AALxB;;;;AACA;;;;AACA;;AACA;;;;AAEe,UAASA,YAAT,CAAuBC,KAAvB,EAA8BC,MAA9B,EACf;AACI,UAAKD,KAAL,GAAsBA,KAAtB;AACA,UAAKE,KAAL,GAAsB,EAAtB;AACA,UAAKC,MAAL,GAAsB,EAAtB;AACA,UAAKC,WAAL,GAAsB,wBAAtB;AACA,UAAKC,OAAL,GAAsB,wBAAtB;AACA,UAAKC,QAAL,GAAsB,wBAAtB;AACA,SAAGL,MAAH,EACA;AACI,cAAKM,UAAL,CAAgBN,MAAhB;AACA,cAAKO,MAAL,CAAY,QAAZ,EAAsB,YAAtB;AACH;AACJ;;AAED;;;;;;;;;;;AAWAT,cAAaU,SAAb,GACA;AACI;AACA;;AAEI;;;;;;;;;;;;AAYAN,aAAc,IAhBtB;;AAkBQ;;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BAC,kBAAc,IA7CtB;;AA+CQ;;;;;;;;;;;;;;;;;;;;;;;;;AAyBAC,cAAc,IAxEtB;;AA0EQ;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BAC,eAAa,IApGrB;;AAsGQ;;;;;AAKAJ,YAAc,EA3GtB;;AA6GQ;;;;;AAKAQ,iBAAc,IAlHtB;;AAoHQ;;;;;AAKAV,YAAa,IAzHrB;;AA2HQ;;;;;AAKAC,aAAc,IAhItB;;AAmII;AACA;;AAEI;;;;;;AAMAM,iBAAW,oBAAUN,MAAV,EACX;AAAA;;AACI;AACA,cAAKA,MAAL,GAAkBA,MAAlB;;AAEA;AACAU,mBAAU,IAAV,EAAgB,MAAhB,EAAwBV,OAAOW,MAA/B;AACAD,mBAAU,IAAV,EAAgB,IAAhB,EAAsBV,OAAOW,MAA7B;;AAEA;AACA,aAAI,CAAEX,OAAOY,OAAb,EACA;AACIZ,oBAAOY,OAAP,GAAiB,KAAKV,MAAL,CAAY,CAAZ,CAAjB;AACH;;AAED;AACAF,gBAAOW,MAAP,CAAcE,GAAd,CAAmB,iBACnB;AACI;AACA,iBAAG,qBAASC,KAAT,CAAH,EACA;AACI,qBAAIC,UAAUD,MAAME,KAAN,CAAY,2CAAZ,CAAd;;AADJ,+CAEgCD,OAFhC;;AAAA,qBAEUE,IAFV;AAAA,qBAEgBC,IAFhB;AAAA,qBAEsBC,EAFtB;AAAA,qBAE0BC,EAF1B;;AAGI,qBAAGD,OAAO,GAAV,EACA;AACI,2BAAKE,GAAL,CAASJ,IAAT,EAAeC,IAAf,EAAqBE,EAArB;AACA,2BAAKC,GAAL,CAASJ,IAAT,EAAeG,EAAf,EAAmBF,IAAnB;AACA;AACH;AACD,qBAAGC,OAAO,GAAV,EACA;AAAA,gCACiB,CAACC,EAAD,EAAKF,IAAL,CADjB;AACKA,yBADL;AACWE,uBADX;AAEC;AACD,uBAAKC,GAAL,CAASJ,IAAT,EAAeC,IAAf,EAAqBE,EAArB;AACH;;AAED;AAjBA,kBAmBA;AACI,2BAAKC,GAAL,CAASP,MAAMG,IAAf,EAAqBH,MAAMI,IAA3B,EAAiCJ,MAAMM,EAAvC;AACH;AACJ,UAzBD;;AA2BA;AACA,cAAI,IAAIH,IAAR,IAAgBjB,OAAOK,QAAvB,EACA;AACI,iBAAGL,OAAOK,QAAP,CAAgBiB,cAAhB,CAA+BL,IAA/B,CAAH,EACA;AACI,sBAAKM,EAAL,CAAQN,IAAR,EAAcjB,OAAOK,QAAP,CAAgBY,IAAhB,CAAd;AACH;AACJ;;AAED;AACA,aAAI,CAAEjB,OAAOwB,KAAb,EACA;AACI,kBAAKvB,KAAL,GAAaD,OAAOY,OAApB;AACH;;AAED;;;;;;;;;AASAZ,gBAAOyB,KAAP,GAAezB,OAAOyB,KAAP,IAAgB,CAC3B,SAD2B,EAE3B,cAF2B,EAG3B,YAH2B,EAI3B,SAJ2B,EAK3B,SAL2B,EAM3B,UAN2B,EAO3B,YAP2B,EAQ3B,OAR2B,CAA/B;AAUH,MAzNT;;AA2NQ;;;;;;AAMAlB,aAAQ,gBAAUmB,SAAV,EAAqBC,IAArB,EACR;AACI,aAAIb,QAAQY,cAAc,QAAd,gDAAZ;AAGA,cAAKE,QAAL,CAAcF,YAAY,GAAZ,GAAkBC,IAAhC,EAAsC,IAAIb,KAAJ,CAAUa,IAAV,CAAtC;AACA,gBAAO,IAAP;AACH,MAxOT;;AA2OI;AACA;;AAEI;;;;;;;AAOAE,SAAI,aAAUC,MAAV,EACJ;AACI,aAAG,KAAKC,GAAL,CAASD,MAAT,CAAH,EACA;AAAA,+CAHqBE,IAGrB;AAHqBA,qBAGrB;AAAA;;AACI,kBAAKvB,UAAL,GAAkB,qBAAWwB,MAAX,CAAkB,IAAlB,EAAwBH,MAAxB,EAAgCE,IAAhC,CAAlB;AACA,kBAAKzB,MAAL,CAAY,QAAZ,EAAsB,QAAtB;AACA,kBAAKE,UAAL,CAAgByB,IAAhB;AACA,oBAAO,IAAP;AACH;AACD,gBAAO,KAAP;AACH,MA/PT;;AAiQQ;;;;;;;;AAQAC,SAAI,YAAUlC,KAAV,EACJ;AACI,aAAG,KAAKmC,GAAL,CAASnC,KAAT,CAAH,EACA;AACI,iBAAI6B,SAAS,KAAKO,iBAAL,CAAuBpC,KAAvB,CAAb;AACA,iBAAG6B,MAAH,EACA;AACI,wBAAO,KAAKD,EAAL,CAAQC,MAAR,CAAP;AACH;AACD,kBAAK9B,MAAL,CAAYsC,KAAZ,IAAqBC,QAAQC,IAAR,CAAa,wCAAb,EAAuD,KAAKvC,KAA5D,EAAmEA,KAAnE,CAArB;AACH,UARD,MAUA;AACI,kBAAKD,MAAL,CAAYsC,KAAZ,IAAqBC,QAAQE,IAAR,CAAa,oBAAb,EAAmCxC,KAAnC,CAArB;AACH;AACD,gBAAO,KAAP;AACH,MAzRT;;AA2RQ;;;;;;AAMA8B,UAAK,aAAUD,MAAV,EACL;AACI,aAAI,CAAE,KAAK1B,OAAL,CAAagC,GAAb,CAAiBN,MAAjB,CAAN,EACA;AACI,kBAAK9B,MAAL,CAAYsC,KAAZ,IAAqBC,QAAQE,IAAR,CAAa,qBAAb,EAAoCX,MAApC,CAArB;AACH;AACD,gBAAO,CAAC,CAAE,KAAK3B,WAAL,CAAiBiC,GAAjB,CAAqB,KAAKnC,KAA1B,EAAiC6B,MAAjC,CAAV;AACH,MAxST;;AA0SQ;;;;;;AAMAY,aAAQ,gBAAUZ,MAAV,EACR;AACI,gBAAO,CAAE,KAAKC,GAAL,CAASD,MAAT,CAAT;AACH,MAnTT;;AAqTQ;;;;;;AAMAa,SAAI,YAAU1C,KAAV,EACJ;AACI,aAAG,KAAKC,MAAL,CAAY0C,OAAZ,CAAoB3C,KAApB,MAA+B,CAAC,CAAnC,EACA;AACI,kBAAKD,MAAL,CAAYsC,KAAZ,IAAqBC,QAAQE,IAAR,CAAa,oBAAb,EAAmCxC,KAAnC,CAArB;AACH;AACD,gBAAOA,UAAU,KAAKA,KAAtB;AACH,MAlUT;;AAoUQ;;;;;;AAMAmC,UAAK,aAASnC,KAAT,EACL;AACI,gBAAO,KAAKC,MAAL,CAAY0C,OAAZ,CAAoB3C,KAApB,MAA+B,CAAC,CAAvC;AACH,MA7UT;;AA+UQ;;;;;;AAMA4C,mBAAc,wBACd;AAAA,aADwB5C,KACxB,uEADgC,IAChC;;AACIA,iBAAcA,SAAS,KAAKA,KAA5B;AACA,aAAIG,UAAU,KAAK0C,aAAL,CAAmB7C,KAAnB,EAA0B,IAA1B,CAAd;AACA,gBAAO8C,OAAOC,IAAP,CAAY5C,OAAZ,EAAqBS,GAArB,CAA0B;AAAA,oBAAQT,QAAQa,IAAR,CAAR;AAAA,UAA1B,CAAP;AACH,MA1VT;;AA4VQ;;;;;;;AAOA6B,oBAAe,yBACf;AAAA;;AAAA,aADyB7C,KACzB,uEADiC,IACjC;AAAA,aADuCgD,KACvC,uEAD+C,KAC/C;;AACIhD,iBAAcA,SAAS,KAAKA,KAA5B;AACA,aAAIG,UAAU,KAAKD,WAAL,CAAiB+C,GAAjB,CAAqBjD,SAAS,KAAKA,KAAnC,CAAd;AACA,aAAGgD,KAAH,EACA;AAAA;AACI,qBAAI/C,SAAU,EAAd;AACAE,yBAAQS,GAAR,CAAa,kBACb;AACIX,4BAAO4B,MAAP,IAAiB,OAAK1B,OAAL,CAAa8C,GAAb,CAAiBpB,SAAS,GAAT,GAAe7B,KAAhC,CAAjB;AACH,kBAHD;AAIA;AAAA,wBAAOC;AAAP;AANJ;;AAAA;AAOC,UARD,MAUA;AACI,oBAAOE,OAAP;AACH;AACJ,MApXT;;AAsXQiC,wBAAmB,2BAAUpC,KAAV,EACnB;AACI,aAAG,KAAKmC,GAAL,CAASnC,KAAT,CAAH,EACA;AACI,iBAAIG,UAAU,KAAK0C,aAAL,CAAmB,IAAnB,EAAyB,IAAzB,CAAd;AACA,kBAAI,IAAIhB,MAAR,IAAkB1B,OAAlB,EACA;AACI,qBAAGA,QAAQ0B,MAAR,MAAoB7B,KAAvB,EACA;AACI,4BAAO6B,MAAP;AACH;AACJ;AACJ;AACD,gBAAO,IAAP;AACH,MApYT;;AAuYI;AACA;;AAEI;;;;;AAKAqB,gBAAW,qBACX;AACI,gBAAO,KAAKlD,KAAL,KAAe,EAAtB;AACH,MAlZT;;AAoZQ;;;;;AAKAmD,sBAAiB,2BACjB;AACI,gBAAO,CAAC,CAAE,KAAK3C,UAAf;AACH,MA5ZT;;AA8ZQ;;;;;AAKA4C,eAAU,oBACV;AACI,gBAAO,KAAK5C,UAAL,GACD,KAAKA,UAAL,CAAgB6C,MADf,GAED,KAFN;AAGH,MAxaT;;AA0aQ;;;;;AAKAC,iBAAY,sBACZ;AACI,gBAAO,KAAKtD,KAAL,KAAe,KAAKD,MAAL,CAAYwD,KAAlC;AACH,MAlbT;;AAqbI;AACA;;AAEI;;;;;AAKAC,YAAO,iBACP;AACI,aAAG,KAAKhD,UAAR,EACA;AACI,kBAAKA,UAAL,CAAgBgD,KAAhB;AACA,kBAAKlD,MAAL,CAAY,YAAZ,EAA0B,OAA1B;AACA,kBAAKA,MAAL,CAAY,QAAZ,EAAsB,QAAtB;AACH;AACD,gBAAO,IAAP;AACH,MAtcT;;AAwcQ;;;;;AAKAmD,aAAQ,kBACR;AACI,aAAG,KAAKjD,UAAR,EACA;AACI,kBAAKF,MAAL,CAAY,YAAZ,EAA0B,QAA1B;AACA,kBAAKA,MAAL,CAAY,QAAZ,EAAsB,QAAtB;AACA,kBAAKE,UAAL,CAAgBiD,MAAhB;AACH;AACD,gBAAO,IAAP;AACH,MAtdT;;AAwdQ;;;;;AAKAC,aAAQ,kBACR;AACI,aAAG,KAAKlD,UAAR,EACA;AACI,kBAAKR,KAAL,GAAa,KAAKQ,UAAL,CAAgBS,IAA7B;AACA,kBAAKT,UAAL,CAAgBmD,KAAhB;AACA,oBAAO,KAAKnD,UAAZ;AACA,kBAAKF,MAAL,CAAY,YAAZ,EAA0B,QAA1B;AACA,kBAAKA,MAAL,CAAY,QAAZ,EAAsB,QAAtB;AACH;AACD,gBAAO,IAAP;AACH,MAxeT;;AA0eQ;;;;;AAKAsD,UAAK,eACL;AACI,aAAG,KAAKpD,UAAR,EACA;AACI,kBAAKR,KAAL,GAAa,KAAKQ,UAAL,CAAgBW,EAA7B;AACA,kBAAKX,UAAL,CAAgBmD,KAAhB;AACA,oBAAO,KAAKnD,UAAZ;AACA,kBAAKF,MAAL,CAAY,QAAZ,EAAsB,QAAtB;AACA,iBAAG,KAAKgD,UAAL,EAAH,EACA;AACI,sBAAKhD,MAAL,CAAY,QAAZ,EAAsB,UAAtB;AACH;AACD,kBAAKA,MAAL,CAAY,QAAZ,EAAsB,QAAtB;AACH;AACD,gBAAO,IAAP;AACH,MA9fT;;AAggBQ;;;;;AAKAuD,YAAM,eAASlD,OAAT,EACN;AACI,cAAKX,KAAL,GAAaW,WAAW,KAAKZ,MAAL,CAAYY,OAApC;AACA,aAAG,KAAKH,UAAR,EACA;AACI,kBAAKA,UAAL,CAAgBmD,KAAhB;AACA,oBAAO,KAAKnD,UAAZ;AACH;AACD,cAAKF,MAAL,CAAY,QAAZ,EAAsB,OAAtB;AACA,gBAAO,IAAP;AACH,MA/gBT;;AAkhBI;AACA;;AAEI;;;;;;;;AAQAc,UAAK,aAAUS,MAAV,EAAkBZ,IAAlB,EAAwBE,EAAxB,EACL;AACI,cAAKhB,OAAL,CAAa2D,GAAb,CAAiBjC,SAAS,GAAT,GAAeZ,IAAhC,EAAsCE,EAAtC;AACA,cAAKjB,WAAL,CAAiBkB,GAAjB,CAAqBH,IAArB,EAA2BY,MAA3B;AACAkC,kBAAS,IAAT,EAAe9C,IAAf;AACA8C,kBAAS,IAAT,EAAe5C,EAAf;AACA,gBAAO,IAAP;AACH,MApiBT;;AAsiBQ6C,aAAQ,gBAAUnC,MAAV,EAAkBZ,IAAlB,EAAwBE,EAAxB,EACR;AACI,cAAKlB,MAAL,CAAY+D,MAAZ,CAAmBnC,MAAnB,EAA2BZ,IAA3B;AACH,MAziBT;;AA4iBI;AACA;;AAEI;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCAK,SAAI,YAAU2C,EAAV,EAAcC,EAAd,EACJ;AAAA;;AAAA,6BACqCC,aAAa,IAAb,EAAmBF,EAAnB,CADrC;;AAAA;;AAAA,aACSxC,SADT;AAAA,aACoBC,IADpB;AAAA,aAC0B0C,OAD1B;;;AAGIA,iBAAQxD,GAAR,CAAa,kBACb;AACI;AACA,iBAAGyD,WAAW,GAAd,EACA;AACI,qBAAG5C,cAAc,OAAjB,EACA;AACI,yBAAG,OAAKxB,MAAL,CAAY0C,OAAZ,CAAoB0B,MAApB,MAAgC,CAAC,CAApC,EACA;AACI,gCAAKtE,MAAL,CAAYsC,KAAZ,IAAqBC,QAAQE,IAAR,CAAa,wDAAb,EAAuEd,IAAvE,EAA6E2C,MAA7E,CAArB;AACH;AACJ,kBAND,MAOK,IAAG5C,cAAc,QAAjB,EACL;AACI,yBAAG,CAAC,OAAKtB,OAAL,CAAagC,GAAb,CAAiBkC,MAAjB,CAAJ,EACA;AACI,gCAAKtE,MAAL,CAAYsC,KAAZ,IAAqBC,QAAQE,IAAR,CAAa,0DAAb,EAAyEd,IAAzE,EAA+E2C,MAA/E,CAArB;AACH;AACJ;AACJ;;AAED;AACA,iBAAG,CAAC,uBAAWH,EAAX,CAAJ,EACA;AACI,uBAAM,IAAII,KAAJ,CAAU,qBAAoB7C,SAApB,GAA+B,GAA/B,GAAoCC,IAApC,GAA0C,sCAApD,EAA4FwC,EAA5F,CAAN;AACH;;AAED;AACA,iBAAIK,OAAOC,QAAQ/C,SAAR,EAAmBC,IAAnB,EAAyB2C,MAAzB,CAAX;AACA,oBAAKjE,QAAL,CAAcqE,MAAd,CAAqBF,IAArB,EAA2BL,EAA3B;AACH,UA9BD;;AAgCA,gBAAO,IAAP;AACH,MAtnBT;;AAwnBQQ,UAAK,aAAUT,EAAV,EAAcC,EAAd,EACL;AAAA;;AAAA,8BACqCC,aAAa,IAAb,EAAmBF,EAAnB,CADrC;;AAAA;;AAAA,aACSxC,SADT;AAAA,aACoBC,IADpB;AAAA,aAC0B0C,OAD1B;;AAEIA,iBAAQxD,GAAR,CAAa,kBACb;AACI,iBAAI2D,OAAOC,QAAQ/C,SAAR,EAAmBC,IAAnB,EAAyB2C,MAAzB,CAAX;AACA,oBAAKjE,QAAL,CAAc4D,MAAd,CAAqBO,IAArB,EAA2BL,EAA3B;AACH,UAJD;AAKH,MAhoBT;;AAkoBQvC,eAAU,kBAAS4C,IAAT,EAAe1D,KAAf,EACV;AACI,cAAKd,MAAL,CAAYsC,KAAZ,IAAqBC,QAAQC,IAAR,CAAa,4BAAb,EAA2CgC,IAA3C,CAArB;AACA,aAAInE,WAAW,KAAKA,QAAL,CAAc6C,GAAd,CAAkBsB,IAAlB,CAAf;AACA,aAAGnE,QAAH,EACA;AACI;AACAA,sBAASQ,GAAT,CAAa;AAAA,wBAAMsD,GAAGrD,KAAH,CAAN;AAAA,cAAb;AACH;AACJ;;AA3oBT,EADA;;AAgpBA;;;;;;;AAOA,UAASJ,SAAT,CAAmBkE,GAAnB,EAAwBC,GAAxB,EAA6B1E,WAA7B,EACA;AACIA,iBAAYU,GAAZ,CAAiB;AAAA,gBAASmD,SAASY,GAAT,EAAc9D,MAAM+D,GAAN,CAAd,CAAT;AAAA,MAAjB;AACH;;AAED,UAASb,QAAT,CAAmBY,GAAnB,EAAwB3E,KAAxB,EACA;AACI,SAAI,qBAASA,KAAT,KAAmB2E,IAAI1E,MAAJ,CAAW0C,OAAX,CAAmB3C,KAAnB,MAA8B,CAAC,CAAtD,EACA;AACI2E,aAAI1E,MAAJ,CAAW4E,IAAX,CAAgB7E,KAAhB;AACH;AACJ;;AAED,UAASmE,YAAT,CAAsBQ,GAAtB,EAA2BV,EAA3B,EACA;AACI;AACA,SAAInD,UAAUmD,GAAGlD,KAAH,CAAS,qCAAT,CAAd;AACA,SAAG,CAACD,OAAJ,EACA;AACI,eAAM,IAAIwD,KAAJ,CAAU,uDAAV,EAAmEL,EAAnE,CAAN;AACH;;AANL,oCAOqCnD,OAPrC;;AAAA,SAOUW,SAPV;AAAA,SAOqBC,IAPrB;AAAA,SAO2B2C,MAP3B;;AASI;;AACA,SAAG,CAAC5C,SAAJ,EACA;AACI;AACAA,qBAAYqD,gBAAgBpD,IAAhB,CAAZ;;AAEA;AACA,aAAG,CAACD,SAAJ,EACA;AACI,iBAAGkD,IAAI1E,MAAJ,CAAW0C,OAAX,CAAmBjB,IAAnB,MAA6B,CAAC,CAAjC,EACA;AACI2C,0BAAc3C,IAAd;AACAD,6BAAc,OAAd;AACAC,wBAAc,OAAd;AACH,cALD,MAMK,IAAGiD,IAAIxE,OAAJ,CAAYgC,GAAZ,CAAgBT,IAAhB,CAAH,EACL;AACI2C,0BAAc3C,IAAd;AACAD,6BAAc,QAAd;AACAC,wBAAc,OAAd;AACH,cALI,MAOL;AACIiD,qBAAI5E,MAAJ,CAAWsC,KAAX,IAAoBC,QAAQE,IAAR,CAAa,uFAAb,EAAsGyB,EAAtG,CAApB;AACH;AACJ;AACJ;;AAED;AACA,SAAIG,UAAUC,SACRA,OAAOtD,KAAP,CAAa,WAAb,CADQ,GAER,CAAC,GAAD,CAFN;;AAIA;AACA,YAAO,CAACU,SAAD,EAAYC,IAAZ,EAAkB0C,OAAlB,CAAP;AACH;;AAED,UAASI,OAAT,CAAiB/C,SAAjB,EAA4BC,IAA5B,EAAkC2C,MAAlC,EACA;AACI,YAAO5C,cAAc,QAAd,IAA0BA,cAAc,OAAxC,GACD,CAACA,SAAD,EAAY4C,MAAZ,EAAoB3C,IAApB,EAA0BqD,IAA1B,CAA+B,GAA/B,CADC,GAEDtD,YAAY,GAAZ,GAAkBC,IAFxB;AAGH;;AAED,KAAIoD,kBACJ;AACIE,aAAS,QADb;AAEI1E,aAAS,QAFb;AAGI2E,eAAS,QAHb;AAIIpB,YAAS,QAJb;;AAMIzC,UAAS,OANb;AAOI4C,aAAS,OAPb;AAQIkB,YAAS,OARb;AASIC,YAAS,OATb;;AAWIC,YAAS,QAXb;AAYIxB,UAAS,QAZb;;AAcIJ,YAAS,YAdb;AAeIC,aAAS,YAfb;AAgBIC,aAAS;AAhBb,EADA,C;;;;;;;;;;;;mBClvBwB2B,Q;;AAPxB;;AAEA;;;;;AAKe,UAASA,QAAT,CAAmBC,IAAnB,EACf;AACI,UAAKA,IAAL,GAAYA,QAAQ,EAApB;AACH;;AAEDD,UAAS9E,SAAT,GACA;AACI+E,WAAM,IADV;;AAGIxB,UAAK,aAAUS,IAAV,EAAgBgB,KAAhB,EACL;AACIzB,cAAI,KAAKwB,IAAT,EAAef,IAAf,EAAqBgB,KAArB;AACA,gBAAO,IAAP;AACH,MAPL;;AASInE,UAAI,aAASmD,IAAT,EAAegB,KAAf,EACJ;AACInE,cAAI,KAAKkE,IAAT,EAAef,IAAf,EAAqBgB,KAArB;AACA,gBAAO,IAAP;AACH,MAbL;;AAeId,aAAO,gBAASF,IAAT,EAAegB,KAAf,EACP;AACId,iBAAO,KAAKa,IAAZ,EAAkBf,IAAlB,EAAwBgB,KAAxB;AACA,gBAAO,IAAP;AACH,MAnBL;;AAqBItC,UAAI,aAASsB,IAAT,EACJ;AACI,gBAAOtB,KAAI,KAAKqC,IAAT,EAAef,IAAf,CAAP;AACH,MAxBL;;AA0BIpC,UAAK,aAAUoC,IAAV,EACL;AAAA,aADqBgB,KACrB,uEAD6BC,SAC7B;;AACI,gBAAOrD,KAAI,KAAKmD,IAAT,EAAef,IAAf,EAAqBgB,KAArB,CAAP;AACH,MA7BL;;AA+BI5C,cAAS,iBAAU4B,IAAV,EAAgBgB,KAAhB,EACT;AACI,gBAAO5C,SAAQ,KAAK2C,IAAb,EAAmBf,IAAnB,EAAyBgB,KAAzB,CAAP;AACH,MAlCL;;AAoCIvB,aAAQ,gBAAUO,IAAV,EACR;AAAA,aADwBgB,KACxB,uEADgCC,SAChC;;AACIxB,iBAAO,KAAKsB,IAAZ,EAAkBf,IAAlB,EAAwBgB,KAAxB;AACA,gBAAO,IAAP;AACH,MAxCL;;AA0CIxC,WAAK,cAASwB,IAAT,EACL;AACI,gBAAOzB,OAAOC,IAAP,CAAYE,KAAI,KAAKqC,IAAT,EAAef,IAAf,CAAZ,CAAP;AACH,MA7CL;;AA+CIkB,aAAO,gBAASlB,IAAT,EACP;AACI,gBAAOkB,QAAO,KAAKH,IAAZ,EAAkBf,IAAlB,CAAP;AACH;;AAlDL,EADA;;AAuDA,UAASvC,MAAT,CAAgB0D,GAAhB,EAAqB3C,IAArB,EACA;AACI,SAAI6B,YAAJ;AACA,YAAM7B,KAAK4C,MAAX,EACA;AACIf,eAAM7B,KAAK6C,KAAL,EAAN;AACA,aAAI,CAAE,qBAASF,IAAId,GAAJ,CAAT,CAAN,EACA;AACIc,iBAAId,GAAJ,IAAW,EAAX;AACH;AACDc,eAAMA,IAAId,GAAJ,CAAN;AACH;AACD,YAAOc,GAAP;AACH;;AAEM,UAAS5B,IAAT,CAAa4B,GAAb,EAAkBnB,IAAlB,EAAwBgB,KAAxB,EACP;AAAA,SADsCM,KACtC,uEAD8C,CAAC,CAC/C;;AACI,SAAI9C,OAAO+C,OAAOvB,IAAP,EAAawB,KAAb,CAAmB,GAAnB,CAAX;AAAA,SACInB,MAAO7B,KAAKiD,GAAL,EADX;AAEAN,WAAM1D,OAAO0D,GAAP,EAAY3C,IAAZ,CAAN;AACA2C,SAAId,GAAJ,IAAWW,KAAX;AACH;;;AAED,UAASnE,IAAT,CAAasE,GAAb,EAAkBnB,IAAlB,EAAwBgB,KAAxB,EACA;AACI,SAAIxC,OAAO+C,OAAOvB,IAAP,EAAawB,KAAb,CAAmB,GAAnB,CAAX;AAAA,SACInB,MAAO7B,KAAKiD,GAAL,EADX;AAEAN,WAAM1D,OAAO0D,GAAP,EAAY3C,IAAZ,CAAN;AACA,SAAI,CAAE,oBAAQ2C,IAAId,GAAJ,CAAR,CAAN,EACA;AACIc,aAAId,GAAJ,IAAW,EAAX;AACH;AACDc,SAAId,GAAJ,EAASC,IAAT,CAAcU,KAAd;AACH;;AAED,UAASd,OAAT,CAAgBiB,GAAhB,EAAqBnB,IAArB,EAA2BgB,KAA3B,EACA;AACI,SAAIxC,OAAO+C,OAAOvB,IAAP,EAAawB,KAAb,CAAmB,GAAnB,CAAX;AAAA,SACInB,MAAO7B,KAAKiD,GAAL,EADX;AAEAN,WAAM1D,OAAO0D,GAAP,EAAY3C,IAAZ,CAAN;AACA,SAAI,CAAE,oBAAQ2C,IAAId,GAAJ,CAAR,CAAN,EACA;AACIc,aAAId,GAAJ,IAAW,EAAX;AACH;AACD,SAAIqB,SAASP,IAAId,GAAJ,CAAb;AAAA,SACIiB,QAAQI,OAAOtD,OAAP,CAAe4C,KAAf,CADZ;AAEA,SAAGM,UAAU,CAAC,CAAd,EACA;AACII,gBAAOpB,IAAP,CAAYU,KAAZ;AACH,MAHD,MAKA;AACIU,gBAAOJ,KAAP,IAAgBN,KAAhB;AACH;AACJ;;AAEM,UAAStC,IAAT,CAAayC,GAAb,EAAkBnB,IAAlB,EACP;AACI,SAAG,wBAAYA,IAAZ,KAAqBA,QAAQ,EAAhC,EACA;AACI,gBAAOmB,GAAP;AACH;;AAED,SAAId,YAAJ;AAAA,SACI7B,OAAO+C,OAAOvB,IAAP,EAAawB,KAAb,CAAmB,GAAnB,CADX;AAEA,YAAMhD,KAAK4C,MAAL,GAAc,CAApB,EACA;AACIf,eAAM7B,KAAK6C,KAAL,EAAN;AACA,aAAI,CAAEF,IAAIrE,cAAJ,CAAmBuD,GAAnB,CAAN,EACA;AACI;AACH;AACDc,eAAMA,IAAId,GAAJ,CAAN;AACH;AACDA,WAAM7B,KAAK6C,KAAL,EAAN;AACA,YAAOF,IAAId,GAAJ,CAAP;AACH;;;AAEM,UAASzC,IAAT,CAAauD,GAAb,EAAkBnB,IAAlB,EAAwBgB,KAAxB,EACP;AACI,SAAIU,SAAShD,KAAIyC,GAAJ,EAASnB,IAAT,CAAb;AACA,YAAO,CAAC,EAAG,oBAAQ0B,MAAR,KAAmB,sBAAUV,KAAV,CAAnB,GACLU,OAAOtD,OAAP,CAAe4C,KAAf,MAA0B,CAAC,CADtB,GAEL,wBAAYA,KAAZ,IACI,sBAAUU,MAAV,CADJ,GAEIA,WAAWV,KAJb,CAAR;AAKH;;;AAEM,UAAS5C,QAAT,CAAkB+C,GAAlB,EAAuBnB,IAAvB,EAA6BgB,KAA7B,EACP;AACI,SAAIW,MAAMjD,KAAIyC,GAAJ,EAASnB,IAAT,CAAV;AACA,SAAG,oBAAQ2B,GAAR,CAAH,EACA;AACI,gBAAOA,IAAIvD,OAAJ,CAAY4C,KAAZ,CAAP;AACH;AACD,YAAO,CAAC,CAAR;AACH;;;AAEM,UAASvB,OAAT,CAAgB0B,GAAhB,EAAqBnB,IAArB,EAA2BgB,KAA3B,EACP;AACI,SAAIU,SAASP,GAAb;AAAA,SACI3C,OAAO+C,OAAOvB,QAAQ,EAAf,EAAmBwB,KAAnB,CAAyB,GAAzB,CADX;AAAA,SAEInB,MAAM7B,KAAKiD,GAAL,EAFV;;AAIA,SAAGjD,KAAK4C,MAAR,EACA;AACIM,kBAAShD,KAAIyC,GAAJ,EAAS3C,KAAKgC,IAAL,CAAU,GAAV,CAAT,CAAT;AACH;AACD,SAAG,sBAAUQ,KAAV,KAAoB,oBAAQU,OAAOrB,GAAP,CAAR,CAAvB,EACA;AACIqB,kBAASA,OAAOrB,GAAP,CAAT;AACA,aAAIiB,QAAQI,OAAOtD,OAAP,CAAe4C,KAAf,CAAZ;AACA,aAAGM,QAAQ,CAAC,CAAZ,EACA;AACII,oBAAOE,MAAP,CAAcN,KAAd,EAAqB,CAArB;AACA,oBAAO,IAAP;AACH;AACD,gBAAO,KAAP;AACH,MAVD,MAYA;AACI,aAAG,qBAASI,MAAT,KAAoBP,IAAIrE,cAAJ,CAAmBuD,GAAnB,CAAvB,EACA;AACI,oBAAOqB,OAAOrB,GAAP,CAAP;AACA,oBAAO,IAAP;AACH;AACJ;AACD,YAAO,KAAP;AACH;;;AAEM,UAASa,OAAT,CAAgBC,GAAhB,EAAqBnB,IAArB,EACP;AACI,SAAIkB,SAAS,EAAb;AACA,SAAIpB,SAASpB,KAAIyC,GAAJ,EAASnB,IAAT,CAAb;AACA,SAAG,qBAASF,MAAT,CAAH,EACA;AACI,cAAI,IAAIrD,IAAR,IAAgBqD,MAAhB,EACA;AACI,iBAAGA,OAAOhD,cAAP,CAAsBL,IAAtB,CAAH,EACA;AACIyE,wBAAOZ,IAAP,CAAYR,OAAOrD,IAAP,CAAZ;AACH;AACJ;AACJ;AACD,YAAOyE,MAAP;AACH;;;;;;;;;;;;SCpNeW,Q,GAAAA,Q;SAKAC,O,GAAAA,O;SAKAC,Q,GAAAA,Q;SAKAC,U,GAAAA,U;SAKAC,S,GAAAA,S;SAKAC,W,GAAAA,W;SAKAC,I,GAAAA,I;AA9BT,UAASN,QAAT,CAAmBb,KAAnB,EACP;AACI,YAAOzC,OAAOvC,SAAP,CAAiBoG,QAAjB,CAA0BC,IAA1B,CAA+BrB,KAA/B,MAA0C,iBAAjD;AACH;;AAEM,UAASc,OAAT,CAAkBd,KAAlB,EACP;AACI,YAAOA,iBAAiBsB,KAAxB;AACH;;AAEM,UAASP,QAAT,CAAmBf,KAAnB,EACP;AACI,YAAO,OAAOA,KAAP,KAAiB,QAAxB;AACH;;AAEM,UAASgB,UAAT,CAAoBhB,KAApB,EACP;AACI,YAAOA,iBAAiBuB,QAAxB;AACH;;AAEM,UAASN,SAAT,CAAoBjB,KAApB,EACP;AACI,YAAO,OAAOA,KAAP,KAAiB,WAAxB;AACH;;AAEM,UAASkB,WAAT,CAAsBlB,KAAtB,EACP;AACI,YAAO,OAAOA,KAAP,KAAiB,WAAxB;AACH;;AAEM,UAASmB,IAAT,CAAenB,KAAf,EACP;AACI,YAAOO,OAAOP,SAAS,EAAhB,EAAoBwB,OAApB,CAA4B,YAA5B,EAA0C,EAA1C,CAAP;AACH,E;;;;;;;;;;;;;;ACjCD;;;;AACA;;;;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CA,UAASC,UAAT,CAAqBnF,MAArB,EAA6BZ,IAA7B,EAAmCE,EAAnC,EAAuCf,QAAvC,EAAiD6G,SAAjD,EACA;AACI,UAAKpF,MAAL,GAAkBA,MAAlB;AACA,UAAKZ,IAAL,GAAkBA,IAAlB;AACA,UAAKE,EAAL,GAAkBA,EAAlB;AACA,UAAKf,QAAL,GAAkBA,QAAlB;AACA,UAAK6G,SAAL,GAAkBA,SAAlB;AACH;;AAEDD,YAAWzG,SAAX,GACA;AACIsB,aAAc,EADlB;AAEIZ,WAAc,EAFlB;AAGIE,SAAc,EAHlB;AAIIf,eAAc,IAJlB;AAKI6G,gBAAc,IALlB;AAMI5D,aAAc,KANlB;;AAQIM,YAAO,iBACP;AACI,cAAKN,MAAL,GAAc,KAAd;AACA,cAAKjD,QAAL,GAAgB,EAAhB;AACH,MAZL;;AAcI;;;;AAIH6B,WAAM,gBACN;AACI,aAAI,CAAE,KAAKoB,MAAX,EACG;AACI,iBAAG,KAAKjD,QAAL,CAAcuF,MAAjB,EACA;AACI,qBAAIuB,UAAU,KAAK9G,QAAL,CAAcwF,KAAd,EAAd;AACA,qBAAI5F,QAAQkH,SAAZ;AACA,qBAAGlH,UAAU,KAAb,EACA;AACI,4BAAO,KAAKiH,SAAL,CAAevD,MAAf,EAAP;AACH;AACD,qBAAG1D,UAAU,IAAb,EACA;AACI,4BAAO,KAAKiH,SAAL,CAAezD,KAAf,EAAP;AACH;AACD,sBAAKvB,IAAL;AACH,cAbD,MAeA;AACI,sBAAKgF,SAAL,CAAerD,GAAf;AACH;AACJ;AACD,gBAAO,IAAP;AACN,MA1CF;;AA4CIJ,YAAO,iBACP;AACI,cAAKH,MAAL,GAAc,IAAd;AACA,gBAAO,IAAP;AACH,MAhDL;;AAkDII,aAAQ,kBACR;AACI,cAAKJ,MAAL,GAAc,KAAd;AACA,gBAAO,KAAKpB,IAAL,EAAP;AACH;AAtDL,EADA;;mBA4DA;AACI;;;;;;;;;;;;;;AAcAD,aAAO,gBAAU2C,GAAV,EAAe9C,MAAf,EAAuBsF,MAAvB,EACP;AACI;AACA,aAAIC,QAAU,EAAd;AACA,aAAItH,QAAU6E,IAAI7E,KAAlB;AACA,aAAImB,OAAU0D,IAAI3E,KAAlB;AACA,aAAImB,KAAUwD,IAAIxE,OAAJ,CAAY8C,GAAZ,CAAgBpB,MAAhB,EAAwBZ,IAAxB,CAAd;AACA,aAAIgG,YACJ;AACIvD,qBAAUiB,IAAIjB,MAAJ,CAAW2D,IAAX,CAAgB1C,GAAhB,CADd;AAEInB,oBAAUmB,IAAInB,KAAJ,CAAU6D,IAAV,CAAe1C,GAAf,CAFd;AAGIlB,qBAAUkB,IAAIlB,MAAJ,CAAW4D,IAAX,CAAgB1C,GAAhB,CAHd;AAIIf,kBAAUe,IAAIf,GAAJ,CAAQyD,IAAR,CAAa1C,GAAb;AAJd,UADA;;AAQA;AACA,aAAG,uBAAWxD,EAAX,CAAH,EACA;AACI,iBAAIhB,UAAUwE,IAAI9B,aAAJ,EAAd;AACA,iBAAI7C,QAAUmB,GAAGmG,KAAH,CAASxH,KAAT,EAAgB,CAACK,OAAD,EAAUoH,MAAV,CAAiBJ,MAAjB,CAAhB,CAAd;AACA,iBAAItF,UAAU8C,IAAI9B,aAAJ,CAAkB7C,KAAlB,CAAd;AACA;AACA,iBAAI,CAAE6B,OAAN,EACA;AACI,uBAAM,IAAIyC,KAAJ,CAAU,yBAAwBtE,KAAxB,GAA+B,wBAA/B,GAAyDiB,IAAzD,GAA+D,GAAzE,CAAN;AACH;AACJ;;AAED;AACA0D,aAAI5E,MAAJ,CAAWyB,KAAX,CAAiBZ,GAAjB,CAAsB,iBACtB;AACI;AADJ,gCAE8B4G,MAAMzB,KAAN,CAAY,GAAZ,CAF9B;;AAAA;;AAAA,iBAESrE,IAFT;AAAA,iBAEe+F,MAFf,qBAEgD;;AAC5C,iBAAIhG,YAAsB,gBAAgBiG,IAAhB,CAAqBhG,IAArB,IACI,QADJ,GAEI,OAF9B;AAGA,iBAAI2C,eAAJ;AACA,iBAAGoD,WAAW,GAAd,EACA;AACIpD,0BAAS,GAAT;AACH,cAHD,MAIK,IAAG5C,aAAa,QAAhB,EACL;AACI4C,0BAASxC,MAAT;AACH,cAHI,MAKL;AACIwC,0BAAS3C,SAAS,OAAT,GACHT,IADG,GAEHE,EAFN;AAGH;;AAED;AACA,iBAAIoD,OAAO,CAAC9C,SAAD,EAAY4C,MAAZ,EAAoB3C,IAApB,EAA0BqD,IAA1B,CAA+B,GAA/B,CAAX;;AAEA,iBAAI3E,WAAWuE,IAAIvE,QAAJ,CAAa6C,GAAb,CAAiBsB,IAAjB,CAAf;AACA,iBAAGnE,QAAH,EACA;AACI;AACA;AACAA,4BAAWA,SAASQ,GAAT,CAAc,mBACzB;AACI,4BAAO,YACP;AACI,6BAAIC,QAAQ,iBAAOmB,MAAP,CAAcP,SAAd,EAAyBC,IAAzB,EAA+B2C,MAA/B,EAAuCpD,IAAvC,EAA6CE,EAA7C,EAAiD8F,SAAjD,CAAZ;AACAC,iCAAQI,KAAR,CAAcxH,KAAd,EAAqB,CAACe,KAAD,EAAQ0G,MAAR,CAAeJ,MAAf,CAArB;AACH,sBAJD;AAKH,kBAPU,CAAX;;AASA;AACAC,yBAAQA,MAAMG,MAAN,CAAanH,QAAb,CAAR;AACH;AAEJ,UA5CD;;AA8CA;AACA,gBAAO,IAAI4G,UAAJ,CAAenF,MAAf,EAAuBZ,IAAvB,EAA6BE,EAA7B,EAAiCiG,KAAjC,EAAwCH,SAAxC,CAAP;AACH;;AA5FL,E;;;;;;;;;;;SC9DoBU,W,GAAAA,W;SAUAC,U,GAAAA,U;SAUAC,W,GAAAA,W;SAeAC,e,GAAAA,e;AA5FpB;AACA;;AAEI,UAASC,IAAT,GAAiB,CAAG;;AAEpB;;;;;;;AAOA,KAAIlH,QACJ;AACI;AACAY,gBAAc,IAFlB;AAGIC,WAAc,IAHlB;AAII2C,aAAc,IAJlB;AAKIpD,WAAc,IALlB;AAMIE,SAAc,IANlB;;AAQI;AACAqC,YAAcuE,IATlB;AAUItE,aAAcsE,IAVlB;AAWIrE,aAAcqE,IAXlB;AAYI9C,eAAc8C;AAZlB,EADA;;AAgBA,UAAS1H,UAAT,CAAqBQ,KAArB,EAA4BY,SAA5B,EAAuCC,IAAvC,EAA6C2C,MAA7C,EAAqDpD,IAArD,EAA2DE,EAA3D,EAA+D8F,SAA/D,EACA;AACIpG,WAAMY,SAAN,GAAkBA,SAAlB;AACAZ,WAAMa,IAAN,GAAkBA,IAAlB;AACAb,WAAMwD,MAAN,GAAkBA,MAAlB;AACAxD,WAAMI,IAAN,GAAkBA,IAAlB;AACAJ,WAAMM,EAAN,GAAkBA,EAAlB;;AAEAN,WAAM2C,KAAN,GAAkByD,UAAUzD,KAA5B;AACA3C,WAAM4C,MAAN,GAAkBwD,UAAUxD,MAA5B;AACA5C,WAAM6C,MAAN,GAAkBuD,UAAUvD,MAA5B;AACA7C,WAAMoE,QAAN,GAAkBgC,UAAUhC,QAA5B;AACH;;mBAGD;AACIjD,aAAQ,gBAASP,SAAT,EAAoBC,IAApB,EAA0B2C,MAA1B,EAAkCpD,IAAlC,EAAwCE,EAAxC,EAA4C8F,SAA5C,EACR;AACI,aAAI/C,KAAKzC,aAAa,OAAb,GACHmG,UADG,GAEHD,WAFN;AAGA,gBAAO,IAAIzD,EAAJ,CAAOxC,IAAP,EAAa2C,MAAb,EAAqBpD,IAArB,EAA2BE,EAA3B,EAA+B8F,SAA/B,CAAP;AACH;AAPL,E;;AAWJ;AACA;;AAEW,UAASU,WAAT,CAAsBjG,IAAtB,EAA4B2C,MAA5B,EAAoCpD,IAApC,EAA0CE,EAA1C,EAA8C8F,SAA9C,EACP;AACI5G,gBAAW,IAAX,EAAiB,QAAjB,EAA2BqB,IAA3B,EAAiC2C,MAAjC,EAAyCpD,IAAzC,EAA+CE,EAA/C,EAAmD8F,SAAnD;AACH;AACDU,aAAYpH,SAAZ,GAAwBM,KAAxB;;AAGJ;AACA;;AAEW,UAAS+G,UAAT,CAAqBlG,IAArB,EAA2B2C,MAA3B,EAAmCpD,IAAnC,EAAyCE,EAAzC,EAA6C8F,SAA7C,EACP;AACI5G,gBAAW,IAAX,EAAiB,OAAjB,EAA0BqB,IAA1B,EAAgC2C,MAAhC,EAAwCpD,IAAxC,EAA8CE,EAA9C,EAAkD8F,SAAlD;AACH;AACDW,YAAWrH,SAAX,GAAuBM,KAAvB;;AAGJ;AACA;;AAEW,UAASgH,WAAT,CAAsBnG,IAAtB,EACP;AACI,UAAKA,IAAL,GAAYA,IAAZ;AACH;;AAEDmG,aAAYtH,SAAZ,GACA;AACIkB,gBAAW,QADf;AAEIC,WAAM;AAFV,EADA;;AAOJ;AACA;;AAEW,UAASoG,eAAT,CAA0BpG,IAA1B,EACP;AACI,UAAKA,IAAL,GAAYA,IAAZ;AACH;;AAEDoG,iBAAgBvH,SAAhB,GACA;AACIkB,gBAAW,YADf;AAEIC,WAAM;AAFV,EADA,C","file":"state-machine.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StateMachine\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 7ac199e0b0fe7236eeb7\n **/","import ValueMap from './utils/ValueMap';\nimport Transition from './Transition';\nimport { SystemEvent, TransitionEvent } from './Events';\nimport { isString, isFunction } from './utils/utils';\n\nexport default function StateMachine (scope, config)\n{\n    this.scope          = scope;\n    this.state          = '';\n    this.states         = [];\n    this.transitions    = new ValueMap();\n    this.actions        = new ValueMap();\n    this.handlers       = new ValueMap();\n    if(config)\n    {\n        this.initialize(config);\n        this.update('system', 'initialize');\n    }\n}\n\n/**\n * StateMachine prototype\n *\n * The property examples below illustrate a 4-state machine, with states:\n *\n * - intro > settings > summary > end\n *\n * And actions:\n *\n * - back | next | restart | finish\n */\nStateMachine.prototype =\n{\n    // ------------------------------------------------------------------------------------------------\n    // properties\n\n        /**\n         * Available state names\n         *\n         * - [\n         *     intro,\n         *     settings,\n         *     summary,\n         *     final\n         *   ]\n         *\n         * @var {string[]}\n         */\n        states      : null,\n\n        /**\n         * Available transitions for each action\n         *\n         * action.from => to\n         *\n         * - next: {\n         *     intro: settings,\n         *     settings: summary\n         *   },\n         * - back: {\n         *     settings: intro\n         *   },\n         * - restart: {\n         *     summary:intro\n         *   },\n         * - finish: {\n         *     summary:final\n         *   },\n         *\n         * Transitions can also be functions\n         *\n         * - next: {\n         *     intro: function() { return '<random state>' } // jump to a random state\n         *   }\n         *\n         * @var {ValueMap}\n         */\n        transitions : null,\n\n        /**\n         * Actions that are available to be called from each state\n         *\n         * state => [ action, action, ... ]\n         *\n         * - intro: [\n         *     'next'\n         *   ],\n         * - settings: [\n         *     'next',\n         *     'back'\n         *   ],\n         * - summary: [\n         *     'restart'\n         *     'finish',\n         *   ]\n         *\n         * Actions can also be expressed as wildcards\n         *\n         * - intro: [\n         *     '*' // any action is allowed from intro\n         *   ]\n         *\n         * @var {ValueMap}\n         */\n        actions     : null,\n\n        /**\n         * Handler functions that should be called on each action event / state change\n         *\n         * name.type => [ handler, handler, ... ]\n         *\n         * - next: {\n         *   - start: [\n         *       hideModal\n         *     ],\n         *   - end: [\n         *       showModal\n         *     ]\n         *   },\n         * - summary: {\n         *   - enter: [\n         *       resetForm\n         *     ],\n         *   - leave: [\n         *       validateForm,\n         *       postData,\n         *     ]\n         *   },\n         *   ...\n         *\n         * @var {ValueMap}\n         */\n        handlers   : null,\n\n        /**\n         * The current state\n         *\n         * @var {string}\n         */\n        state       : '',\n\n        /**\n         * Any active Transition object that is driving the state change\n         *\n         * @var {Transition}\n         */\n        transition  : null,\n\n        /**\n         * The scope in which to call all handlers\n         *\n         * @var {*}\n         */\n        scope      : null,\n\n        /**\n         * The original config object\n         *\n         * @var {Object}\n         */\n        config      : null,\n\n\n    // ------------------------------------------------------------------------------------------------\n    // private methods\n\n        /**\n         * Initialize the FSM with a config object\n         *\n         * @private\n         * @param config\n         */\n        initialize:function (config)\n        {\n            // assign config\n            this.config     = config;\n\n            // pre-collate all states\n            addStates(this, 'from', config.events);\n            addStates(this, 'to', config.events);\n\n            // initial state\n            if( ! config.initial )\n            {\n                config.initial = this.states[0];\n            }\n\n            // add transitions\n            config.events.map( event =>\n            {\n                // shorthand\n                if(isString(event))\n                {\n                    let matches = event.match(/(\\w+)\\s*[\\|:=]\\s*(\\w+)\\s*([<>-])\\s*(\\w.*)/);\n                    let [,name, from, op, to] = matches;\n                    if(op === '-')\n                    {\n                        this.add(name, from, to);\n                        this.add(name, to, from);\n                        return;\n                    }\n                    if(op === '<')\n                    {\n                        [from, to] = [to, from];\n                    }\n                    this.add(name, from, to);\n                }\n\n                // keys\n                else\n                {\n                    this.add(event.name, event.from, event.to);\n                }\n            });\n\n            // add handlers\n            for(let name in config.handlers)\n            {\n                if(config.handlers.hasOwnProperty(name))\n                {\n                    this.on(name, config.handlers[name]);\n                }\n            }\n\n            // state\n            if( ! config.defer )\n            {\n                this.state = config.initial;\n            }\n\n            /**\n             * Sets the default order to run transition callbacks in\n             *\n             * start/leave/enter/end  -> event types\n             * to/action              -> targeted handlers (leave:red)\n             * *                      -> global handlers   (leave, or leave:*)\n             *\n             * @type {string[]} type.target\n             */\n            config.order = config.order || [\n                'start:*',\n                'start:action',\n                'leave:from',\n                'leave:*',\n                'enter:*',\n                'enter:to',\n                'end:action',\n                'end:*'\n            ];\n        },\n\n        /**\n         * Dispatch an event\n         *\n         * @param namespace\n         * @param type\n         */\n        update: function (namespace, type)\n        {\n            let event = namespace === 'system'\n                ? SystemEvent\n                : TransitionEvent;\n            this.dispatch(namespace + '.' + type, new event(type));\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // api\n\n        /**\n         * Attempt to run an action, resulting in a transition to a state\n         *\n         * @param   {string}    action\n         * @param   {*[]}       rest\n         * @returns {boolean}\n         */\n        do: function (action, ...rest)\n        {\n            if(this.can(action))\n            {\n                this.transition = Transition.create(this, action, rest);\n                this.update('system', 'update');\n                this.transition.exec();\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Attempt to go to a state\n         *\n         * Finds if an appropriate transition exists, then calls the related action if it does\n         *\n         * @param   {string}    state\n         * @returns {boolean}\n         */\n        go: function (state)\n        {\n            if(this.has(state))\n            {\n                var action = this.getActionForState(state);\n                if(action)\n                {\n                    return this.do(action);\n                }\n                this.config.debug && console.info('No transition exists from \"%s\" to \"%s\"', this.state, state);\n            }\n            else\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n            }\n            return false;\n        },\n\n        /**\n         * Query a transition to see if a named action is available\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        can: function (action)\n        {\n            if( ! this.actions.has(action) )\n            {\n                this.config.debug && console.warn('No such action \"%s\"', action);\n            }\n            return !! this.transitions.has(this.state, action);\n        },\n\n        /**\n         * Query a transition to see if a named action is unavailable\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        cannot: function (action)\n        {\n            return ! this.can(action);\n        },\n\n        /**\n         * Test if the current state is the same as the supplied one\n         *\n         * @param   {string}    state       A state name to compare against the current state\n         * @returns {boolean}\n         */\n        is: function (state)\n        {\n            if(this.states.indexOf(state) === -1)\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n            }\n            return state === this.state;\n        },\n\n        /**\n         * Test if a state exists\n         *\n         * @param   {string}    state\n         * @return  {boolean}\n         */\n        has: function(state)\n        {\n            return this.states.indexOf(state) !== -1;\n        },\n\n        /**\n         * Get the available \"to\" states for the current or supplied state\n         *\n         * @param   {string}    [state]     Optional name of a state to get states for. Defaults to the current state\n         * @returns {string[]}              An array of string states\n         */\n        getStatesFor: function (state = null)\n        {\n            state       = state || this.state;\n            let actions = this.getActionsFor(state, true);\n            return Object.keys(actions).map( name => actions[name] );\n        },\n\n        /**\n         * Get the available actions (or actions and states) for the current or supplied state\n         *\n         * @param   {string}    [state]     Optional name of a state to get actions for. Defaults to the current state\n         * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n         * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n         */\n        getActionsFor: function (state = null, asMap = false)\n        {\n            state       = state || this.state;\n            let actions = this.transitions.get(state || this.state);\n            if(asMap)\n            {\n                let states  = {};\n                actions.map( action =>\n                {\n                    states[action] = this.actions.get(action + '.' + state);\n                });\n                return states;\n            }\n            else\n            {\n                return actions;\n            }\n        },\n\n        getActionForState: function (state)\n        {\n            if(this.has(state))\n            {\n                let actions = this.getActionsFor(null, true);\n                for(let action in actions)\n                {\n                    if(actions[action] === state)\n                    {\n                        return action;\n                    }\n                }\n            }\n            return null;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // flags\n\n        /**\n         * Test if the FSM has started\n         *\n         * @returns {boolean}\n         */\n        isStarted: function ()\n        {\n            return this.state !== '';\n        },\n\n        /**\n         * Test if the FSM is transitioning\n         *\n         * @returns {boolean}\n         */\n        isTransitioning: function ()\n        {\n            return !! this.transition;\n        },\n\n        /**\n         * Test if the FSM is paused (whilst transitioning)\n         *\n         * @returns {boolean}\n         */\n        isPaused: function ()\n        {\n            return this.transition\n                ? this.transition.paused\n                : false;\n        },\n\n        /**\n         * Test if the FSM is on the \"final\" state\n         *\n         * @returns {boolean}\n         */\n        isComplete: function ()\n        {\n            return this.state === this.config.final;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // transitions\n\n        /**\n         * Pause any current transition\n         *\n         * @returns {StateMachine}\n         */\n        pause: function ()\n        {\n            if(this.transition)\n            {\n                this.transition.pause();\n                this.update('transition', 'pause');\n                this.update('system', 'update');\n            }\n            return this;\n        },\n\n        /**\n         * Resume any current transition\n         *\n         * @returns {StateMachine}\n         */\n        resume: function ()\n        {\n            if(this.transition)\n            {\n                this.update('transition', 'resume');\n                this.update('system', 'update');\n                this.transition.resume();\n            }\n            return this;\n        },\n\n        /**\n         * Cancel any current transition\n         *\n         * @returns {StateMachine}\n         */\n        cancel: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.from;\n                this.transition.clear();\n                delete this.transition;\n                this.update('transition', 'cancel');\n                this.update('system', 'update');\n            }\n            return this;\n        },\n\n        /**\n         * End any current transition, skipping remaining handlers\n         *\n         * @returns {StateMachine}\n         */\n        end: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.to;\n                this.transition.clear();\n                delete this.transition;\n                this.update('system', 'change');\n                if(this.isComplete())\n                {\n                    this.update('system', 'complete');\n                }\n                this.update('system', 'update');\n            }\n            return this;\n        },\n\n        /**\n         * Reset the FSM to the initial, or supplied, state\n         *\n         * @returns {StateMachine}\n         */\n        reset:function(initial)\n        {\n            this.state = initial || this.config.initial;\n            if(this.transition)\n            {\n                this.transition.clear();\n                delete this.transition;\n            }\n            this.update('system', 'reset');\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // actions\n\n        /**\n         * Add a transition event\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        add: function (action, from, to)\n        {\n            this.actions.set(action + '.' + from, to);\n            this.transitions.add(from, action);\n            addState(this, from);\n            addState(this, to);\n            return this;\n        },\n\n        remove: function (action, from, to)\n        {\n            this.states.remove(action, from);\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // handlers\n\n        /**\n         * Add an event handler\n         *\n         * Event handler signature:\n         *\n         * - namespace.type:target1 target2 target3 ...\n         *\n         * Valid event signatures:\n         *\n         * - system:(change|update|complete|reset)\n         * - action:(start|end)\n         * - state:(add|remove|leave|enter)\n         * - transition:(pause|resume|cancel)\n         *\n         * As event types are unique, they can be used without the namespace:\n         *\n         * - change\n         * - pause\n         * - start\n         * - end\n         * - leave:red\n         * - enter:blue green\n         * - start:next\n         * - end:back\n         *\n         * You can also just pass action or names to target individual state.leave / action.end events:\n         *\n         * - next\n         * - intro\n         *\n         * @param id\n         * @param fn\n         * @return {StateMachine}\n         */\n        on: function (id, fn)\n        {\n            let [namespace, type, targets] = parseHandler(this, id);\n\n            targets.map( target =>\n            {\n                // warn for invalid actions / states\n                if(target !== '*')\n                {\n                    if(namespace === 'state')\n                    {\n                        if(this.states.indexOf(target) === -1)\n                        {\n                            this.config.debug && console.warn('Warning assigning state.%s handler: no such state \"%s\"', type, target);\n                        }\n                    }\n                    else if(namespace === 'action')\n                    {\n                        if(!this.actions.has(target))\n                        {\n                            this.config.debug && console.warn('Warning assigning action.%s handler: no such action \"%s\"', type, target);\n                        }\n                    }\n                }\n\n                // check handler is a function\n                if(!isFunction(fn))\n                {\n                    throw new Error('Error assigning ' +namespace+ '.' +type+ ' handler; callback is not a Function', fn);\n                }\n\n                // assign\n                let path = getPath(namespace, type, target);\n                this.handlers.insert(path, fn);\n            });\n\n            return this;\n        },\n\n        off: function (id, fn)\n        {\n            let [namespace, type, targets] = parseHandler(this, id);\n            targets.map( target =>\n            {\n                let path = getPath(namespace, type, target);\n                this.handlers.remove(path, fn)\n            });\n        },\n\n        dispatch: function(path, event)\n        {\n            this.config.debug && console.info('StateMachine dispatch \"%s\"', path);\n            let handlers = this.handlers.get(path);\n            if(handlers)\n            {\n                // do we need to pass additional arguments?\n                handlers.map(fn => fn(event) );\n            }\n        }\n\n};\n\n/**\n * Parses config and adds unique state names to states array\n *\n * @param {StateMachine}    fsm\n * @param {string}          key\n * @param {Object[]}        transitions\n */\nfunction addStates(fsm, key, transitions)\n{\n    transitions.map( event => addState(fsm, event[key]) );\n}\n\nfunction addState (fsm, state)\n{\n    if (isString(state) && fsm.states.indexOf(state) === -1)\n    {\n        fsm.states.push(state);\n    }\n}\n\nfunction parseHandler(fsm, id)\n{\n    // get initial matches\n    let matches = id.match(/^(?:(\\w+)\\.)?(\\w+[-.\\w]*)(?::(.*))?/);\n    if(!matches)\n    {\n        throw new Error('Warning parsing event handler: invalid signature \"%s\"', id);\n    }\n    let [,namespace, type, target] = matches;\n\n    // determine namespace if not found\n    if(!namespace)\n    {\n        // check if shorthand global was passed\n        namespace = eventNamespaces[type];\n\n        // if event is still null, attempt to determine type from existing states or actions\n        if(!namespace)\n        {\n            if(fsm.states.indexOf(type) !== -1)\n            {\n                target      = type;\n                namespace   = 'state';\n                type        = 'enter';\n            }\n            else if(fsm.actions.has(type))\n            {\n                target      = type;\n                namespace   = 'action';\n                type        = 'start';\n            }\n            else\n            {\n                fsm.config.debug && console.warn('Warning parsing event handler: unable to map \"%s\" to a valid event or existing entity', id);\n            }\n        }\n    }\n\n    // determine targets\n    let targets = target\n        ? target.match(/[-*\\w_]+/g)\n        : ['*'];\n\n    // return\n    return [namespace, type, targets]\n}\n\nfunction getPath(namespace, type, target)\n{\n    return namespace === 'action' || namespace === 'state'\n        ? [namespace, target, type].join('.')\n        : namespace + '.' + type;\n}\n\nlet eventNamespaces =\n{\n    change  :'system',\n    update  :'system',\n    complete:'system',\n    reset   :'system',\n\n    add     :'state',\n    remove  :'state',\n    leave   :'state',\n    enter   :'state',\n\n    start   :'action',\n    end     :'action',\n\n    pause   :'transition',\n    resume  :'transition',\n    cancel  :'transition'\n};\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/StateMachine.js\n **/","import {isObject, isArray, isDefined, isUndefined} from './utils';\n\n/**\n * Utility class to create, modify and delete nested hashes and values\n *\n * @constructor\n */\nexport default function ValueMap (data)\n{\n    this.data = data || {};\n}\n\nValueMap.prototype =\n{\n    data: null,\n\n    set: function (path, value)\n    {\n        set(this.data, path, value);\n        return this;\n    },\n\n    add:function(path, value)\n    {\n        add(this.data, path, value);\n        return this;\n    },\n\n    insert:function(path, value)\n    {\n        insert(this.data, path, value);\n        return this;\n    },\n\n    get:function(path)\n    {\n        return get(this.data, path);\n    },\n\n    has: function (path, value = undefined)\n    {\n        return has(this.data, path, value)\n    },\n\n    indexOf: function (path, value)\n    {\n        return indexOf(this.data, path, value)\n    },\n\n    remove: function (path, value = undefined)\n    {\n        remove(this.data, path, value);\n        return this;\n    },\n\n    keys:function(path)\n    {\n        return Object.keys(get(this.data, path));\n    },\n\n    values:function(path)\n    {\n        return values(this.data, path);\n    }\n\n};\n\nfunction create(obj, keys)\n{\n    let key;\n    while(keys.length)\n    {\n        key = keys.shift();\n        if( ! isObject(obj[key]) )\n        {\n            obj[key] = {};\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n\nexport function set(obj, path, value, index = -1)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    obj[key] = value;\n}\n\nfunction add(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    obj[key].push(value);\n}\n\nfunction insert(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    let parent = obj[key],\n        index = parent.indexOf(value);\n    if(index === -1)\n    {\n        parent.push(value);\n    }\n    else\n    {\n        parent[index] = value;\n    }\n}\n\nexport function get(obj, path)\n{\n    if(isUndefined(path) || path == '')\n    {\n        return obj;\n    }\n\n    let key,\n        keys = String(path).split('.');\n    while(keys.length > 1)\n    {\n        key = keys.shift();\n        if( ! obj.hasOwnProperty(key) )\n        {\n            return;\n        }\n        obj = obj[key];\n    }\n    key = keys.shift();\n    return obj[key];\n}\n\nexport function has(obj, path, value)\n{\n    let parent = get(obj, path);\n    return !! (isArray(parent) && isDefined(value)\n        ? parent.indexOf(value) !== -1\n        : isUndefined(value)\n            ? isDefined(parent)\n            : parent === value);\n}\n\nexport function indexOf (obj, path, value)\n{\n    let arr = get(obj, path);\n    if(isArray(arr))\n    {\n        return arr.indexOf(value);\n    }\n    return -1;\n}\n\nexport function remove(obj, path, value)\n{\n    let parent = obj,\n        keys = String(path || '').split('.'),\n        key = keys.pop();\n\n    if(keys.length)\n    {\n        parent = get(obj, keys.join('.'))\n    }\n    if(isDefined(value) && isArray(parent[key]))\n    {\n        parent = parent[key];\n        var index = parent.indexOf(value);\n        if(index > -1)\n        {\n            parent.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n    else\n    {\n        if(isObject(parent) && obj.hasOwnProperty(key))\n        {\n            delete parent[key];\n            return true;\n        }\n    }\n    return false\n}\n\nexport function values(obj, path)\n{\n    var values = [];\n    var target = get(obj, path);\n    if(isObject(target))\n    {\n        for(var name in target)\n        {\n            if(target.hasOwnProperty(name))\n            {\n                values.push(target[name]);\n            }\n        }\n    }\n    return values;\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/ValueMap.js\n **/","export function isObject (value)\n{\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport function isArray (value)\n{\n    return value instanceof Array;\n}\n\nexport function isString (value)\n{\n    return typeof value === 'string';\n}\n\nexport function isFunction(value)\n{\n    return value instanceof Function;\n}\n\nexport function isDefined (value)\n{\n    return typeof value !== 'undefined';\n}\n\nexport function isUndefined (value)\n{\n    return typeof value === 'undefined';\n}\n\nexport function trim (value)\n{\n    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/utils.js\n **/","import Events from './Events';\nimport { isFunction } from './utils/utils';\n\n/**\n * Transition class\n *\n * Responsible for managing events in the flow from state to state.\n *\n * This adds all handlers for the current action start/end and state from/to to an array:\n *\n * - <namespace>.<target>.<type>[]\n *\n * So going from state \"a\" to state \"b\" with action \"next\" should build:\n *\n * - action.*.start[]\n * - action.next.start[]\n * - state.a.leave[]\n * - state.*.leave[]\n * - state.*.enter[]\n * - state.b.enter[]\n * - action.next.end[]\n * - action.*.end[]\n *\n * This can be changed by passing in an order array in fsm.config\n *\n * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n *\n * From a callback, you can:\n *\n * - return false to cancel the transition\n * - return true to pause the transition\n * - not return a value (the transition continues)\n *\n * Transitions can also be paused, resumed, or cancelled by calling\n * the appropriate method on, or from:\n *\n * - the event\n * - the transition\n * - the state machine\n *\n * Cancelled transitions will reset the FSM to the previous \"from\" state\n *\n * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n *\n * @param {string}          action\n * @param {string}          from\n * @param {string}          to\n * @param {Function[]}      handlers\n * @param {Object}          callbacks\n */\nfunction Transition (action, from, to, handlers, callbacks)\n{\n    this.action     = action;\n    this.from       = from;\n    this.to         = to;\n    this.handlers   = handlers;\n    this.callbacks  = callbacks;\n}\n\nTransition.prototype =\n{\n    action      : '',\n    from        : '',\n    to          : '',\n    handlers    : null,\n    callbacks   : null,\n    paused      : false,\n\n    clear: function ()\n    {\n        this.paused = false;\n        this.handlers = [];\n    },\n\n    /**\n     * Execute the next event's callbacks\n     * @returns {*}\n     */\n\texec: function ()\n\t{\n\t    if( ! this.paused )\n        {\n            if(this.handlers.length)\n            {\n                var handler = this.handlers.shift();\n                var state = handler();\n                if(state === false)\n                {\n                    return this.callbacks.cancel();\n                }\n                if(state === true)\n                {\n                    return this.callbacks.pause();\n                }\n                this.exec();\n            }\n            else\n            {\n                this.callbacks.end();\n            }\n        }\n        return this;\n\t},\n\n    pause: function ()\n    {\n        this.paused = true;\n        return this;\n    },\n\n    resume: function ()\n    {\n        this.paused = false;\n        return this.exec();\n    }\n};\n\n\nexport default\n{\n    /**\n     * Create the Transition object\n     *\n     * - Set up variables, callbacks and queue\n     * - Determine paths to relevant callbacks\n     * - Build State and Action Event objects\n     * - Pre-bind all handlers\n     * - Append to queue\n     *\n     * @param {StateMachine}    fsm\n     * @param {string}          action\n     * @param {Array}           params\n     * @returns {Transition}\n     */\n    create:function (fsm, action, params)\n    {\n        // transition\n        var queue   = [];\n        var scope   = fsm.scope;\n        var from    = fsm.state;\n        var to      = fsm.actions.get(action)[from];\n        var callbacks =\n        {\n            cancel   :fsm.cancel.bind(fsm),\n            pause    :fsm.pause.bind(fsm),\n            resume   :fsm.resume.bind(fsm),\n            end      :fsm.end.bind(fsm)\n        };\n\n        // handle \"to\" being a function\n        if(isFunction(to))\n        {\n            let actions = fsm.getActionsFor();\n            let state   = to.apply(scope, [actions].concat(params));\n            let action  = fsm.getActionsFor(state);\n            // TODO debug this! It's wrong\n            if( ! action )\n            {\n                throw new Error('Cannot go to state \"' +state+ '\" from current state \"' +from+ '\"');\n            }\n        }\n\n        // build handlers array\n        fsm.config.order.map( token =>\n        {\n            // determine path variables\n            let [type, source]      = token.split(':'); // i.e. start.*, enter:to, end:action\n            let namespace           = /^(start|end)$/.test(type)\n                                        ? 'action'\n                                        : 'state';\n            let target;\n            if(source === '*')\n            {\n                target = '*';\n            }\n            else if(namespace == 'action')\n            {\n                target = action;\n            }\n            else\n            {\n                target = type === 'leave'\n                    ? from\n                    : to;\n            }\n\n            // get handlers\n            let path = [namespace, target, type].join('.');\n\n            let handlers = fsm.handlers.get(path);\n            if(handlers)\n            {\n                // pre-bind handlers, scopes and params\n                // this way scope and params don't need to be passed around\n                handlers = handlers.map( handler =>\n                {\n                    return function()\n                    {\n                        let event = Events.create(namespace, type, target, from, to, callbacks);\n                        handler.apply(scope, [event].concat(params));\n                    }\n                });\n\n                // add to queue\n                queue = queue.concat(handlers);\n            }\n\n        });\n\n        // create\n        return new Transition(action, from, to, queue, callbacks);\n    }\n\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/Transition.js\n **/","// ------------------------------------------------------------------------------------------------\n// setup\n\n    function noop () { }\n\n    /**\n     * @prop {string}  namespace  The Event namespace; i.e. state or action\n     * @prop {string}  type       The Event type;      i.e. leave/enter (state) or start/end (action)\n     * @prop {string}  target     The Event target;    i.e. intro (state), next (action), or * (all states or types)\n     * @prop {string}  from       The from state\n     * @prop {string}  to         The to state\n     */\n    let event =\n    {\n        // properties\n        namespace   : null,\n        type        : null,\n        target      : null,\n        from        : null,\n        to          : null,\n\n        // transition callbacks\n        pause       : noop,\n        resume      : noop,\n        cancel      : noop,\n        complete    : noop\n    };\n\n    function initialize (event, namespace, type, target, from, to, callbacks)\n    {\n        event.namespace = namespace;\n        event.type      = type;\n        event.target    = target;\n        event.from      = from;\n        event.to        = to;\n\n        event.pause     = callbacks.pause;\n        event.resume    = callbacks.resume;\n        event.cancel    = callbacks.cancel;\n        event.complete  = callbacks.complete;\n    }\n\n    export default\n    {\n        create: function(namespace, type, target, from, to, callbacks)\n        {\n            var fn = namespace == 'state'\n                ? StateEvent\n                : ActionEvent;\n            return new fn(type, target, from, to, callbacks);\n        }\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// ActionEvent\n\n    export function ActionEvent (type, target, from, to, callbacks)\n    {\n        initialize(this, 'action' ,type, target, from, to, callbacks);\n    }\n    ActionEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// StateEvent\n\n    export function StateEvent (type, target, from, to, callbacks)\n    {\n        initialize(this, 'state' ,type, target, from, to, callbacks);\n    }\n    StateEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// SystemEvent\n\n    export function SystemEvent (type)\n    {\n        this.type = type;\n    }\n\n    SystemEvent.prototype =\n    {\n        namespace: 'system',\n        type: ''\n    };\n\n\n// ------------------------------------------------------------------------------------------------\n// TransitionEvent\n\n    export function TransitionEvent (type)\n    {\n        this.type = type;\n    }\n\n    TransitionEvent.prototype =\n    {\n        namespace: 'transition',\n        type: ''\n    };\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/Events.js\n **/"],"sourceRoot":""}