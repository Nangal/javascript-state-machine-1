{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///webpack/bootstrap 1c04c4d40872d5d1d8df?5bb7","webpack:///./src/core/utils/utils.js?57f9","webpack:///./src/StateMachine.js","webpack:///./src/core/classes/Config.js","webpack:///./src/core/maps/HandlerMap.js","webpack:///./src/core/maps/ValueMap.js","webpack:///./src/core/objects/events.js","webpack:///./src/core/parsers/HandlerParser.js","webpack:///./src/core/parsers/HandlerMeta.js","webpack:///./src/core/lexer/Lexer.js","webpack:///./src/core/lexer/Rule.js","webpack:///./src/core/lexer/Token.js","webpack:///./src/core/objects/errors.js","webpack:///./src/core/maps/TransitionMap.js","webpack:///./src/core/parsers/TransitionParser.js","webpack:///./src/core/parsers/TransitionMeta.js","webpack:///./src/core/classes/Transition.js"],"names":["isObject","isArray","isString","isFunction","isDefined","isUndefined","trim","diff","toHash","value","Object","prototype","toString","call","Array","Function","String","replace","a","b","da","filter","indexOf","v","db","concat","values","reduce","obj","StateMachine","options","transitions","handlers","initialize","config","transition","state","map","parse","tx","add","action","from","to","initial","getStates","name","hasOwnProperty","on","methods","scope","start","trigger","reset","cancel","do","canDo","isPaused","rest","create","exec","go","force","has","clear","end","getActionFor","errors","console","warn","getActionsFrom","canGo","hasState","is","isStarted","isTransitioning","paused","isComplete","final","pause","resume","arguments","length","updateTransitions","remove","id","fn","invalid","forEach","meta","path","off","result","Error","message","target","error","namespace","hasAction","split","apply","constructor","getDefaultOrder","fsm","method","callback","statesBefore","actionsBefore","getActions","statesAfter","actionsAfter","states","actions","Config","match","order","defaults","assign","HandlerMap","insert","get","type","event","test","ValueMap","data","set","undefined","keys","key","shift","index","pop","push","parent","arr","join","splice","ActionEvent","StateEvent","SystemEvent","TransitionEvent","isSystem","token","isTransition","expandGroups","input","rx","matches","group","items","item","output","addPath","results","_id","addError","_defaults","parser","patterns","alias","namespaced","oneAction","oneActionEvent","anyActionEvent","oneState","oneStateEvent","anyStateEvent","oneStateAction","lexer","paths","parsePath","tokens","process","HandlerMeta","Lexer","rules","addRule","source","next","substr","some","rule","LexerError","Rule","Token","slice","ParseError","TransitionMap","update","asMap","wildcard","getStatesFrom","getStateFor","hasTransition","getError","stack","op","TransitionMeta","Transition","unpause","handler","params","vars","queue","all","Event"],"mappings":"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","file":"StateMachine.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 1c04c4d40872d5d1d8df\n **/","export function isObject (value)\n{\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport function isArray (value)\n{\n    return value instanceof Array;\n}\n\nexport function isString (value)\n{\n    return typeof value === 'string';\n}\n\nexport function isFunction(value)\n{\n    return value instanceof Function;\n}\n\nexport function isDefined (value)\n{\n    return typeof value !== 'undefined';\n}\n\nexport function isUndefined (value)\n{\n    return typeof value === 'undefined';\n}\n\nexport function trim (value)\n{\n    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n}\n\nexport function diff (a, b)\n{\n    var da = b.filter( v => a.indexOf(v) < 0 );\n    var db = a.filter( v => b.indexOf(v) < 0 );\n    return db.concat(da)\n}\n\nexport function toHash(values) {\n    return values.reduce(function (obj, value) {\n        obj[value] = true;\n        return obj;\n    }, {})\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/utils/utils.js\n **/","import Config from './core/classes/Config';\nimport HandlerMap from './core/maps/HandlerMap';\nimport TransitionMap from './core/maps/TransitionMap';\nimport Transition from './core/classes/Transition';\nimport { diff } from './core/utils/utils';\n\n\n/**\n * StateMachine constructor\n *\n * @param   {Object|null}    options\n * @constructor\n */\nfunction StateMachine (options)\n{\n    this.transitions    = new TransitionMap();\n    this.handlers       = new HandlerMap(this);\n    this.initialize(options);\n}\n\n/**\n * StateMachine prototype\n *\n * The property examples below illustrate a 4-state machine, with states:\n *\n * - intro > settings > summary > end\n *\n * And actions:\n *\n * - back | next | restart | finish\n */\nStateMachine.prototype =\n{\n    // -----------------------------------------------------------------------------------------------------------------\n    // properties\n\n        /**\n         * Configuration object\n         *\n         * @var {Config}\n         */\n        config      : null,\n\n        /**\n         * Map of all transitions\n         *\n         * @var {TransitionMap}\n         */\n        transitions : null,\n\n        /**\n         * Map of all handlers\n         *\n         * @var {HandlerMap}\n         */\n        handlers    : null,\n\n        /**\n         * Any active Transition object that is driving the state change\n         *\n         * @var {Transition}\n         */\n        transition  : null,\n\n        /**\n         * The current state\n         *\n         * @var {string}\n         */\n        state       : '',\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // private methods\n\n        /**\n         * Initialize the FSM with options\n         *\n         * @private\n         * @param options\n         */\n        initialize:function (options)\n        {\n            // state\n            this.state          = '';\n\n            // build config\n            let config  = new Config(options);\n            this.config = config;\n\n            // pre-process all transitions\n            let transitions = [];\n            if(Array.isArray(options.transitions))\n            {\n                options.transitions.map( tx =>\n                {\n                    transitions = transitions.concat(this.transitions.parse(tx));\n                });\n            }\n\n            // add transitions\n            transitions.map( transition =>\n            {\n                this.transitions.add(transition.action, transition.from, transition.to);\n            });\n\n            // get initial state (must be done after state collation)\n            if( ! config.initial )\n            {\n                config.initial = this.transitions.getStates()[0];\n            }\n\n            // add handlers\n            if(options.handlers)\n            {\n                for(let name in options.handlers)\n                {\n                    if(options.handlers.hasOwnProperty(name))\n                    {\n                        this.on(name, options.handlers[name]);\n                    }\n                }\n            }\n\n            // add methods\n            if(options.methods)\n            {\n                if(!this.config.scope)\n                {\n                    this.config.scope = this;\n                }\n                for(var name in options.methods)\n                {\n                    if(options.methods.hasOwnProperty(name) && !this.hasOwnProperty(name))\n                    {\n                        this[name] = options.methods[name];\n                    }\n                }\n            }\n\n            // start\n            if(this.config.start)\n            {\n                this.start();\n            }\n\n            // return\n            return this;\n        },\n\n        start: function ()\n        {\n            this.state = this.config.initial;\n            this.handlers.trigger('system.start');\n            if(this.state)\n            {\n                this.handlers.trigger('system.change', this.state);\n            }\n            return this;\n        },\n\n        /**\n         * Reset the FSM to the initial, or supplied, state\n         *\n         * @returns {StateMachine}\n         */\n        reset:function(initial = '')\n        {\n            let state = initial || this.config.initial;\n            this.handlers.trigger('system.reset');\n            if(this.transition)\n            {\n                this.transition.cancel();\n                delete this.transition;\n            }\n            if(this.state !== state)\n            {\n                this.state = state;\n                this.handlers.trigger('system.change', this.state);\n            }\n            return this;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // api\n\n        /**\n         * Attempt to run an action, resulting in a transition to a state\n         *\n         * @param   {string}    action\n         * @param   {*[]}       rest\n         * @returns {boolean}\n         */\n        do: function (action, ...rest)\n        {\n            if(this.canDo(action) && !this.isPaused())\n            {\n                this.transition = Transition.create(this, action, rest);\n                this.transition.exec();\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Attempt to go to a state\n         *\n         * Queries TransitionMap instance to see if a transition exists, then calls the related action if it does\n         *\n         * @param   {string}    state\n         * @param   {boolean}   [force]\n         * @returns {boolean}\n         */\n        go: function (state, force = false)\n        {\n            if(this.has(state))\n            {\n                if(force)\n                {\n                    if(this.transition)\n                    {\n                        this.transition.clear();\n                    }\n                    this.transition = Transition.force(this, state);\n                    return this.end();\n                }\n                var action = this.transitions.getActionFor(this.state, state);\n                if(action)\n                {\n                    return this.do(action);\n                }\n                this.config.errors > 0 && console.warn('No transition exists from \"%s\" to \"%s\"', this.state, state);\n                return false;\n            }\n            this.config.errors > 0 && console.warn('No such state \"%s\"', state);\n            return false;\n        },\n\n        /**\n         * Query transition map to see if a named action is available\n         *\n         * @param   {string}        action\n         * @returns {boolean}\n         */\n        canDo: function (action)\n        {\n            return this.transitions.getActionsFrom(this.state).indexOf(action) !== -1;\n        },\n\n        /**\n         * Query transition map to see if a state is available to go to\n         *\n         * @param to\n         * @return {boolean}\n         */\n        canGo: function (to)\n        {\n            return this.transitions.getActionFor(this.state, to) !== null;\n        },\n\n        /**\n         * Test if a state exists\n         *\n         * @param   {string}    state\n         * @return  {boolean}\n         */\n        has: function(state)\n        {\n            return this.transitions.hasState(state);\n        },\n\n        /**\n         * Test if the current state is the same as the supplied one\n         *\n         * @param   {string}    state       A state name to compare against the current state\n         * @returns {boolean}\n         */\n        is: function (state)\n        {\n            return state === this.state;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // flags\n\n        /**\n         * Test if the FSM has started\n         *\n         * @returns {boolean}\n         */\n        isStarted: function ()\n        {\n            return this.state !== '';\n        },\n\n        /**\n         * Test if the FSM is transitioning\n         *\n         * @returns {boolean}\n         */\n        isTransitioning: function ()\n        {\n            return !! this.transition;\n        },\n\n        /**\n         * Test if the FSM is paused (whilst transitioning)\n         *\n         * @returns {boolean}\n         */\n        isPaused: function ()\n        {\n            return this.transition\n                ? this.transition.paused\n                : false;\n        },\n\n        /**\n         * Test if the FSM is on the \"final\" state\n         *\n         * @returns {boolean}\n         */\n        isComplete: function ()\n        {\n            return this.state === this.config.final;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // transitions\n\n        /**\n         * Pause any current transition\n         *\n         * @returns {StateMachine}\n         */\n        pause: function ()\n        {\n            if(this.transition && !this.isPaused())\n            {\n                this.transition.pause();\n            }\n            return this;\n        },\n\n        /**\n         * Resume any current transition\n         *\n         * @returns {StateMachine}\n         */\n        resume: function ()\n        {\n            if(this.transition && this.isPaused())\n            {\n                this.transition.resume();\n            }\n            return this;\n        },\n\n        /**\n         * Cancel any current transition\n         *\n         * @returns {StateMachine}\n         */\n        cancel: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.from;\n                this.transition.cancel();\n                delete this.transition;\n            }\n            return this;\n        },\n\n        /**\n         * End any current transition, skipping remaining handlers\n         *\n         * @returns {StateMachine}\n         */\n        end: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.to;\n                this.transition.clear();\n                delete this.transition;\n                this.handlers.trigger('system.change', this.state);\n                if(this.isComplete())\n                {\n                    this.handlers.trigger('system.complete');\n                }\n            }\n            return this;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // actions\n\n        /**\n         * Add a transition\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        add: function (action, from, to)\n        {\n            // 1 argument: shorthand transition, i.e 'next : a > b'\n            if(arguments.length === 1)\n            {\n                var transitions = this.transitions.parse(action);\n                transitions.map( tx => this.add(tx.action, tx.from, tx.to));\n                return this;\n            }\n\n            // 3 arguments: longhand transition\n            updateTransitions(this, 'add', () => this.transitions.add(action, from, to) );\n            return this;\n        },\n\n        /**\n         * Remove a state\n         *\n         * @param   {string}    state\n         * @return  {StateMachine}\n         */\n        remove: function (state)\n        {\n            this.handlers.remove('state.' + state);\n            updateTransitions(this, 'remove', () => this.transitions.remove(state) );\n            return this;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // handlers\n\n        /**\n         * Add an event handler\n         *\n         * Event handler signatures are built from the following grammar:\n         *\n         * - token      foo\n         * - property   .foo\n         * - event      :foo\n         * - action     @foo\n         * - targets    (foo bar baz)\n         *\n         * For example:\n         *\n         * - change\n         * - transition.pause\n         * - next:end\n         * - (a b)@next\n         * - a@next\n         *\n         * The main event types are unique, so can be used without the namespace:\n         *\n         * - change\n         * - pause\n         * - complete\n         * - ...\n         *\n         * If your states and events are unique, they can also be used without qualification.\n         *\n         * See docs and demo for more information\n         *\n         * @param   {string}        id\n         * @param   {Function}      fn\n         * @return  {StateMachine}\n         */\n        on: function (id, fn)\n        {\n            this.parse(id, this.config.invalid, this.config.errors)\n                .forEach( meta => this.handlers.add(meta.path, fn) );\n            return this;\n        },\n\n        off: function (id, fn)\n        {\n            this.parse(id, this.config.invalid, this.config.errors)\n                .forEach( meta => this.handlers.remove(meta.path, fn) );\n            return this;\n        },\n\n    \n    // -----------------------------------------------------------------------------------------------------------------\n    // utilities\n\n        /**\n         * Parses a handler id string into HandlerMeta objects\n         *\n         * @param   {string}    id\n         * @param   {boolean}   invalid\n         * @param   {number}    errors\n         * @returns {HandlerMeta[]}\n         */\n        parse: function (id, invalid = false, errors = 0)\n        {\n            return this.handlers.parse(id).filter(result =>\n            {\n                // picks up unrecognised handlers, namespaces, etc\n                if(result instanceof Error)\n                {\n                    if(errors == 2)\n                    {\n                        throw result;\n                    }\n                    errors == 1 && console.warn(result.message);\n                    return false;\n                }\n\n                // picks up unrecognised states and actions\n                if(result.target !== '*')\n                {\n                    let error = '';\n\n                    if(result.namespace === 'state')\n                    {\n                        if(!this.transitions.hasState(result.target))\n                        {\n                            error = 'Unrecognised state \"' +result.target+ '\" in handler \"' +result.id+ '\"';\n                        }\n                    }\n                    else if(result.namespace === 'action')\n                    {\n                        if(!this.transitions.hasAction(result.target))\n                        {\n                            error = 'Unrecognised action \"' +result.target+ '\" in handler \"' +result.id+ '\"';\n                        }\n                    }\n                    else if(result.namespace === 'state/action')\n                    {\n                        // variables\n                        let [state, action] = result.target.split('@');\n\n                        // test for state and action\n                        if(!this.transitions.hasState(state))\n                        {\n                            error = 'Unrecognised state \"' +state+ '\" in handler \"' +result.id+ '\"';\n                        }\n                        if(!this.transitions.hasAction(action))\n                        {\n                            error = 'Unrecognised action \"' +action+ '\" in handler \"' +result.id+ '\"';\n                        }\n                    }\n\n                    // if we have an error, the result was not an existing state or action\n                    if(error)\n                    {\n                        if(errors == 2)\n                        {\n                            throw new Error(error);\n                        }\n                        errors == 1 && console.warn(error);\n                        return !!invalid;\n                    }\n                }\n\n                // must be valid\n                return true\n            });\n        },\n\n        trigger: function (id, ...rest)\n        {\n            this.handlers.parse(id).map( meta => this.handlers.trigger.apply(this.handlers, [meta.path, ...rest]) );\n            return this;\n        }\n\n};\n\nStateMachine.prototype.constructor = StateMachine;\n\nexport default StateMachine;\n\n\n// ---------------------------------------------------------------------------------------------------------------------\n// static methods\n\n    /**\n     * Factory method\n     *\n     * @param   options\n     * @returns {StateMachine}\n     */\n    StateMachine.create = function(options)\n    {\n        return new StateMachine(options);\n    };\n\n    /**\n     * Gets the default order events should be called in\n     * @returns {string[]}\n     */\n    StateMachine.getDefaultOrder = function ()\n    {\n        return [\n            'action.*.start',\n            'action.{action}.start',\n            'state.*.{action}',\n            'state.{from}.{action}',\n            'state.{from}.leave',\n            'state.*.leave',\n            'state.*.enter',\n            'state.{to}.enter',\n            'action.{action}.end',\n            'action.*.end'\n        ];\n    };\n\n\n// ---------------------------------------------------------------------------------------------------------------------\n// helper functions\n\n    /**\n     * Utility method to update transitions and dispatch events\n     *\n     * Saves duplicating the following code in both add() and remove() methods\n     *\n     * @param   {StateMachine}  fsm\n     * @param   {string}        method\n     * @param   {Function}      callback\n     */\n    function updateTransitions(fsm, method, callback)\n    {\n        var statesBefore    = fsm.transitions.getStates();\n        var actionsBefore   = fsm.transitions.getActions();\n        callback();\n        var statesAfter     = fsm.transitions.getStates();\n        var actionsAfter    = fsm.transitions.getActions();\n\n        // calculate differences\n        var states          = diff(statesBefore, statesAfter);\n        var actions         = diff(actionsBefore, actionsAfter);\n\n        // dispatch events\n        states.map ( state  => fsm.handlers.trigger('system.state.'  + method, state) );\n        actions.map( action => fsm.handlers.trigger('system.action.' + method, action) );\n    }\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/StateMachine.js\n **/","import StateMachine from '../../StateMachine';\n\nexport default function Config (options)\n{\n    'scope start initial final invalid errors'\n        .match(/\\w+/g)\n        .map( name =>\n        {\n            if(options.hasOwnProperty(name))\n            {\n                this[name] = options[name];\n            }\n        });\n\n    // order\n    this.order      = options.order || StateMachine.getDefaultOrder();\n\n    // defaults\n    this.defaults   = Object.assign({\n\n        // allow user to specify alternate triggers for event and action ids\n        action      :'start',\n        state       :'enter'\n\n    }, options.defaults);\n}\n\nConfig.prototype =\n{\n    /**\n     * An optional scope to run handler functions in\n     *\n     * @var object\n     */\n    scope       : null,\n\n    /**\n     * A boolean to automatically start the state machine in the initial state\n     *\n     * @var boolean\n     */\n    start       : true,\n\n    /**\n     * A string to indicate which state to start on; defaults to ''\n     *\n     * @var string\n     */\n    initial     : '',\n\n    /**\n     * A string indicating the state to trigger a complete event; defaults to ''\n     *\n     * @var string\n     */\n    final       : '',\n\n    /**\n     * A boolean to allow non-existent states and actions to be added to the handlers object; defaults to false (disallow)\n     *\n     * @var boolean\n     */\n    invalid     : false,\n\n    /**\n     * A number indicating how to handle invalid or erroneous actions; defaults to 1 (warn)\n     *\n     *  - 0 : quiet\n     *  - 1 : console.warn()\n     *  - 2 : throw an error\n     *\n     * @var number\n     */\n    errors      : 1,\n\n    /**\n     * The order to run transition callbacks in\n     *\n     * @type {string[]} type.target\n     */\n    order       : null,\n\n    /**\n     * Sets defaults for various declarations\n     *\n     * Available options are:\n     *\n     * - action: (start|end)\n     * - state: (enter|leave)\n     *\n     * @type {Object}\n     */\n    defaults    : null,\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/classes/Config.js\n **/","import ValueMap from './ValueMap';\nimport { SystemEvent, TransitionEvent, StateEvent, ActionEvent } from '../objects/events';\nimport { isFunction } from '../utils/utils';\n\nimport parseHandler from '../parsers/HandlerParser';\n\nfunction HandlerMap (fsm)\n{\n    this.fsm    = fsm;\n    this.map    = new ValueMap();\n}\n\nHandlerMap.prototype =\n{\n\n\tfsm: null,\n\n\tmap: null,\n\n    /**\n     * Parse event handler grammar into a HandlerMeta structure\n     *\n     * @param   {string}        id      The handler id to parse, i.e. '@next', 'intro:end', 'change', etc\n     * @returns {HandlerMeta[]}\n     */\n    parse: function (id)\n    {\n        return parseHandler(id, this.fsm.config.defaults);\n    },\n\n    /**\n     * Directly add a new handler\n     *\n     * @param   {string}    path    A 'namespace.target.type' target path to add a handler to\n     * @param   {Function}  fn      A callback function\n     * @returns {HandlerMap}\n     */\n    add: function (path, fn)\n    {\n        // check handler is a function\n        if(!isFunction(fn))\n        {\n            throw new Error('Error assigning \"' +path+ '\" handler; callback is not a function', fn);\n        }\n\n        this.map.insert(path, fn);\n        return this;\n    },\n\n    /**\n     * Directly remove a handler target\n     *\n     * @param   {string}    path    A 'namespace.target.type' parent to a handler removed from\n     * @param   {Function}  fn      The instance of the callback function\n     * @returns {HandlerMap}\n     */\n    remove: function (path, fn)\n    {\n        this.map.remove(path, fn);\n        return this;\n    },\n\n    /**\n     * Get all handlers for a valid target path\n     *\n     * @param   {string}    path    A 'namespace.target.type' target path\n     * @returns {Function[]}        An array of callback functions\n     */\n    get:function(path)\n    {\n        return this.map.get(path);\n    },\n\n    /**\n     * Dispatch an event\n     *\n     * @param   {string}    path\n     * @param   {*}         value\n     * @returns {StateMachine}\n     */\n    trigger: function (path, value = null)\n    {\n        // create lookup path\n        let [namespace, type, method] = path.match(/\\w+/g);\n\n        // build event\n        let event;\n        if(/^system\\.(state|action)\\./.test(path))\n        {\n            event = type === 'state'\n                ? new StateEvent(method, value)\n                : new ActionEvent(method, value);\n        }\n        else\n        {\n            event = namespace === 'system'\n                ? new SystemEvent(type, value)\n                : new TransitionEvent(type);\n        }\n\n        // dispatch\n        let handlers = this.map.get(path);\n        if(handlers)\n        {\n            handlers.map(fn => fn(event, this.fsm) );\n        }\n    }\n\n};\n\nexport default HandlerMap;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/HandlerMap.js\n **/","import {isObject, isArray, isDefined, isUndefined} from '../utils/utils';\n\n/**\n * Utility class to create, modify and delete nested hashes and values\n *\n * @constructor\n */\nexport default function ValueMap (data)\n{\n    this.data = data || {};\n}\n\nValueMap.prototype =\n{\n    data: null,\n\n    set: function (path, value)\n    {\n        set(this.data, path, value);\n        return this;\n    },\n\n    add:function(path, value)\n    {\n        add(this.data, path, value);\n        return this;\n    },\n\n    insert:function(path, value)\n    {\n        insert(this.data, path, value);\n        return this;\n    },\n\n    get:function(path)\n    {\n        return get(this.data, path);\n    },\n\n    has: function (path, value = undefined)\n    {\n        return has(this.data, path, value)\n    },\n\n    indexOf: function (path, value)\n    {\n        return indexOf(this.data, path, value)\n    },\n\n    remove: function (path, value = undefined)\n    {\n        remove(this.data, path, value);\n        return this;\n    },\n\n    keys:function(path)\n    {\n        return Object.keys(get(this.data, path));\n    },\n\n    values:function(path)\n    {\n        return values(this.data, path);\n    }\n\n};\n\nfunction create(obj, keys)\n{\n    let key;\n    while(keys.length)\n    {\n        key = keys.shift();\n        if( ! isObject(obj[key]) )\n        {\n            obj[key] = {};\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n\nexport function set(obj, path, value, index = -1)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    obj[key] = value;\n}\n\nfunction add(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    obj[key].push(value);\n}\n\nfunction insert(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    let parent = obj[key],\n        index = parent.indexOf(value);\n    if(index === -1)\n    {\n        parent.push(value);\n    }\n    else\n    {\n        parent[index] = value;\n    }\n}\n\nexport function get(obj, path)\n{\n    if(isUndefined(path) || path == '')\n    {\n        return obj;\n    }\n\n    let key,\n        keys = String(path).split('.');\n    while(keys.length > 1)\n    {\n        key = keys.shift();\n        if( ! obj.hasOwnProperty(key) )\n        {\n            return;\n        }\n        obj = obj[key];\n    }\n    key = keys.shift();\n    return obj[key];\n}\n\nexport function has(obj, path, value)\n{\n    let parent = get(obj, path);\n    return !! (isArray(parent) && isDefined(value)\n        ? parent.indexOf(value) !== -1\n        : isUndefined(value)\n            ? isDefined(parent)\n            : parent === value);\n}\n\nexport function indexOf (obj, path, value)\n{\n    let arr = get(obj, path);\n    if(isArray(arr))\n    {\n        return arr.indexOf(value);\n    }\n    return -1;\n}\n\nexport function remove(obj, path, value)\n{\n    let parent = obj,\n        keys = String(path || '').split('.'),\n        key = keys.pop();\n\n    if(keys.length)\n    {\n        parent = get(obj, keys.join('.'))\n    }\n    if(isDefined(value) && isArray(parent[key]))\n    {\n        let target = parent[key];\n        var index = target.indexOf(value);\n        if(index > -1)\n        {\n            target.splice(index, 1);\n            if(target.length === 0)\n            {\n                delete parent[key];\n            }\n            return true;\n        }\n        return false;\n    }\n    else\n    {\n        if(isObject(parent) && obj.hasOwnProperty(key))\n        {\n            delete parent[key];\n            return true;\n        }\n    }\n    return false\n}\n\nexport function values(obj, path)\n{\n    var values = [];\n    var target = get(obj, path);\n    if(isObject(target))\n    {\n        for(var name in target)\n        {\n            if(target.hasOwnProperty(name))\n            {\n                values.push(target[name]);\n            }\n        }\n    }\n    return values;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/ValueMap.js\n **/","// ------------------------------------------------------------------------------------------------\n// setup\n\n    /**\n     * @prop {string}       namespace   The Event namespace; i.e. state or action\n     * @prop {string}       type        The Event type;      i.e. leave/enter (state) or start/end (action)\n     * @prop {string}       target      The Event target;    i.e. intro (state), next (action), or * (all states or types)\n     * @prop {Transition}   transition  The transition which generated the event\n     */\n    let event =\n    {\n        // properties\n        namespace   : null,\n        type        : null,\n        target      : null,\n        transition          : null\n    };\n\n    function initialize (event, namespace, type, target, transition)\n    {\n        event.namespace     = namespace;\n        event.type          = type;\n        event.target        = target;\n        event.transition    = transition;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// ActionEvent\n\n    export function ActionEvent (type, target, transition)\n    {\n        initialize(this, 'action' ,type, target, transition);\n    }\n    ActionEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// StateEvent\n\n    export function StateEvent (type, target, transition)\n    {\n        initialize(this, 'state' ,type, target, transition);\n    }\n    StateEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// SystemEvent\n\n    export function SystemEvent (type, value)\n    {\n        this.type   = type;\n        this.value  = value;\n    }\n\n    SystemEvent.prototype =\n    {\n        namespace   : 'system',\n        type        : '',\n        value       : null\n    };\n\n\n// ------------------------------------------------------------------------------------------------\n// TransitionEvent\n\n    export function TransitionEvent (type)\n    {\n        this.type = type;\n    }\n\n    TransitionEvent.prototype =\n    {\n        namespace   : 'transition',\n        type        : ''\n    };\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/objects/events.js\n **/","import HandlerMeta from './HandlerMeta';\nimport Lexer from '../lexer/Lexer'\nimport { trim } from '../utils/utils';\nimport { ParseError } from '../objects/errors';\n\n\n// ------------------------------------------------------------------------------------------------\n// functions\n\n    function isSystem(token)\n    {\n        return /^(start|change|complete|reset)$/.test(token);\n    }\n\n    function isTransition(token)\n    {\n        return /^(pause|resume|cancel)$/.test(token);\n    }\n\n    function expandGroups (input)\n    {\n        var rx \t\t= /\\((.+?)\\)/;\n        var matches = input.match(rx);\n        if(matches)\n        {\n            var group = matches[0];\n            var items = matches[1].match(/\\S+/g);\n            if(items)\n            {\n                items = items.map(item => input.replace(group, item));\n                if(rx.test(items[0]))\n                {\n                    return items.reduce( (output, input) => {\n                        return output.concat(expandGroups(input));\n                    }, []);\n                }\n                return items;\n            }\n        }\n        return [input];\n    }\n\n    function addPath (path, namespace, target)\n    {\n        results.push(new HandlerMeta(_id, path, namespace, target));\n        return true;\n    }\n\n    function addError (message, path)\n    {\n        var error = new ParseError(message, path, _id);\n        results.push(error);\n        return false;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// export\n\n    /**\n     * Parses event handler id into a HandlerMeta results containing handler paths\n     *\n     * @param   {string}    id          The handler id to parse, i.e. '@next', 'intro:end', 'change', etc\n     * @param   {Object}    defaults     A StateMachine instance to test for states and actions\n     * @return  {HandlerMeta[]}\n     */\n    export default function parse(id, defaults)\n    {\n        // pre-parse handler\n        id          = trim(id);\n\n        // objects\n        _id         = id;\n        _defaults   = defaults;\n        results     = [];\n\n        // parse\n        parser.parse(id, defaults);\n\n        // return\n        return results;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// objects\n\n    let results,\n        _defaults,\n        _id;\n\n    var patterns  =\n    {\n        // start pause intro\n        alias               : /^(\\w+)$/,\n\n        // system.start state.add\n        namespaced          : /^(system|transition|state|action)\\.(\\w+)$/,\n\n        // @next @quit\n        oneAction           : /^@(\\w+)$/,\n\n        // @next:start @next:end\n        oneActionEvent      : /^@(\\w+):(start|end)$/,\n\n        // :start :end\n        anyActionEvent      : /^:(start|end)$/,\n\n        // intro form\n        oneState            : /^#(\\w+)$/,\n\n        // intro:enter intro:leave\n        oneStateEvent       : /^#?(\\w+):(leave|enter)$/,\n\n        // :enter :leave\n        anyStateEvent       : /^:(enter|leave)$/,\n\n        // intro@next\n        oneStateAction      : /^#?(\\w+)@(\\w+)$/\n    };\n\n    let lexer   = new Lexer(patterns);\n\n    var parser =\n    {\n        /**\n         * Parses event handler id into HandlerMeta instance\n         *\n         * Resolving namespace, type and target properties\n         *\n         * @param   {string}        id\n         * @param   {Object}        defaults\n         */\n        parse (id, defaults)\n        {\n            // expand groups\n            let paths   = expandGroups(id);\n\n            // process paths\n            paths.map( path => this.parsePath(path) );\n        },\n\n        parsePath:function(path)\n        {\n            let tokens;\n            try\n            {\n                tokens = lexer.process(path)\n            }\n            catch(error)\n            {\n                return addError('Unrecognised pattern \"' +path+ '\"', path);\n            }\n\n            if(tokens && tokens.length)\n            {\n                // variables\n                let token   = tokens.shift();\n                var fn      = this[token.type];\n\n                // process\n                if(fn)\n                {\n                    return fn.apply(this, token.values);\n                }\n                return addError('Unknown token type \"' +token.type+ '\"', path);\n            }\n        },\n\n        alias (value)\n        {\n            if (isSystem(value))\n            {\n                return addPath('system.' + value, 'system');\n            }\n            if (isTransition(value))\n            {\n                return addPath('transition.' + value, 'transition');\n            }\n            return this.oneState(value);\n        },\n\n        namespaced (namespace, type)\n        {\n            var path = namespace + '.' + type;\n\n            if(namespace === 'system' && isSystem(type) || namespace === 'transition' && isTransition(type))\n            {\n                return addPath(path, namespace);\n            }\n\n            if(/^(state|action)$/.test(namespace) && /^(add|remove)$/.test(type))\n            {\n                return addPath('system.' + path, 'system');\n            }\n\n            addError('Unrecognised type \"' +type+'\" for namespace \"' +namespace+ '\"', _id)\n        },\n\n        oneState (state)\n        {\n            return addPath('state.' + state + '.' + _defaults.state, 'state', state);\n        },\n\n        oneAction (action)\n        {\n            return addPath('action.' +action+ '.' +_defaults.action, 'action', action);\n        },\n\n        anyActionEvent (event)\n        {\n            return addPath('action.*.' + event, 'action', '*');\n        },\n\n        oneActionEvent (action, event)\n        {\n            return addPath('action.' +action+ '.' + event, 'action', action);\n        },\n\n        anyStateEvent (event)\n        {\n            return addPath('state.*.' + event, 'state', '*');\n        },\n\n        oneStateEvent (state, event)\n        {\n            return addPath('state.' +state+ '.' + event, 'state', state);\n        },\n\n        oneStateAction (state, action)\n        {\n            return addPath('state.' +state+ '.' + action, 'state/action', state + '@' + action);\n        }\n\n    };\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/HandlerParser.js\n **/","function HandlerMeta (id, path, namespace = '', target = '')\n{\n    this.id         = id;\n    this.path       = path;\n    if(namespace)\n    {\n        this.namespace  = namespace;\n    }\n    if(target)\n    {\n        this.target     = target;\n    }\n}\n\nHandlerMeta.prototype =\n{\n    id          : '',\n    path        : '',\n    namespace   : '',\n    target      : ''\n};\n\nexport default HandlerMeta;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/HandlerMeta.js\n **/","import Rule from './Rule';\nimport Token from './Token';\n\n/**\n * Simple Lexer class\n *\n * @param   {Object}    rules   A hash of id:RegExp values\n * @constructor\n */\nexport default function Lexer(rules)\n{\n    this.rules = [];\n    if(rules)\n    {\n        Object.keys(rules).map( name => this.addRule(name, rules[name]) );\n    }\n}\n\nLexer.prototype =\n{\n    /** @var {String} */\n    source  : null,\n\n    /** @var {Rule[]} */\n    rules   : null,\n\n    /** @var {Token[]} */\n    tokens  : null,\n\n    /** @var {Number} */\n    index   : 0,\n\n    /**\n     * Process a source string into an array of Tokens based on Rules\n     *\n     * @param source\n     * @returns {Token[]}\n     */\n    process:function(source)\n    {\n        this.source = source;\n        this.tokens = [];\n        this.index  = 0;\n        this.next();\n        return this.tokens;\n    },\n\n    /**\n     * Adds a new rule\n     *\n     * @protected\n     * @param name\n     * @param rx\n     */\n    addRule:function(name, rx)\n    {\n        this.rules.push(new Rule(name, rx));\n    },\n\n    next:function()\n    {\n        if(this.index < this.source.length)\n        {\n            let source  = this.source.substr(this.index);\n            let state = this.rules.some(rule =>\n            {\n                var matches = source.match(rule.rx);\n                if(matches)\n                {\n                    this.tokens.push(new Token(rule.name, matches));\n                    this.index += matches[0].length;\n                    return true;\n                }\n                return false;\n            });\n\n            // not matched\n            if(!state)\n            {\n                throw new LexerError('Unable to match source at position ' + this.index + ': \"' +source+'\"', this.source, this.index);\n            }\n\n            // match\n            this.next();\n        }\n    }\n};\n\nfunction LexerError(message, source, index)\n{\n    this.message = message;\n    this.source = source;\n    this.index = index;\n}\n\nLexerError.prototype = new Error;\nLexerError.prototype.constructor = LexerError;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/lexer/Lexer.js\n **/","/**\n * A parsing rule, designed to match part of a string\n *\n * @param   {string}    name\n * @param   {RegExp}    rx\n */\nfunction Rule(name, rx)\n{\n    this.name = name;\n    this.rx = rx;\n}\n\nexport default Rule;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/lexer/Rule.js\n **/","/**\n * Token class, representing the type and value of part of a source string\n *\n * @param       {string}    type\n * @param       {string[]}  matches\n *\n * @property    {string}    type\n * @property    {string}    match\n * @property    {string[]}  values\n */\nfunction Token(type, matches)\n{\n    this.type       = type;\n    this.match      = matches[0];\n    this.values     = matches.slice(1);\n}\n\nexport default Token;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/lexer/Token.js\n **/","export function ParseError(message, path, id)\n{\n    this.message = message;\n    this.path = path;\n    this.id = id;\n}\n\nParseError.prototype = Error.prototype;\nParseError.prototype.name = 'ParseError';\nParseError.prototype.constructor = ParseError;\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/objects/errors.js\n **/","import ValueMap from './ValueMap';\nimport parseTransition from '../parsers/TransitionParser'\nimport { trim } from '../utils/utils'\n\nfunction TransitionMap ()\n{\n    this.map        = new ValueMap();\n    this.states     = [];\n    this.actions    = [];\n}\n\nTransitionMap.prototype =\n{\n    // ------------------------------------------------------------------------------------------------\n    // properties\n\n        map     : null,\n        states  : null,\n        actions : null,\n\n\n    // ------------------------------------------------------------------------------------------------\n    // add and remove states\n\n        /**\n         * Add event handler parsing\n         *\n         * @param   {string}    tx\n         * @returns {TransitionMeta[]}\n         */\n        parse: function (tx)\n        {\n            return parseTransition(tx);\n        },\n\n        /**\n         * Adds a new transition\n         * \n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @returns {TransitionMap}\n         */\n        add: function (action, from, to)\n        {\n            // procss variables\n            action  = trim(action);\n            from    = trim(from);\n            to      = typeof to === 'string' ? trim(to) : to;\n\n            // check for wildcards\n            if(to === '*')\n            {\n                throw new Error('Transitioning to a wildcard doesn\\'t make sense');\n            }\n\n            // add transition\n            this.map.set(from + '.' + action, to);\n            return update(this);\n        },\n\n        /**\n         * Removes an existing state\n         *\n         * @param   {string}    state\n         * @returns {TransitionMap}\n         */\n        remove: function (state)\n        {\n            // remove \"from\" state\n            this.map.remove(state);\n\n            // remove \"to\" states\n            let data = this.map.data;\n            for(let name in data)\n            {\n                let from = data[name];\n                for(let action in from)\n                {\n                    if(from[action] === state)\n                    {\n                        delete from[action];\n                    }\n                }\n            }\n\n            // update and return\n            return update(this);\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // accessors\n\n        /**\n         * Get all available actions (or action => states map) for a given state\n         *\n         * @param   {string}    from        Name of a state to get actions for\n         * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n         * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n         */\n        getActionsFrom: function (from, asMap = false)\n        {\n            if(this.has(from) || this.has('*'))\n            {\n                // get all available actions\n                let actions     = this.map.get(from) || {};\n                let wildcard    = this.map.get('*');\n                let output      = Object.assign({}, actions);\n\n                // append wildcard actions\n                if(wildcard)\n                {\n                    for(var action in wildcard)\n                    {\n                        let value = wildcard[action];\n                        if(value !== from && !actions[action])\n                        {\n                            output[action] = value;\n                        }\n                    }\n                }\n\n                // return map or keys\n                return output\n                    ? asMap\n                        ? output\n                        : Object.keys(output)\n                    : [];\n            }\n            return [];\n        },\n\n        /**\n         * Get the first available action to move from one state to another (if there is one)\n         *\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {string|null}\n         */\n        getActionFor: function (from, to)\n        {\n            let actions = this.map.get(from);\n            for(let action in actions)\n            {\n                if(actions[action] === to)\n                {\n                    return action;\n                }\n            }\n            return null;\n        },\n\n        /**\n         * Get all available \"to\" states for a given state\n         *\n         * Loops over all actions and returns a unique array of \"to\" states\n         *\n         * @param   {string|null}    [from]     Optional name of a from state to get states for. Defaults to the current state\n         * @returns {string[]}                  An array of string states\n         */\n        getStatesFrom: function (from)\n        {\n            if(this.hasState(from))\n            {\n                let actions = this.getActionsFrom(from, true);\n                return Object.keys(actions).map( name => actions[name] );\n            }\n            return null;\n        },\n\n        /**\n         * Get the target \"to\" state from a \"from\" state via an \"action\"\n         *\n         * @param   {string}    from\n         * @param   {string}    action\n         * @returns {string}\n         */\n        getStateFor: function (from, action)\n        {\n            let states = this.getActionsFrom(from, true) || {};\n            return states[action];\n        },\n\n        /**\n         * Get all states within the system\n         *\n         * @return  {string[]}\n         */\n        getStates: function ()\n        {\n            return [].concat(this.states);\n        },\n\n        /**\n         * Get all actions within the system\n         *\n         * @return  {string[]}\n         */\n        getActions: function ()\n        {\n            return [].concat(this.actions);\n        },\n\n        /**\n         * General getter\n         *\n         * @param   {string}    path\n         * @return  {*}\n         */\n        get: function(...path)\n        {\n            path = [...path].join('.');\n            return this.map.get(path);\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // checks\n\n        /**\n         * Test if the given state exists within the system\n         *\n         * @param   {string}    state\n         * @returns {boolean}\n         */\n        hasState: function (state)\n        {\n            return this.states.indexOf(state) !== -1;\n        },\n\n        /**\n         * Test if the given action exists within the system\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        hasAction: function (action)\n        {\n            return this.actions.indexOf(action) !== -1;\n        },\n\n        /**\n         * Test if the given transition exists within the system\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @returns {boolean}\n         */\n        hasTransition: function (action, from, to)\n        {\n            return this.map.get(from + '.' + action) === to;\n        },\n\n        /**\n         * Utility function to directly check if the composed ValueMap has the requested path\n         *\n         * Note this does NOT take into account the value of the target object; use hasTransition() for that\n         *\n         * @param   {string}    path    Pass a path using dot notation, i.e. 'a.next' or pass individual arguments, i.e. from, action, to\n         * @returns {boolean}\n         */\n        has: function (...path)\n        {\n            path = [...path].join('.');\n            return !! path\n                ? this.map.has(path)\n                : false;\n        }\n\n};\n\nTransitionMap.prototype.constructor = TransitionMap;\n\n/**\n * Private utility function to update existing states and actions\n *\n * @param   {TransitionMap} target\n * @returns {TransitionMap}\n */\nfunction update(target)\n{\n    // variables\n    var actions     = {};\n    var states      = {};\n    var data        = target.map.data;\n    var to;\n\n    // collate from states\n    for(let from in data)\n    {\n        states[from] = true;\n        for(let action in data[from])\n        {\n            actions[action] = true;\n            to = data[from][action];\n            if(typeof to !== 'function')\n            {\n                states[to] = true;\n            }\n        }\n    }\n\n    // update\n    target.states  = Object.keys(states).filter(state => state !== '*');\n    target.actions = Object.keys(actions);\n\n    // return\n    return target;\n}\n\nexport default TransitionMap;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/TransitionMap.js\n **/","import { isString } from '../utils/utils';\nimport { ParseError } from '../objects/errors';\nimport TransitionMeta from './TransitionMeta';\n\n// ------------------------------------------------------------------------------------------------\n// functions\n\n    function getError(tx, message)\n    {\n        return 'Invalid transition shorthand pattern \"' +tx+ '\" - ' + message;\n    }\n\n    function add(transitions, action, from, to)\n    {\n        transitions.push(new TransitionMeta(action, from, to));\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// export\n\n    /**\n     * Parses/expands transition objects/strings into discrete transitions\n     *\n     * @returns {TransitionMeta[]}  An array of TransitionMeta instances\n     */\n    export default function parse (tx)\n    {\n        if(isString(tx))\n        {\n            // pre-process string\n            tx = tx\n                .replace(/([|=:<>])/g, ' $1 ')\n                .replace(/\\s+/g, ' ')\n                .replace(/^\\s+|\\s+$/g,'');\n\n            // ensure string is valid\n            if(!/^\\w+ [:|=] [*\\w][\\w ]*[<>] [*\\w][\\w ]*/.test(tx))\n            {\n                throw new ParseError(getError(tx, 'cannot determine action and states'));\n            }\n\n            // initialize variables\n            let transitions = [],\n                matches = tx.match(/([*\\w ]+|[<>])/g),\n                action  = matches.shift().replace(/\\s+/g, ''),\n                stack   = [],\n                match   = '',\n                op      = '',\n                a       = '',\n                b       = '';\n\n            // process states\n            while(matches.length)\n            {\n                // get the next match\n                match = matches.shift();\n                if(/[<>]/.test(match))\n                {\n                    op = match;\n                }\n                else\n                {\n                    match = match.match(/[*\\w]+/g);\n                    match = match.length === 1 ? match[0] : match;\n                    stack.push(match);\n                }\n\n                // process matches if stack is full\n                if(stack.length === 2)\n                {\n                    [a, b] = op === '<'\n                        ? [stack[1], stack[0]]\n                        : stack;\n                    if(Array.isArray(a) && Array.isArray(b))\n                    {\n                        throw new ParseError(getError(tx, 'transitioning between 2 arrays doesn\\'t make sense'));\n                    }\n                    if(b === '*')\n                    {\n                        throw new ParseError(getError(tx, 'transitioning to a wildcard doesn\\'t make sense'));\n                    }\n                    if(Array.isArray(a))\n                    {\n                        a.map( a => add(transitions, action, a, b) );\n                    }\n                    else if(Array.isArray(b))\n                    {\n                        b.map( b => add(transitions, action, a, b) );\n                    }\n                    else\n                    {\n                        add(transitions, action, a, b);\n                    }\n\n                    // discard original match once processed\n                    stack.shift();\n                }\n\n            }\n\n            // return\n            return transitions;\n        }\n\n        // return objects wrapped in an array\n        return [tx];\n    }\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/TransitionParser.js\n **/","function TransitionMeta(action, from, to)\n{\n    this.action = action;\n    this.from = from;\n    this.to = to;\n}\n\nexport default TransitionMeta;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/TransitionMeta.js\n **/","import { StateEvent, ActionEvent } from '../objects/events';\nimport { isFunction } from '../utils/utils';\n\n/**\n * Transition class\n *\n * Responsible for managing events in the flow from state to state.\n *\n * This adds all handlers for the current action start/end and state from/to to an array:\n *\n * - <namespace>.<target>.<type>[]\n *\n * So going from state \"a\" to state \"b\" with action \"next\" should build:\n *\n * - action.*.start[]\n * - action.next.start[]\n * - state.a.leave[]\n * - state.*.leave[]\n * - state.*.enter[]\n * - state.b.enter[]\n * - action.next.end[]\n * - action.*.end[]\n *\n * This can be changed by passing in an order array in fsm.config\n *\n * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n *\n * From a callback, you can:\n *\n * - return false to cancel the transition\n * - return true to pause the transition\n * - not return a value (the transition continues)\n *\n * TransitionMap can also be paused, resumed, or cancelled by calling\n * the appropriate method on, or from:\n *\n * - the event\n * - the transition\n * - the state machine\n *\n * Cancelled transitions will reset the FSM to the previous \"from\" state\n *\n * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n *\n * @param {StateMachine}    fsm\n * @param {string}          action\n * @param {string}          from\n * @param {string}          to\n */\nfunction Transition (fsm, action, from, to)\n{\n    this.fsm        = fsm;\n    this.action     = action;\n    this.from       = from;\n    this.to         = to;\n    this.clear();\n}\n\n/**\n * @prop {StateMachine}    fsm\n * @prop {string}          action\n * @prop {string}          from\n * @prop {string}          to\n * @prop {Function[]}      handlers\n */\nTransition.prototype =\n{\n    fsm         : null,\n    action      : '',\n    from        : '',\n    to          : '',\n    paused      : false,\n    handlers    : null,\n\n    clear: function ()\n    {\n        unpause(this);\n        this.handlers = [];\n    },\n\n    /**\n     * Execute the next event's callbacks\n     * @returns {*}\n     */\n\texec: function ()\n\t{\n\t    if( ! this.paused )\n        {\n            if(this.handlers.length)\n            {\n                var handler = this.handlers.shift();\n                var state = handler();\n                if(state === false)\n                {\n                    return this.fsm.cancel();\n                }\n                if(state === true)\n                {\n                    return this.fsm.pause();\n                }\n                this.exec();\n            }\n            else\n            {\n                this.fsm.end();\n            }\n        }\n        return this;\n\t},\n\n    pause: function ()\n    {\n        pause(this);\n        return this;\n    },\n\n    resume: function ()\n    {\n        unpause(this);\n        return this.exec();\n    },\n\n    cancel: function()\n    {\n        this.paused = false;;\n        this.fsm.handlers.trigger('transition.cancel', false);\n    }\n\n};\n\nfunction pause(transition)\n{\n    if(!transition.paused)\n    {\n        transition.paused = true;\n        transition.fsm.handlers.trigger('transition.pause', true);\n    }\n}\n\nfunction unpause(transition)\n{\n    if(transition.paused)\n    {\n        transition.paused = false;\n        transition.fsm.handlers.trigger('transition.resume', false);\n    }\n}\n\nexport default\n{\n    /**\n     * Create the Transition object\n     *\n     * - Set up variables, and queue\n     * - Determine paths to relevant handlers\n     * - Build State and Action Event objects\n     * - Pre-bind all handlers\n     * - Append to queue\n     *\n     * @param {StateMachine}    fsm\n     * @param {string}          action\n     * @param {Array}           params\n     * @returns {Transition}\n     */\n    create:function (fsm, action, params)\n    {\n        // transition properties\n        let scope   = fsm.config.scope;\n        let from    = fsm.state;\n        let to      = fsm.transitions.getStateFor(from, action);\n        let vars    = {action, to, from};\n\n        // handle \"to\" being a function\n        if(isFunction(to))\n        {\n            to = to.apply(scope, params);\n            if(!fsm.transitions.hasState(to))\n            {\n                throw new Error('Invalid \"to\" state \"' +to+ '\"');\n            }\n        }\n\n        // transition\n        let queue       = [];\n        let transition  = new Transition(fsm, action, from, to);\n\n        // build handlers array\n        fsm.config.order.map( path =>\n        {\n            // replace path tokens\n            path = path.replace(/{(\\w+)}/g, (all, token) => vars[token]);\n            let handlers = fsm.handlers.get(path);\n\n            // do it!\n            if(handlers)\n            {\n                let [namespace, target, type] = path.split('.');\n                handlers = handlers.map( handler =>\n                {\n                    // build event object\n                    let Event = namespace === 'state' ? StateEvent : ActionEvent;\n                    let event = new Event(type, target, transition);\n\n                    // pre-bind handlers, scopes and params\n                    // this way scope and params don't need to be passed around\n                    // and the call from Transition is always just `value = handler()`\n                    return function()\n                    {\n                        return handler.apply(scope, [event, fsm].concat(params));\n                    }\n                });\n\n                // add to queue\n                queue = queue.concat(handlers);\n            }\n        });\n\n        // return\n        transition.handlers = queue;\n        return transition;\n    },\n\n    force: function(fsm, state)\n    {\n        let transition = new Transition(fsm, '', fsm.state, state);\n        transition.paused = fsm.transition ? fsm.transition.paused : false;\n        return transition;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/classes/Transition.js\n **/"],"sourceRoot":""}