{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///webpack/bootstrap 79fae98e180af7793ff9?09db","webpack:///./src/StateMachine.js","webpack:///./src/core/utils/utils.js?57f9","webpack:///./src/core/classes/Config.js","webpack:///./src/core/maps/HandlerMap.js","webpack:///./src/core/maps/ValueMap.js","webpack:///./src/core/objects/events.js","webpack:///./src/core/parsers/HandlerParser.js","webpack:///./src/core/parsers/HandlerMeta.js","webpack:///./src/core/lexer/Lexer.js","webpack:///./src/core/lexer/Rule.js","webpack:///./src/core/lexer/Token.js","webpack:///./src/core/objects/errors.js","webpack:///./src/core/maps/TransitionMap.js","webpack:///./src/core/parsers/TransitionParser.js","webpack:///./src/core/parsers/TransitionMeta.js","webpack:///./src/core/classes/Transition.js"],"names":["StateMachine","options","transitions","handlers","initialize","prototype","config","transition","state","Array","isArray","map","concat","parse","tx","add","action","from","to","initial","getStates","name","hasOwnProperty","on","methods","scope","start","trigger","reset","cancel","do","canDo","isPaused","rest","create","exec","go","force","has","clear","end","getActionFor","errors","console","warn","getActionsFrom","indexOf","canGo","hasState","is","isStarted","isTransitioning","paused","isComplete","final","pause","resume","arguments","length","updateTransitions","remove","id","fn","invalid","forEach","meta","path","off","filter","result","Error","message","target","error","namespace","hasAction","split","apply","constructor","getDefaultOrder","fsm","method","callback","statesBefore","actionsBefore","getActions","statesAfter","actionsAfter","states","actions","isObject","isString","isFunction","isDefined","isUndefined","trim","diff","toHash","value","Object","toString","call","Function","String","replace","a","b","da","v","db","values","reduce","obj","Config","match","order","defaults","assign","HandlerMap","insert","get","type","event","test","ValueMap","data","set","undefined","keys","key","shift","index","pop","push","parent","arr","join","splice","ActionEvent","StateEvent","SystemEvent","TransitionEvent","isSystem","token","isTransition","expandGroups","input","rx","matches","group","items","item","output","addPath","results","_id","addError","_defaults","parser","patterns","alias","namespaced","oneAction","oneActionEvent","anyActionEvent","oneState","oneStateEvent","anyStateEvent","oneStateAction","lexer","paths","parsePath","tokens","process","HandlerMeta","Lexer","rules","addRule","source","next","substr","some","rule","LexerError","Rule","Token","slice","ParseError","TransitionMap","update","asMap","wildcard","getStatesFrom","getStateFor","hasTransition","getError","stack","op","TransitionMeta","Transition","unpause","handler","params","vars","queue","all","Event"],"mappings":"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","file":"StateMachine.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 79fae98e180af7793ff9\n **/","import Config from './core/classes/Config';\nimport HandlerMap from './core/maps/HandlerMap';\nimport TransitionMap from './core/maps/TransitionMap';\nimport Transition from './core/classes/Transition';\nimport { diff } from './core/utils/utils';\n\n\n/**\n * StateMachine constructor\n *\n * @param   {Object|null}    options\n * @constructor\n */\nfunction StateMachine (options)\n{\n    this.transitions    = new TransitionMap();\n    this.handlers       = new HandlerMap(this);\n    this.initialize(options);\n}\n\n/**\n * StateMachine prototype\n *\n * The property examples below illustrate a 4-state machine, with states:\n *\n * - intro > settings > summary > end\n *\n * And actions:\n *\n * - back | next | restart | finish\n */\nStateMachine.prototype =\n{\n    // -----------------------------------------------------------------------------------------------------------------\n    // properties\n\n        /**\n         * Configuration object\n         *\n         * @var {Config}\n         */\n        config      : null,\n\n        /**\n         * Map of all transitions\n         *\n         * @var {TransitionMap}\n         */\n        transitions : null,\n\n        /**\n         * Map of all handlers\n         *\n         * @var {HandlerMap}\n         */\n        handlers    : null,\n\n        /**\n         * Any active Transition object that is driving the state change\n         *\n         * @var {Transition}\n         */\n        transition  : null,\n\n        /**\n         * The current state\n         *\n         * @var {string}\n         */\n        state       : '',\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // private methods\n\n        /**\n         * Initialize the FSM with a config object\n         *\n         * @private\n         * @param options\n         */\n        initialize:function (options)\n        {\n            // state\n            this.state          = '';\n\n            // build config\n            let config  = new Config(options);\n            this.config = config;\n\n            // pre-process all transitions\n            let transitions = [];\n            if(Array.isArray(options.transitions))\n            {\n                options.transitions.map( tx =>\n                {\n                    transitions = transitions.concat(this.transitions.parse(tx));\n                });\n            }\n\n            // add transitions\n            transitions.map( transition =>\n            {\n                this.transitions.add(transition.action, transition.from, transition.to);\n            });\n\n            // get initial state (must be done after state collation)\n            if( ! config.initial )\n            {\n                config.initial = this.transitions.getStates()[0];\n            }\n\n            // add handlers\n            if(options.handlers)\n            {\n                for(let name in options.handlers)\n                {\n                    if(options.handlers.hasOwnProperty(name))\n                    {\n                        this.on(name, options.handlers[name]);\n                    }\n                }\n            }\n\n            // add methods\n            if(options.methods)\n            {\n                if(!this.config.scope)\n                {\n                    this.config.scope = this;\n                }\n                for(var name in options.methods)\n                {\n                    if(options.methods.hasOwnProperty(name) && !this.hasOwnProperty(name))\n                    {\n                        this[name] = options.methods[name];\n                    }\n                }\n            }\n\n            // start\n            if(this.config.start)\n            {\n                this.start();\n            }\n\n            // return\n            return this;\n        },\n\n        start: function ()\n        {\n            this.state = this.config.initial;\n            this.handlers.trigger('system.start');\n            this.handlers.trigger('system.change', this.state);\n            return this;\n        },\n\n        /**\n         * Reset the FSM to the initial, or supplied, state\n         *\n         * @returns {StateMachine}\n         */\n        reset:function(initial = '')\n        {\n            let state = initial || this.config.initial;\n            this.handlers.trigger('system.reset');\n            if(this.transition)\n            {\n                this.transition.cancel();\n                delete this.transition;\n            }\n            if(this.state !== state)\n            {\n                this.state = state;\n                this.handlers.trigger('system.change', this.state);\n            }\n            return this;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // api\n\n        /**\n         * Attempt to run an action, resulting in a transition to a state\n         *\n         * @param   {string}    action\n         * @param   {*[]}       rest\n         * @returns {boolean}\n         */\n        do: function (action, ...rest)\n        {\n            if(this.canDo(action) && !this.isPaused())\n            {\n                this.transition = Transition.create(this, action, rest);\n                this.transition.exec();\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Attempt to go to a state\n         *\n         * Queries TransitionMap instance to see if a transition exists, then calls the related action if it does\n         *\n         * @param   {string}    state\n         * @param   {boolean}   [force]\n         * @returns {boolean}\n         */\n        go: function (state, force = false)\n        {\n            if(this.has(state))\n            {\n                if(force)\n                {\n                    if(this.transition)\n                    {\n                        this.transition.clear();\n                    }\n                    this.transition = Transition.force(this, state);\n                    return this.end();\n                }\n                var action = this.transitions.getActionFor(this.state, state);\n                if(action)\n                {\n                    return this.do(action);\n                }\n                this.config.errors > 0 && console.warn('No transition exists from \"%s\" to \"%s\"', this.state, state);\n                return false;\n            }\n            this.config.errors > 0 && console.warn('No such state \"%s\"', state);\n            return false;\n        },\n\n        /**\n         * Query transition map to see if a named action is available\n         *\n         * @param   {string}        action\n         * @returns {boolean}\n         */\n        canDo: function (action)\n        {\n            return this.transitions.getActionsFrom(this.state).indexOf(action) !== -1;\n        },\n\n        /**\n         * Query transition map to see if a state is available to go to\n         *\n         * @param to\n         * @return {boolean}\n         */\n        canGo: function (to)\n        {\n            return this.transitions.getActionFor(this.state, to) !== null;\n        },\n\n        /**\n         * Test if a state exists\n         *\n         * @param   {string}    state\n         * @return  {boolean}\n         */\n        has: function(state)\n        {\n            return this.transitions.hasState(state);\n        },\n\n        /**\n         * Test if the current state is the same as the supplied one\n         *\n         * @param   {string}    state       A state name to compare against the current state\n         * @returns {boolean}\n         */\n        is: function (state)\n        {\n            return state === this.state;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // flags\n\n        /**\n         * Test if the FSM has started\n         *\n         * @returns {boolean}\n         */\n        isStarted: function ()\n        {\n            return this.state !== '';\n        },\n\n        /**\n         * Test if the FSM is transitioning\n         *\n         * @returns {boolean}\n         */\n        isTransitioning: function ()\n        {\n            return !! this.transition;\n        },\n\n        /**\n         * Test if the FSM is paused (whilst transitioning)\n         *\n         * @returns {boolean}\n         */\n        isPaused: function ()\n        {\n            return this.transition\n                ? this.transition.paused\n                : false;\n        },\n\n        /**\n         * Test if the FSM is on the \"final\" state\n         *\n         * @returns {boolean}\n         */\n        isComplete: function ()\n        {\n            return this.state === this.config.final;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // transitions\n\n        /**\n         * Pause any current transition\n         *\n         * @returns {StateMachine}\n         */\n        pause: function ()\n        {\n            if(this.transition && !this.isPaused())\n            {\n                this.transition.pause();\n            }\n            return this;\n        },\n\n        /**\n         * Resume any current transition\n         *\n         * @returns {StateMachine}\n         */\n        resume: function ()\n        {\n            if(this.transition && this.isPaused())\n            {\n                this.transition.resume();\n            }\n            return this;\n        },\n\n        /**\n         * Cancel any current transition\n         *\n         * @returns {StateMachine}\n         */\n        cancel: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.from;\n                this.transition.cancel();\n                delete this.transition;\n            }\n            return this;\n        },\n\n        /**\n         * End any current transition, skipping remaining handlers\n         *\n         * @returns {StateMachine}\n         */\n        end: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.to;\n                this.transition.clear();\n                delete this.transition;\n                this.handlers.trigger('system.change', this.state);\n                if(this.isComplete())\n                {\n                    this.handlers.trigger('system.complete');\n                }\n            }\n            return this;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // actions\n\n        /**\n         * Add a transition\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        add: function (action, from, to)\n        {\n            // 1 argument: shorthand transition, i.e 'next : a > b'\n            if(arguments.length === 1)\n            {\n                var transitions = this.transitions.parse(action);\n                transitions.map( tx => this.add(tx.action, tx.from, tx.to));\n                return this;\n            }\n\n            // 3 arguments: longhand transition\n            updateTransitions(this, 'add', () => this.transitions.add(action, from, to) );\n            return this;\n        },\n\n        /**\n         * Remove a state\n         *\n         * @param   {string}    state\n         * @return  {StateMachine}\n         */\n        remove: function (state)\n        {\n            this.handlers.remove('state.' + state);\n            updateTransitions(this, 'remove', () => this.transitions.remove(state) );\n            return this;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // handlers\n\n        /**\n         * Add an event handler\n         *\n         * Event handler signatures are built from the following grammar:\n         *\n         * - token      foo\n         * - property   .foo\n         * - event      :foo\n         * - action     @foo\n         * - targets    (foo bar baz)\n         *\n         * For example:\n         *\n         * - change\n         * - transition.pause\n         * - next:end\n         * - (a b)@next\n         * - a@next\n         *\n         * The main event types are unique, so can be used without the namespace:\n         *\n         * - change\n         * - pause\n         * - complete\n         * - ...\n         *\n         * If your states and events are unique, they can also be used without qualification.\n         *\n         * See docs and demo for more information\n         *\n         * @param   {string}        id\n         * @param   {Function}      fn\n         * @return  {StateMachine}\n         */\n        on: function (id, fn)\n        {\n            this.parse(id, this.config.invalid, this.config.errors)\n                .forEach( meta => this.handlers.add(meta.path, fn) );\n            return this;\n        },\n\n        off: function (id, fn)\n        {\n            this.parse(id, this.config.invalid, this.config.errors)\n                .forEach( meta => this.handlers.remove(meta.path, fn) );\n            return this;\n        },\n\n    \n    // -----------------------------------------------------------------------------------------------------------------\n    // utilities\n\n        /**\n         * Parses a handler id string into HandlerMeta objects\n         *\n         * @param   {string}    id\n         * @param   {boolean}   invalid\n         * @param   {number}    errors\n         * @returns {HandlerMeta[]}\n         */\n        parse: function (id, invalid = false, errors = 0)\n        {\n            return this.handlers.parse(id).filter(result =>\n            {\n                // picks up unrecognised handlers, namespaces, etc\n                if(result instanceof Error)\n                {\n                    if(errors == 2)\n                    {\n                        throw result;\n                    }\n                    errors == 1 && console.warn(result.message);\n                    return false;\n                }\n\n                // picks up unrecognised states and actions\n                if(result.target !== '*')\n                {\n                    let error = '';\n\n                    if(result.namespace === 'state')\n                    {\n                        if(!this.transitions.hasState(result.target))\n                        {\n                            error = 'Unrecognised state \"' +result.target+ '\" in handler \"' +result.id+ '\"';\n                        }\n                    }\n                    else if(result.namespace === 'action')\n                    {\n                        if(!this.transitions.hasAction(result.target))\n                        {\n                            error = 'Unrecognised action \"' +result.target+ '\" in handler \"' +result.id+ '\"';\n                        }\n                    }\n                    else if(result.namespace === 'state/action')\n                    {\n                        // variables\n                        let [state, action] = result.target.split('@');\n\n                        // test for state and action\n                        if(!this.transitions.hasState(state))\n                        {\n                            error = 'Unrecognised state \"' +state+ '\" in handler \"' +result.id+ '\"';\n                        }\n                        if(!this.transitions.hasAction(action))\n                        {\n                            error = 'Unrecognised action \"' +action+ '\" in handler \"' +result.id+ '\"';\n                        }\n                    }\n\n                    // if we have an error, the result was not an existing state or action\n                    if(error)\n                    {\n                        if(errors == 2)\n                        {\n                            throw new Error(error);\n                        }\n                        errors == 1 && console.warn(error);\n                        return !!invalid;\n                    }\n                }\n\n                // must be valid\n                return true\n            });\n        },\n\n        trigger: function (id, ...rest)\n        {\n            this.handlers.parse(id).map( meta => this.handlers.trigger.apply(this.handlers, [meta.path, ...rest]) );\n            return this;\n        }\n\n};\n\nStateMachine.prototype.constructor = StateMachine;\n\nexport default StateMachine;\n\n\n// ---------------------------------------------------------------------------------------------------------------------\n// static methods\n\n    /**\n     * Factory method\n     *\n     * @param   options\n     * @returns {StateMachine}\n     */\n    StateMachine.create = function(options)\n    {\n        return new StateMachine(options);\n    };\n\n    /**\n     * Gets the default order events should be called in\n     * @returns {string[]}\n     */\n    StateMachine.getDefaultOrder = function ()\n    {\n        return [\n            'action.*.start',\n            'action.{action}.start',\n            'state.*.{action}',\n            'state.{from}.{action}',\n            'state.{from}.leave',\n            'state.*.leave',\n            'state.*.enter',\n            'state.{to}.enter',\n            'action.{action}.end',\n            'action.*.end'\n        ];\n    };\n\n\n// ---------------------------------------------------------------------------------------------------------------------\n// helper functions\n\n    /**\n     * Utility method to update transitions and dispatch events\n     *\n     * Saves duplicating the following code in both add() and remove() methods\n     *\n     * @param   {StateMachine}  fsm\n     * @param   {string}        method\n     * @param   {Function}      callback\n     */\n    function updateTransitions(fsm, method, callback)\n    {\n        var statesBefore    = fsm.transitions.getStates();\n        var actionsBefore   = fsm.transitions.getActions();\n        callback();\n        var statesAfter     = fsm.transitions.getStates();\n        var actionsAfter    = fsm.transitions.getActions();\n\n        // calculate differences\n        var states          = diff(statesBefore, statesAfter);\n        var actions         = diff(actionsBefore, actionsAfter);\n\n        // dispatch events\n        states.map ( state  => fsm.handlers.trigger('system.state.'  + method, state) );\n        actions.map( action => fsm.handlers.trigger('system.action.' + method, action) );\n    }\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/StateMachine.js\n **/","export function isObject (value)\n{\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport function isArray (value)\n{\n    return value instanceof Array;\n}\n\nexport function isString (value)\n{\n    return typeof value === 'string';\n}\n\nexport function isFunction(value)\n{\n    return value instanceof Function;\n}\n\nexport function isDefined (value)\n{\n    return typeof value !== 'undefined';\n}\n\nexport function isUndefined (value)\n{\n    return typeof value === 'undefined';\n}\n\nexport function trim (value)\n{\n    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n}\n\nexport function diff (a, b)\n{\n    var da = b.filter( v => a.indexOf(v) < 0 );\n    var db = a.filter( v => b.indexOf(v) < 0 );\n    return db.concat(da)\n}\n\nexport function toHash(values) {\n    return values.reduce(function (obj, value) {\n        obj[value] = true;\n        return obj;\n    }, {})\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/utils/utils.js\n **/","export default function Config (options)\n{\n    'scope start initial final invalid errors'\n        .match(/\\w+/g)\n        .map( name =>\n        {\n            if(options.hasOwnProperty(name))\n            {\n                this[name] = options[name];\n            }\n        });\n\n    // order\n    this.order      = options.order || StateMachine.getDefaultOrder();\n\n    // defaults\n    this.defaults   = Object.assign({\n\n        // allow user to specify alternate triggers for event and action ids\n        action      :'start',\n        state       :'enter'\n\n    }, options.defaults);\n}\n\nConfig.prototype =\n{\n    /**\n     * An optional scope to run handler functions in\n     *\n     * @var object\n     */\n    scope       : null,\n\n    /**\n     * A boolean to automatically start the state machine in the initial state\n     *\n     * @var boolean\n     */\n    start       : true,\n\n    /**\n     * A string to indicate which state to start on; defaults to ''\n     *\n     * @var string\n     */\n    initial     : '',\n\n    /**\n     * A string indicating the state to trigger a complete event; defaults to ''\n     *\n     * @var string\n     */\n    final       : '',\n\n    /**\n     * A boolean to allow non-existent states and actions to be added to the handlers object; defaults to false (disallow)\n     *\n     * @var boolean\n     */\n    invalid     : false,\n\n    /**\n     * A number indicating how to handle invalid or erroneous actions; defaults to 1 (warn)\n     *\n     *  - 0 : quiet\n     *  - 1 : console.warn()\n     *  - 2 : throw an error\n     *\n     * @var number\n     */\n    errors      : 1,\n\n    /**\n     * The order to run transition callbacks in\n     *\n     * @type {string[]} type.target\n     */\n    order       : null,\n\n    /**\n     * Sets defaults for various declarations\n     *\n     * Available options are:\n     *\n     * - action: (start|end)\n     * - state: (enter|leave)\n     *\n     * @type {Object}\n     */\n    defaults    : null,\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/classes/Config.js\n **/","import ValueMap from './ValueMap';\nimport { SystemEvent, TransitionEvent, StateEvent, ActionEvent } from '../objects/events';\nimport { isFunction } from '../utils/utils';\n\nimport parseHandler from '../parsers/HandlerParser';\n\nfunction HandlerMap (fsm)\n{\n    this.fsm    = fsm;\n    this.map    = new ValueMap();\n}\n\nHandlerMap.prototype =\n{\n\n\tfsm: null,\n\n\tmap: null,\n\n    /**\n     * Parse event handler grammar into a HandlerMeta structure\n     *\n     * @param   {string}        id      The handler id to parse, i.e. '@next', 'intro:end', 'change', etc\n     * @returns {HandlerMeta[]}\n     */\n    parse: function (id)\n    {\n        return parseHandler(id, this.fsm.config.defaults);\n    },\n\n    /**\n     * Directly add a new handler\n     *\n     * @param   {string}    path    A 'namespace.target.type' target path to add a handler to\n     * @param   {Function}  fn      A callback function\n     * @returns {HandlerMap}\n     */\n    add: function (path, fn)\n    {\n        // check handler is a function\n        if(!isFunction(fn))\n        {\n            throw new Error('Error assigning \"' +path+ '\" handler; callback is not a function', fn);\n        }\n\n        this.map.insert(path, fn);\n        return this;\n    },\n\n    /**\n     * Directly remove a handler target\n     *\n     * @param   {string}    path    A 'namespace.target.type' parent to a handler removed from\n     * @param   {Function}  fn      The instance of the callback function\n     * @returns {HandlerMap}\n     */\n    remove: function (path, fn)\n    {\n        this.map.remove(path, fn);\n        return this;\n    },\n\n    /**\n     * Get all handlers for a valid target path\n     *\n     * @param   {string}    path    A 'namespace.target.type' target path\n     * @returns {Function[]}        An array of callback functions\n     */\n    get:function(path)\n    {\n        return this.map.get(path);\n    },\n\n    /**\n     * Dispatch an event\n     *\n     * @param   {string}    path\n     * @param   {*}         value\n     * @returns {StateMachine}\n     */\n    trigger: function (path, value = null)\n    {\n        // create lookup path\n        let [namespace, type, method] = path.match(/\\w+/g);\n\n        // build event\n        let event;\n        if(/^system\\.(state|action)\\./.test(path))\n        {\n            event = type === 'state'\n                ? new StateEvent(method, value)\n                : new ActionEvent(method, value);\n        }\n        else\n        {\n            event = namespace === 'system'\n                ? new SystemEvent(type, value)\n                : new TransitionEvent(type);\n        }\n\n        // dispatch\n        let handlers = this.map.get(path);\n        if(handlers)\n        {\n            handlers.map(fn => fn(event, this.fsm) );\n        }\n    }\n\n};\n\nexport default HandlerMap;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/HandlerMap.js\n **/","import {isObject, isArray, isDefined, isUndefined} from '../utils/utils';\n\n/**\n * Utility class to create, modify and delete nested hashes and values\n *\n * @constructor\n */\nexport default function ValueMap (data)\n{\n    this.data = data || {};\n}\n\nValueMap.prototype =\n{\n    data: null,\n\n    set: function (path, value)\n    {\n        set(this.data, path, value);\n        return this;\n    },\n\n    add:function(path, value)\n    {\n        add(this.data, path, value);\n        return this;\n    },\n\n    insert:function(path, value)\n    {\n        insert(this.data, path, value);\n        return this;\n    },\n\n    get:function(path)\n    {\n        return get(this.data, path);\n    },\n\n    has: function (path, value = undefined)\n    {\n        return has(this.data, path, value)\n    },\n\n    indexOf: function (path, value)\n    {\n        return indexOf(this.data, path, value)\n    },\n\n    remove: function (path, value = undefined)\n    {\n        remove(this.data, path, value);\n        return this;\n    },\n\n    keys:function(path)\n    {\n        return Object.keys(get(this.data, path));\n    },\n\n    values:function(path)\n    {\n        return values(this.data, path);\n    }\n\n};\n\nfunction create(obj, keys)\n{\n    let key;\n    while(keys.length)\n    {\n        key = keys.shift();\n        if( ! isObject(obj[key]) )\n        {\n            obj[key] = {};\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n\nexport function set(obj, path, value, index = -1)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    obj[key] = value;\n}\n\nfunction add(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    obj[key].push(value);\n}\n\nfunction insert(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    let parent = obj[key],\n        index = parent.indexOf(value);\n    if(index === -1)\n    {\n        parent.push(value);\n    }\n    else\n    {\n        parent[index] = value;\n    }\n}\n\nexport function get(obj, path)\n{\n    if(isUndefined(path) || path == '')\n    {\n        return obj;\n    }\n\n    let key,\n        keys = String(path).split('.');\n    while(keys.length > 1)\n    {\n        key = keys.shift();\n        if( ! obj.hasOwnProperty(key) )\n        {\n            return;\n        }\n        obj = obj[key];\n    }\n    key = keys.shift();\n    return obj[key];\n}\n\nexport function has(obj, path, value)\n{\n    let parent = get(obj, path);\n    return !! (isArray(parent) && isDefined(value)\n        ? parent.indexOf(value) !== -1\n        : isUndefined(value)\n            ? isDefined(parent)\n            : parent === value);\n}\n\nexport function indexOf (obj, path, value)\n{\n    let arr = get(obj, path);\n    if(isArray(arr))\n    {\n        return arr.indexOf(value);\n    }\n    return -1;\n}\n\nexport function remove(obj, path, value)\n{\n    let parent = obj,\n        keys = String(path || '').split('.'),\n        key = keys.pop();\n\n    if(keys.length)\n    {\n        parent = get(obj, keys.join('.'))\n    }\n    if(isDefined(value) && isArray(parent[key]))\n    {\n        let target = parent[key];\n        var index = target.indexOf(value);\n        if(index > -1)\n        {\n            target.splice(index, 1);\n            if(target.length === 0)\n            {\n                delete parent[key];\n            }\n            return true;\n        }\n        return false;\n    }\n    else\n    {\n        if(isObject(parent) && obj.hasOwnProperty(key))\n        {\n            delete parent[key];\n            return true;\n        }\n    }\n    return false\n}\n\nexport function values(obj, path)\n{\n    var values = [];\n    var target = get(obj, path);\n    if(isObject(target))\n    {\n        for(var name in target)\n        {\n            if(target.hasOwnProperty(name))\n            {\n                values.push(target[name]);\n            }\n        }\n    }\n    return values;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/ValueMap.js\n **/","// ------------------------------------------------------------------------------------------------\n// setup\n\n    /**\n     * @prop {string}       namespace   The Event namespace; i.e. state or action\n     * @prop {string}       type        The Event type;      i.e. leave/enter (state) or start/end (action)\n     * @prop {string}       target      The Event target;    i.e. intro (state), next (action), or * (all states or types)\n     * @prop {Transition}   transition  The transition which generated the event\n     */\n    let event =\n    {\n        // properties\n        namespace   : null,\n        type        : null,\n        target      : null,\n        transition          : null\n    };\n\n    function initialize (event, namespace, type, target, transition)\n    {\n        event.namespace     = namespace;\n        event.type          = type;\n        event.target        = target;\n        event.transition    = transition;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// ActionEvent\n\n    export function ActionEvent (type, target, transition)\n    {\n        initialize(this, 'action' ,type, target, transition);\n    }\n    ActionEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// StateEvent\n\n    export function StateEvent (type, target, transition)\n    {\n        initialize(this, 'state' ,type, target, transition);\n    }\n    StateEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// SystemEvent\n\n    export function SystemEvent (type, value)\n    {\n        this.type   = type;\n        this.value  = value;\n    }\n\n    SystemEvent.prototype =\n    {\n        namespace   : 'system',\n        type        : '',\n        value       : null\n    };\n\n\n// ------------------------------------------------------------------------------------------------\n// TransitionEvent\n\n    export function TransitionEvent (type)\n    {\n        this.type = type;\n    }\n\n    TransitionEvent.prototype =\n    {\n        namespace   : 'transition',\n        type        : ''\n    };\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/objects/events.js\n **/","import HandlerMeta from './HandlerMeta';\nimport Lexer from '../lexer/Lexer'\nimport { trim } from '../utils/utils';\nimport { ParseError } from '../objects/errors';\n\n\n// ------------------------------------------------------------------------------------------------\n// functions\n\n    function isSystem(token)\n    {\n        return /^(start|change|complete|reset)$/.test(token);\n    }\n\n    function isTransition(token)\n    {\n        return /^(pause|resume|cancel)$/.test(token);\n    }\n\n    function expandGroups (input)\n    {\n        var rx \t\t= /\\((.+?)\\)/;\n        var matches = input.match(rx);\n        if(matches)\n        {\n            var group = matches[0];\n            var items = matches[1].match(/\\S+/g);\n            if(items)\n            {\n                items = items.map(item => input.replace(group, item));\n                if(rx.test(items[0]))\n                {\n                    return items.reduce( (output, input) => {\n                        return output.concat(expandGroups(input));\n                    }, []);\n                }\n                return items;\n            }\n        }\n        return [input];\n    }\n\n    function addPath (path, namespace, target)\n    {\n        results.push(new HandlerMeta(_id, path, namespace, target));\n        return true;\n    }\n\n    function addError (message, path)\n    {\n        var error = new ParseError(message, path, _id);\n        results.push(error);\n        return false;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// export\n\n    /**\n     * Parses event handler id into a HandlerMeta results containing handler paths\n     *\n     * @param   {string}    id          The handler id to parse, i.e. '@next', 'intro:end', 'change', etc\n     * @param   {Object}    defaults     A StateMachine instance to test for states and actions\n     * @return  {HandlerMeta[]}\n     */\n    export default function parse(id, defaults)\n    {\n        // pre-parse handler\n        id          = trim(id);\n\n        // objects\n        _id         = id;\n        _defaults   = defaults;\n        results     = [];\n\n        // parse\n        parser.parse(id, defaults);\n\n        // return\n        return results;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// objects\n\n    let results,\n        _defaults,\n        _id;\n\n    var patterns  =\n    {\n        // start pause intro\n        alias               : /^(\\w+)$/,\n\n        // system.start state.add\n        namespaced          : /^(system|transition|state|action):(\\w+)$/,\n\n        // @next @quit\n        oneAction           : /^@(\\w+)$/,\n\n        // @next:start @next:end\n        oneActionEvent      : /^@(\\w+):(start|end)$/,\n\n        // :start :end\n        anyActionEvent      : /^:(start|end)$/,\n\n        // intro form\n        oneState            : /^#(\\w+)$/,\n\n        // intro:enter intro:leave\n        oneStateEvent       : /^#?(\\w+):(leave|enter)$/,\n\n        // :enter :leave\n        anyStateEvent       : /^:(enter|leave)$/,\n\n        // intro@next\n        oneStateAction      : /^#?(\\w+)@(\\w+)$/\n    };\n\n    let lexer   = new Lexer(patterns);\n\n    var parser =\n    {\n        /**\n         * Parses event handler id into HandlerMeta instance\n         *\n         * Resolving namespace, type and target properties\n         *\n         * @param   {string}        id\n         * @param   {Object}        defaults\n         */\n        parse (id, defaults)\n        {\n            // expand groups\n            let paths   = expandGroups(id);\n\n            // process paths\n            paths.map( path => this.parsePath(path) );\n        },\n\n        parsePath:function(path)\n        {\n            let tokens;\n            try\n            {\n                tokens = lexer.process(path)\n            }\n            catch(error)\n            {\n                return addError('Unrecognised pattern \"' +path+ '\"', path);\n            }\n\n            if(tokens && tokens.length)\n            {\n                // variables\n                let token   = tokens.shift();\n                var fn      = this[token.type];\n\n                // process\n                if(fn)\n                {\n                    return fn.apply(this, token.values);\n                }\n                return addError('Unknown token type \"' +token.type+ '\"', path);\n            }\n        },\n\n        alias (value)\n        {\n            if (isSystem(value))\n            {\n                return addPath('system.' + value, 'system');\n            }\n            if (isTransition(value))\n            {\n                return addPath('transition.' + value, 'transition');\n            }\n            return this.oneState(value);\n        },\n\n        namespaced (namespace, type)\n        {\n            var path = namespace + '.' + type;\n\n            if(namespace === 'system' && isSystem(type) || namespace === 'transition' && isTransition(type))\n            {\n                return addPath(path, namespace);\n            }\n\n            if(/^(state|action)$/.test(namespace) && /^(add|remove)$/.test(type))\n            {\n                return addPath('system.' + path, 'system');\n            }\n\n            addError('Unrecognised type \"' +type+'\" for namespace \"' +namespace+ '\"', _id)\n        },\n\n        oneState (state)\n        {\n            return addPath('state.' + state + '.' + _defaults.state, 'state', state);\n        },\n\n        oneAction (action)\n        {\n            return addPath('action.' +action+ '.' +_defaults.action, 'action', action);\n        },\n\n        anyActionEvent (event)\n        {\n            return addPath('action.*.' + event, 'action', '*');\n        },\n\n        oneActionEvent (action, event)\n        {\n            return addPath('action.' +action+ '.' + event, 'action', action);\n        },\n\n        anyStateEvent (event)\n        {\n            return addPath('state.*.' + event, 'state', '*');\n        },\n\n        oneStateEvent (state, event)\n        {\n            return addPath('state.' +state+ '.' + event, 'state', state);\n        },\n\n        oneStateAction (state, action)\n        {\n            return addPath('state.' +state+ '.' + action, 'state/action', state + '@' + action);\n        }\n\n    };\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/HandlerParser.js\n **/","function HandlerMeta (id, path, namespace = '', target = '')\n{\n    this.id         = id;\n    this.path       = path;\n    if(namespace)\n    {\n        this.namespace  = namespace;\n    }\n    if(target)\n    {\n        this.target     = target;\n    }\n}\n\nHandlerMeta.prototype =\n{\n    id          : '',\n    path        : '',\n    namespace   : '',\n    target      : ''\n};\n\nexport default HandlerMeta;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/HandlerMeta.js\n **/","import Rule from './Rule';\nimport Token from './Token';\n\n/**\n * Simple Lexer class\n *\n * @param   {Object}    rules   A hash of id:RegExp values\n * @constructor\n */\nexport default function Lexer(rules)\n{\n    this.rules = [];\n    if(rules)\n    {\n        Object.keys(rules).map( name => this.addRule(name, rules[name]) );\n    }\n}\n\nLexer.prototype =\n{\n    /** @var {String} */\n    source  : null,\n\n    /** @var {Rule[]} */\n    rules   : null,\n\n    /** @var {Token[]} */\n    tokens  : null,\n\n    /** @var {Number} */\n    index   : 0,\n\n    /**\n     * Process a source string into an array of Tokens based on Rules\n     *\n     * @param source\n     * @returns {Token[]}\n     */\n    process:function(source)\n    {\n        this.source = source;\n        this.tokens = [];\n        this.index  = 0;\n        this.next();\n        return this.tokens;\n    },\n\n    /**\n     * Adds a new rule\n     *\n     * @protected\n     * @param name\n     * @param rx\n     */\n    addRule:function(name, rx)\n    {\n        this.rules.push(new Rule(name, rx));\n    },\n\n    next:function()\n    {\n        if(this.index < this.source.length)\n        {\n            let source  = this.source.substr(this.index);\n            let state = this.rules.some(rule =>\n            {\n                var matches = source.match(rule.rx);\n                if(matches)\n                {\n                    this.tokens.push(new Token(rule.name, matches));\n                    this.index += matches[0].length;\n                    return true;\n                }\n                return false;\n            });\n\n            // not matched\n            if(!state)\n            {\n                throw new LexerError('Unable to match source at position ' + this.index + ': \"' +source+'\"', this.source, this.index);\n            }\n\n            // match\n            this.next();\n        }\n    }\n};\n\nfunction LexerError(message, source, index)\n{\n    this.message = message;\n    this.source = source;\n    this.index = index;\n}\n\nLexerError.prototype = new Error;\nLexerError.prototype.constructor = LexerError;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/lexer/Lexer.js\n **/","/**\n * A parsing rule, designed to match part of a string\n *\n * @param   {string}    name\n * @param   {RegExp}    rx\n */\nfunction Rule(name, rx)\n{\n    this.name = name;\n    this.rx = rx;\n}\n\nexport default Rule;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/lexer/Rule.js\n **/","/**\n * Token class, representing the type and value of part of a source string\n *\n * @param       {string}    type\n * @param       {string[]}  matches\n *\n * @property    {string}    type\n * @property    {string}    match\n * @property    {string[]}  values\n */\nfunction Token(type, matches)\n{\n    this.type       = type;\n    this.match      = matches[0];\n    this.values     = matches.slice(1);\n}\n\nexport default Token;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/lexer/Token.js\n **/","export function ParseError(message, path, id)\n{\n    this.message = message;\n    this.path = path;\n    this.id = id;\n}\n\nParseError.prototype = Error.prototype;\nParseError.prototype.name = 'ParseError';\nParseError.prototype.constructor = ParseError;\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/objects/errors.js\n **/","import ValueMap from './ValueMap';\nimport parseTransition from '../parsers/TransitionParser'\nimport { trim } from '../utils/utils'\n\nfunction TransitionMap ()\n{\n    this.map        = new ValueMap();\n    this.states     = [];\n    this.actions    = [];\n}\n\nTransitionMap.prototype =\n{\n    // ------------------------------------------------------------------------------------------------\n    // properties\n\n        map     : null,\n        states  : null,\n        actions : null,\n\n\n    // ------------------------------------------------------------------------------------------------\n    // add and remove states\n\n        /**\n         * Add event handler parsing\n         *\n         * @param   {string}    tx\n         * @returns {TransitionMeta[]}\n         */\n        parse: function (tx)\n        {\n            return parseTransition(tx);\n        },\n\n        /**\n         * Adds a new transition\n         * \n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @returns {TransitionMap}\n         */\n        add: function (action, from, to)\n        {\n            // procss variables\n            action  = trim(action);\n            from    = trim(from);\n            to      = typeof to === 'string' ? trim(to) : to;\n\n            // check for wildcards\n            if(to === '*')\n            {\n                throw new Error('Transitioning to a wildcard doesn\\'t make sense');\n            }\n\n            // add transition\n            this.map.set(from + '.' + action, to);\n            return update(this);\n        },\n\n        /**\n         * Removes an existing state\n         *\n         * @param   {string}    state\n         * @returns {TransitionMap}\n         */\n        remove: function (state)\n        {\n            // remove \"from\" state\n            this.map.remove(state);\n\n            // remove \"to\" states\n            let data = this.map.data;\n            for(let name in data)\n            {\n                let from = data[name];\n                for(let action in from)\n                {\n                    if(from[action] === state)\n                    {\n                        delete from[action];\n                    }\n                }\n            }\n\n            // update and return\n            return update(this);\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // accessors\n\n        /**\n         * Get all available actions (or action => states map) for a given state\n         *\n         * @param   {string}    from        Name of a state to get actions for\n         * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n         * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n         */\n        getActionsFrom: function (from, asMap = false)\n        {\n            if(this.has(from) || this.has('*'))\n            {\n                // get all available actions\n                let actions     = this.map.get(from) || {};\n                let wildcard    = this.map.get('*');\n                let output      = Object.assign({}, actions);\n\n                // append wildcard actions\n                if(wildcard)\n                {\n                    for(var action in wildcard)\n                    {\n                        let value = wildcard[action];\n                        if(value !== from && !actions[action])\n                        {\n                            output[action] = value;\n                        }\n                    }\n                }\n\n                // return map or keys\n                return output\n                    ? asMap\n                        ? output\n                        : Object.keys(output)\n                    : [];\n            }\n            return [];\n        },\n\n        /**\n         * Get the first available action to move from one state to another (if there is one)\n         *\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {string|null}\n         */\n        getActionFor: function (from, to)\n        {\n            let actions = this.map.get(from);\n            for(let action in actions)\n            {\n                if(actions[action] === to)\n                {\n                    return action;\n                }\n            }\n            return null;\n        },\n\n        /**\n         * Get all available \"to\" states for a given state\n         *\n         * Loops over all actions and returns a unique array of \"to\" states\n         *\n         * @param   {string|null}    [from]     Optional name of a from state to get states for. Defaults to the current state\n         * @returns {string[]}                  An array of string states\n         */\n        getStatesFrom: function (from)\n        {\n            if(this.hasState(from))\n            {\n                let actions = this.getActionsFrom(from, true);\n                return Object.keys(actions).map( name => actions[name] );\n            }\n            return null;\n        },\n\n        /**\n         * Get the target \"to\" state from a \"from\" state via an \"action\"\n         *\n         * @param   {string}    from\n         * @param   {string}    action\n         * @returns {string}\n         */\n        getStateFor: function (from, action)\n        {\n            let states = this.getActionsFrom(from, true) || {};\n            return states[action];\n        },\n\n        /**\n         * Get all states within the system\n         *\n         * @return  {string[]}\n         */\n        getStates: function ()\n        {\n            return [].concat(this.states);\n        },\n\n        /**\n         * Get all actions within the system\n         *\n         * @return  {string[]}\n         */\n        getActions: function ()\n        {\n            return [].concat(this.actions);\n        },\n\n        /**\n         * General getter\n         *\n         * @param   {string}    path\n         * @return  {*}\n         */\n        get:function(...path)\n        {\n            path = [...path].join('.');\n            return this.map.get(path);\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // checks\n\n        /**\n         * Test if the given state exists within the system\n         *\n         * @param   {string}    state\n         * @returns {boolean}\n         */\n        hasState: function (state)\n        {\n            return this.states.indexOf(state) !== -1;\n        },\n\n        /**\n         * Test if the given action exists within the system\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        hasAction: function (action)\n        {\n            return this.actions.indexOf(action) !== -1;\n        },\n\n        /**\n         * Test if the given transition exists within the system\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @returns {boolean}\n         */\n        hasTransition: function (action, from, to)\n        {\n            return this.map.get(from + '.' + action) === to;\n        },\n\n        /**\n         * Utility function to directly check if the composed ValueMap has the requested path\n         *\n         * Note this does NOT take into account the value of the target object; use hasTransition() for that\n         *\n         * @param   {string}    path    Pass a path using dot notation, i.e. 'a.next' or pass individual arguments, i.e. from, action, to\n         * @returns {boolean}\n         */\n        has: function (...path)\n        {\n            path = [...path].join('.');\n            return !! path\n                ? this.map.has(path)\n                : false;\n        }\n\n};\n\nTransitionMap.prototype.constructor = TransitionMap;\n\n/**\n * Private utility function to update existing states and actions\n *\n * @param   {TransitionMap} target\n * @returns {TransitionMap}\n */\nfunction update(target)\n{\n    // variables\n    var actions     = {};\n    var states      = {};\n    var data        = target.map.data;\n    var to;\n\n    // collate from states\n    for(let from in data)\n    {\n        states[from] = true;\n        for(let action in data[from])\n        {\n            actions[action] = true;\n            to = data[from][action];\n            if(typeof to !== 'function')\n            {\n                states[to] = true;\n            }\n        }\n    }\n\n    // update\n    target.states  = Object.keys(states).filter(state => state !== '*');\n    target.actions = Object.keys(actions);\n\n    // return\n    return target;\n}\n\nexport default TransitionMap;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/TransitionMap.js\n **/","import { isString } from '../utils/utils';\nimport { ParseError } from '../objects/errors';\nimport TransitionMeta from './TransitionMeta';\n\n// ------------------------------------------------------------------------------------------------\n// functions\n\n    function getError(tx, message)\n    {\n        return 'Invalid transition shorthand pattern \"' +tx+ '\" - ' + message;\n    }\n\n    function add(transitions, action, from, to)\n    {\n        transitions.push(new TransitionMeta(action, from, to));\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// export\n\n    /**\n     * Parses/expands transition objects/strings into discrete transitions\n     *\n     * @returns {TransitionMeta[]}  An array of TransitionMeta instances\n     */\n    export default function parse (tx)\n    {\n        if(isString(tx))\n        {\n            // pre-process string\n            tx = tx\n                .replace(/([|=:<>])/g, ' $1 ')\n                .replace(/\\s+/g, ' ')\n                .replace(/^\\s+|\\s+$/g,'');\n\n            // ensure string is valid\n            if(!/^\\w+ [:|=] [*\\w][\\w ]*[<>] [*\\w][\\w ]*/.test(tx))\n            {\n                throw new ParseError(getError(tx, 'cannot determine action and states'));\n            }\n\n            // initialize variables\n            let transitions = [],\n                matches = tx.match(/([*\\w ]+|[<>])/g),\n                action  = matches.shift().replace(/\\s+/g, ''),\n                stack   = [],\n                match   = '',\n                op      = '',\n                a       = '',\n                b       = '';\n\n            // process states\n            while(matches.length)\n            {\n                // get the next match\n                match = matches.shift();\n                if(/[<>]/.test(match))\n                {\n                    op = match;\n                }\n                else\n                {\n                    match = match.match(/[*\\w]+/g);\n                    match = match.length === 1 ? match[0] : match;\n                    stack.push(match);\n                }\n\n                // process matches if stack is full\n                if(stack.length === 2)\n                {\n                    [a, b] = op === '<'\n                        ? [stack[1], stack[0]]\n                        : stack;\n                    if(Array.isArray(a) && Array.isArray(b))\n                    {\n                        throw new ParseError(getError(tx, 'transitioning between 2 arrays doesn\\'t make sense'));\n                    }\n                    if(b === '*')\n                    {\n                        throw new ParseError(getError(tx, 'transitioning to a wildcard doesn\\'t make sense'));\n                    }\n                    if(Array.isArray(a))\n                    {\n                        a.map( a => add(transitions, action, a, b) );\n                    }\n                    else if(Array.isArray(b))\n                    {\n                        b.map( b => add(transitions, action, a, b) );\n                    }\n                    else\n                    {\n                        add(transitions, action, a, b);\n                    }\n\n                    // discard original match once processed\n                    stack.shift();\n                }\n\n            }\n\n            // return\n            return transitions;\n        }\n\n        // return objects wrapped in an array\n        return [tx];\n    }\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/TransitionParser.js\n **/","function TransitionMeta(action, from, to)\n{\n    this.action = action;\n    this.from = from;\n    this.to = to;\n}\n\nexport default TransitionMeta;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/TransitionMeta.js\n **/","import { StateEvent, ActionEvent } from '../objects/events';\nimport { isFunction } from '../utils/utils';\n\n/**\n * Transition class\n *\n * Responsible for managing events in the flow from state to state.\n *\n * This adds all handlers for the current action start/end and state from/to to an array:\n *\n * - <namespace>.<target>.<type>[]\n *\n * So going from state \"a\" to state \"b\" with action \"next\" should build:\n *\n * - action.*.start[]\n * - action.next.start[]\n * - state.a.leave[]\n * - state.*.leave[]\n * - state.*.enter[]\n * - state.b.enter[]\n * - action.next.end[]\n * - action.*.end[]\n *\n * This can be changed by passing in an order array in fsm.config\n *\n * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n *\n * From a callback, you can:\n *\n * - return false to cancel the transition\n * - return true to pause the transition\n * - not return a value (the transition continues)\n *\n * TransitionMap can also be paused, resumed, or cancelled by calling\n * the appropriate method on, or from:\n *\n * - the event\n * - the transition\n * - the state machine\n *\n * Cancelled transitions will reset the FSM to the previous \"from\" state\n *\n * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n *\n * @param {StateMachine}    fsm\n * @param {string}          action\n * @param {string}          from\n * @param {string}          to\n */\nfunction Transition (fsm, action, from, to)\n{\n    this.fsm        = fsm;\n    this.action     = action;\n    this.from       = from;\n    this.to         = to;\n    this.clear();\n}\n\n/**\n * @prop {StateMachine}    fsm\n * @prop {string}          action\n * @prop {string}          from\n * @prop {string}          to\n * @prop {Function[]}      handlers\n */\nTransition.prototype =\n{\n    fsm         : null,\n    action      : '',\n    from        : '',\n    to          : '',\n    paused      : false,\n    handlers    : null,\n\n    clear: function ()\n    {\n        unpause(this);\n        this.handlers = [];\n    },\n\n    /**\n     * Execute the next event's callbacks\n     * @returns {*}\n     */\n\texec: function ()\n\t{\n\t    if( ! this.paused )\n        {\n            if(this.handlers.length)\n            {\n                var handler = this.handlers.shift();\n                var state = handler();\n                if(state === false)\n                {\n                    return this.fsm.cancel();\n                }\n                if(state === true)\n                {\n                    return this.fsm.pause();\n                }\n                this.exec();\n            }\n            else\n            {\n                this.fsm.end();\n            }\n        }\n        return this;\n\t},\n\n    pause: function ()\n    {\n        pause(this);\n        return this;\n    },\n\n    resume: function ()\n    {\n        unpause(this);\n        return this.exec();\n    },\n\n    cancel: function()\n    {\n        this.paused = false;;\n        this.fsm.handlers.trigger('transition.cancel', false);\n    }\n\n};\n\nfunction pause(transition)\n{\n    if(!transition.paused)\n    {\n        transition.paused = true;\n        transition.fsm.handlers.trigger('transition.pause', true);\n    }\n}\n\nfunction unpause(transition)\n{\n    if(transition.paused)\n    {\n        transition.paused = false;\n        transition.fsm.handlers.trigger('transition.resume', false);\n    }\n}\n\nexport default\n{\n    /**\n     * Create the Transition object\n     *\n     * - Set up variables, and queue\n     * - Determine paths to relevant handlers\n     * - Build State and Action Event objects\n     * - Pre-bind all handlers\n     * - Append to queue\n     *\n     * @param {StateMachine}    fsm\n     * @param {string}          action\n     * @param {Array}           params\n     * @returns {Transition}\n     */\n    create:function (fsm, action, params)\n    {\n        // transition properties\n        let scope   = fsm.config.scope;\n        let from    = fsm.state;\n        let to      = fsm.transitions.getStateFor(from, action);\n        let vars    = {action, to, from};\n\n        // handle \"to\" being a function\n        if(isFunction(to))\n        {\n            to = to.apply(scope, params);\n            if(!fsm.transitions.hasState(to))\n            {\n                throw new Error('Invalid \"to\" state \"' +to+ '\"');\n            }\n        }\n\n        // transition\n        let queue       = [];\n        let transition  = new Transition(fsm, action, from, to);\n\n        // build handlers array\n        fsm.config.order.map( path =>\n        {\n            // replace path tokens\n            path = path.replace(/{(\\w+)}/g, (all, token) => vars[token]);\n            let handlers = fsm.handlers.get(path);\n\n            // do it!\n            if(handlers)\n            {\n                let [namespace, target, type] = path.split('.');\n                handlers = handlers.map( handler =>\n                {\n                    // build event object\n                    let Event = namespace === 'state' ? StateEvent : ActionEvent;\n                    let event = new Event(type, target, transition);\n\n                    // pre-bind handlers, scopes and params\n                    // this way scope and params don't need to be passed around\n                    // and the call from Transition is always just `value = handler()`\n                    return function()\n                    {\n                        return handler.apply(scope, [event, fsm].concat(params));\n                    }\n                });\n\n                // add to queue\n                queue = queue.concat(handlers);\n            }\n        });\n\n        // return\n        transition.handlers = queue;\n        return transition;\n    },\n\n    force: function(fsm, state)\n    {\n        let transition = new Transition(fsm, '', fsm.state, state);\n        transition.paused = fsm.transition ? fsm.transition.paused : false;\n        return transition;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/classes/Transition.js\n **/"],"sourceRoot":""}