{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///webpack/bootstrap 893baffce10df85461b9?359b","webpack:///./src/StateMachine.js","webpack:///./src/core/utils/utils.js?57f9","webpack:///./src/core/maps/HandlerMap.js","webpack:///./src/core/maps/ValueMap.js","webpack:///./src/core/objects/events.js","webpack:///./src/core/parsers/HandlerParser.js","webpack:///./src/core/parsers/HandlerMeta.js","webpack:///./src/core/objects/errors.js","webpack:///./src/core/utils/Lexer.js","webpack:///./src/core/maps/TransitionMap.js","webpack:///./src/core/parsers/TransitionParser.js","webpack:///./src/core/parsers/TransitionMeta.js","webpack:///./src/core/classes/Transition.js","webpack:///./src/core/classes/Config.js"],"names":["StateMachine","options","transitions","handlers","initialize","prototype","config","transition","state","Array","isArray","map","concat","parse","tx","add","action","from","to","initial","getStates","name","hasOwnProperty","on","start","update","do","canDo","isPaused","rest","create","defaults","exec","go","force","has","unpause","end","getActionTo","debug","console","warn","canGo","hasState","is","isStarted","isTransitioning","paused","isComplete","final","pause","resume","cancel","clear","reset","arguments","length","parseTransition","states","remove","id","fn","result","log","namespace","type","paths","path","index","target","targets","hasAction","off","constructor","fsm","isObject","isString","isFunction","isDefined","isUndefined","trim","toHash","value","Object","toString","call","Function","String","replace","values","reduce","obj","HandlerMap","Error","insert","get","key","info","event","ValueMap","data","set","undefined","indexOf","keys","shift","split","pop","push","parent","arr","join","splice","ActionEvent","StateEvent","SystemEvent","TransitionEvent","isNamespace","token","test","isSystem","isTransition","isAction","isState","getNamespace","getEventNamespace","parser","lexer","property","word","tokens","process","parseToken","setType","match","setNamespace","setTarget","HandlerMeta","segments","parts","ParseError","message","Lexer","rules","addRule","source","next","rx","Rule","RegExp","substr","some","matches","rule","Token","TransitionMap","actions","getActionsFrom","asMap","getToStates","getActions","slice","apply","getError","stack","op","a","b","TransitionMeta","Transition","handler","params","scope","vars","queue","order","all","Event","Config","getDefaultOrder","assign"],"mappings":"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","file":"StateMachine.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 893baffce10df85461b9\n **/","import HandlerMap from './core/maps/HandlerMap';\nimport TransitionMap from './core/maps/TransitionMap';\nimport Transition from './core/classes/Transition';\n\nimport Config from './core/classes/Config';\n\n\n/**\n * StateMachine constructor\n *\n * @param   {Object|null}    options\n * @constructor\n */\nfunction StateMachine (options)\n{\n    this.transitions    = new TransitionMap();\n    this.handlers       = new HandlerMap(this);\n    this.initialize(options);\n}\n\n/**\n * StateMachine prototype\n *\n * The property examples below illustrate a 4-state machine, with states:\n *\n * - intro > settings > summary > end\n *\n * And actions:\n *\n * - back | next | restart | finish\n */\nStateMachine.prototype =\n{\n    // ------------------------------------------------------------------------------------------------\n    // properties\n\n        /**\n         * Configuration object\n         *\n         * @var {Config}\n         */\n        config      : null,\n\n        /**\n         * Map of all transitions\n         *\n         * @var {TransitionMap}\n         */\n        transitions : null,\n\n        /**\n         * Map of all handlers\n         *\n         * @var {HandlerMap}\n         */\n        handlers    : null,\n\n        /**\n         * Any active Transition object that is driving the state change\n         *\n         * @var {Transition}\n         */\n        transition  : null,\n\n        /**\n         * The current state\n         *\n         * @var {string}\n         */\n        state       : '',\n\n\n    // ------------------------------------------------------------------------------------------------\n    // private methods\n\n        /**\n         * Initialize the FSM with a config object\n         *\n         * @private\n         * @param options\n         */\n        initialize:function (options)\n        {\n            // state\n            this.state          = '';\n\n            // build config\n            let config  = new Config(options);\n            this.config = config;\n\n            // pre-process all transitions\n            let transitions = [];\n            if(Array.isArray(options.transitions))\n            {\n                options.transitions.map( tx =>\n                {\n                    transitions = transitions.concat(this.transitions.parse(tx));\n                });\n            }\n\n            // add transitions\n            transitions.map( transition =>\n            {\n                this.transitions.add(transition.action, transition.from, transition.to);\n            });\n\n            // get initial state (must be done after state collation)\n            if( ! config.initial )\n            {\n                config.initial = this.transitions.getStates()[0];\n            }\n\n            // add handlers\n            if(options.handlers)\n            {\n                for(let name in options.handlers)\n                {\n                    if(options.handlers.hasOwnProperty(name))\n                    {\n                        this.on(name, options.handlers[name]);\n                    }\n                }\n            }\n\n            // start\n            if(this.config.start)\n            {\n                this.start();\n            }\n\n            // return\n            return this;\n        },\n\n        start: function ()\n        {\n            this.state = this.config.initial;\n            this.handlers.update('system', 'start');\n            this.handlers.update('system', 'change', 'state', this.state);\n            return this;\n        },\n    \n\n    // ------------------------------------------------------------------------------------------------\n    // api\n\n        /**\n         * Attempt to run an action, resulting in a transition to a state\n         *\n         * @param   {string}    action\n         * @param   {*[]}       rest\n         * @returns {boolean}\n         */\n        do: function (action, ...rest)\n        {\n            if(this.canDo(action) && !this.isPaused())\n            {\n                this.transition = Transition.create(this, action, rest);\n                if(action === this.config.defaults.initialize)\n                {\n                    this.handlers.update('system', 'initialize');\n                }\n                this.transition.exec();\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Attempt to go to a state\n         *\n         * Queries TransitionMap instance to see if a transition exists, then calls the related action if it does\n         *\n         * @param   {string}    state\n         * @param   {boolean}   [force]\n         * @returns {boolean}\n         */\n        go: function (state, force = false)\n        {\n            if(this.has(state))\n            {\n                if(force)\n                {\n                    unpause(this);\n                    this.transition = Transition.force(this, state);\n                    return this.end();\n                }\n                var action = this.transitions.getActionTo(this.state, state);\n                if(action)\n                {\n                    return this.do(action);\n                }\n                this.config.debug && console.warn('No transition exists from \"%s\" to \"%s\"', this.state, state);\n            }\n            return false;\n        },\n\n        /**\n         * Query a transition to see if a named action is available\n         *\n         * @param   {string}        action\n         * @returns {boolean}\n         */\n        canDo: function (action)\n        {\n            return this.transitions.has(this.state, action);\n        },\n\n        /**\n         *\n         * @param to\n         * @return {boolean}\n         */\n        canGo: function (to)\n        {\n            return this.transitions.getActionTo(this.state, to) !== null;\n        },\n\n        /**\n         * Test if a state exists\n         *\n         * @param   {string}    state\n         * @return  {boolean}\n         */\n        has: function(state)\n        {\n            if( ! this.transitions.hasState(state) )\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n                return false;\n            }\n            return true;\n        },\n\n        /**\n         * Test if the current state is the same as the supplied one\n         *\n         * @param   {string}    state       A state name to compare against the current state\n         * @returns {boolean}\n         */\n        is: function (state)\n        {\n            return state === this.state;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // flags\n\n        /**\n         * Test if the FSM has started\n         *\n         * @returns {boolean}\n         */\n        isStarted: function ()\n        {\n            return this.state !== '';\n        },\n\n        /**\n         * Test if the FSM is transitioning\n         *\n         * @returns {boolean}\n         */\n        isTransitioning: function ()\n        {\n            return !! this.transition;\n        },\n\n        /**\n         * Test if the FSM is paused (whilst transitioning)\n         *\n         * @returns {boolean}\n         */\n        isPaused: function ()\n        {\n            return this.transition\n                ? this.transition.paused\n                : false;\n        },\n\n        /**\n         * Test if the FSM is on the \"final\" state\n         *\n         * @returns {boolean}\n         */\n        isComplete: function ()\n        {\n            return this.state === this.config.final;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // transitions\n\n        /**\n         * Pause any current transition\n         *\n         * @returns {StateMachine}\n         */\n        pause: function ()\n        {\n            if(this.transition && !this.isPaused())\n            {\n                this.transition.pause();\n                this.handlers.update('transition', 'pause');\n            }\n            return this;\n        },\n\n        /**\n         * Resume any current transition\n         *\n         * @returns {StateMachine}\n         */\n        resume: function ()\n        {\n            if(this.transition && this.isPaused())\n            {\n                unpause(this);\n                this.transition.resume();\n            }\n            return this;\n        },\n\n        /**\n         * Cancel any current transition\n         *\n         * @returns {StateMachine}\n         */\n        cancel: function ()\n        {\n            if(this.transition)\n            {\n                unpause(this);\n                this.state = this.transition.from;\n                this.transition.clear();\n                delete this.transition;\n                this.handlers.update('transition', 'cancel');\n            }\n            return this;\n        },\n\n        /**\n         * End any current transition, skipping remaining handlers\n         *\n         * @returns {StateMachine}\n         */\n        end: function ()\n        {\n            if(this.transition)\n            {\n                unpause(this);\n                this.state = this.transition.to;\n                this.transition.clear();\n                delete this.transition;\n                this.handlers.update('system', 'change', 'state', this.state);\n                if(this.isComplete())\n                {\n                    this.handlers.update('system', 'complete');\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Reset the FSM to the initial, or supplied, state\n         *\n         * @returns {StateMachine}\n         */\n        reset:function(initial = '')\n        {\n            let state = initial || this.config.initial;\n            this.handlers.update('system', 'reset');\n            if(this.transition)\n            {\n                unpause(this);\n                this.transition.clear();\n                delete this.transition;\n                this.handlers.update('transition', 'cancel');\n            }\n            if(this.state !== state)\n            {\n                this.state = state;\n                this.handlers.update('system', 'change', 'state', this.state);\n            }\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // actions\n\n        /**\n         * Add a transition\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        add: function (action, from, to)\n        {\n            // 1 argument: shorthand transition, i.e 'next : a > b'\n            if(arguments.length === 1)\n            {\n                var transitions = parseTransition(action);\n                transitions.map( tx => this.add(tx.action, tx.from, tx.to));\n                return this;\n            }\n\n            // 3 arguments: longhand transition\n            this.transitions.add(action, from, to);\n            let states = this.transitions.getStates();\n            this.handlers.update('system', 'add', 'states', states);\n            return this;\n        },\n\n        /**\n         * Remove a state\n         *\n         * @param   {string}    state\n         * @return  {StateMachine}\n         */\n        remove: function (state)\n        {\n            this.handlers.remove('state.' + state);\n            this.transitions.remove(state);\n            let states = this.transitions.getStates();\n            this.handlers.update('system', 'remove', 'states', states);\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // handlers\n\n        /**\n         * Add an event handler\n         *\n         * Event handler signatures are build from the following grammar:\n         *\n         * - token      foo\n         * - property   .foo\n         * - event      :foo\n         * - action     @foo\n         * - targets    (foo|bar|baz)\n         *\n         * For example:\n         *\n         * - change\n         * - transition.pause\n         * - next:end\n         * - (a|b)@next\n         * - a@next\n         *\n         * The main event types are unique, so can be used without the namespace:\n         *\n         * - change\n         * - pause\n         * - complete\n         * - ...\n         *\n         * If your states and events are unique, they can also be used without qualification.\n         *\n         * See docs and demo for more information\n         *\n         * @param   {string}        id\n         * @param   {Function}      fn\n         * @return  {StateMachine}\n         */\n        on: function (id, fn)\n        {\n            /** @var {HandlerMeta} */\n            let result = this.handlers.parse(id);\n\n            if(this.config.debug)\n            {\n                console.log('StateMachine on: ' + id, [result.namespace, result.type], result.paths)\n            }\n\n            result.paths.map( (path, index) =>\n            {\n                let target = result.targets[index];\n\n                // warn for invalid actions / states\n                if(target !== '*')\n                {\n                    if(result.namespace === 'state')\n                    {\n                        if(!this.transitions.hasState(target))\n                        {\n                            this.config.debug && console.warn('StateMachine: Warning assigning state.%s handler; no such state \"%s\"', result.type, target);\n                        }\n                    }\n                    else if(result.namespace === 'action')\n                    {\n                        if(!this.transitions.hasAction(target))\n                        {\n                            this.config.debug && console.warn('StateMachine: Warning assigning action.%s handler; no such action \"%s\"', result.type, target);\n                        }\n                    }\n                }\n\n                // assign\n                this.handlers.add(path, fn);\n            });\n\n            return this;\n        },\n\n        off: function (id, fn)\n        {\n            let result = this.handlers.parse(id);\n            result.paths.map( path =>\n            {\n                this.handlers.remove(path, fn)\n            });\n        }\n\n\n};\n\nStateMachine.prototype.constructor = StateMachine;\n\n/**\n * Factory method\n *\n * @param   options\n * @returns {StateMachine}\n */\nStateMachine.create = function(options)\n{\n    return new StateMachine(options);\n};\n\nexport default StateMachine;\n\nfunction unpause(fsm)\n{\n    if(fsm.isPaused())\n    {\n        fsm.transition.paused = false;\n        fsm.handlers.update('transition', 'resume');\n    }\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/StateMachine.js\n **/","export function isObject (value)\n{\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport function isArray (value)\n{\n    return value instanceof Array;\n}\n\nexport function isString (value)\n{\n    return typeof value === 'string';\n}\n\nexport function isFunction(value)\n{\n    return value instanceof Function;\n}\n\nexport function isDefined (value)\n{\n    return typeof value !== 'undefined';\n}\n\nexport function isUndefined (value)\n{\n    return typeof value === 'undefined';\n}\n\nexport function trim (value)\n{\n    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n}\n\nexport function toHash(values) {\n    return values.reduce(function (obj, value) {\n        obj[value] = true;\n        return obj;\n    }, {})\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/utils/utils.js\n **/","import ValueMap from './ValueMap';\nimport { SystemEvent, TransitionEvent } from '../objects/events';\nimport { isFunction } from '../utils/utils';\n\nimport parseHandler from '../parsers/HandlerParser';\n\nfunction HandlerMap (fsm)\n{\n\tthis.fsm    = fsm;\n    this.map    = new ValueMap();\n}\n\nHandlerMap.prototype =\n{\n\n\tfsm: null,\n\n\tmap: null,\n\n    /**\n     * Parse event handler grammar into a HandlerMeta structure\n     *\n     * @param   {string}    id      A valid event handler id signature\n     * @returns {HandlerMeta}\n     */\n    parse: function (id)\n    {\n        return parseHandler(id, this.fsm);\n    },\n\n    /**\n     * Directly add a new handler\n     *\n     * @param   {string}    path    A 'namespace.target.type' target path to add a handler to\n     * @param   {Function}  fn      A callback function\n     * @returns {HandlerMap}\n     */\n    add: function (path, fn)\n    {\n        // check handler is a function\n        if(!isFunction(fn))\n        {\n            throw new Error('Error assigning \"' +path+ '\" handler; callback is not a function', fn);\n        }\n\n        this.map.insert(path, fn);\n        return this;\n    },\n\n    /**\n     * Directly remove a handler target\n     *\n     * @param   {string}    path    A 'namespace.target.type' target to be removed\n     * @returns {HandlerMap}\n     */\n    remove: function (path)\n    {\n        this.map.remove(path);\n        return this;\n    },\n\n    /**\n     * Get all handlers for a valid target path\n     *\n     * @param   {string}    path    A 'namespace.target.type' target path\n     * @returns {Function[]}        An array of callback functions\n     */\n    get:function(path)\n    {\n        return this.map.get(path);\n    },\n\n    /**\n     * Dispatch an event\n     *\n     * @param   {string}    namespace\n     * @param   {string}    type\n     * @param   {string}    key\n     * @param   {*}         value\n     * @returns {StateMachine}\n     */\n    update: function (namespace, type, key = '', value = null)\n    {\n        // create lookup path\n        let path = namespace + '.' + type;\n\n        //debug\n        this.fsm.config.debug && console.info('StateMachine: dispatch \"%s\"', path);\n\n        // build event\n        let event = namespace === 'system'\n            ? new SystemEvent(type, key, value)\n            : new TransitionEvent(type);\n\n        // dispatch\n        let handlers = this.map.get(path);\n        if(handlers)\n        {\n            handlers.map(fn => fn(event, this) );\n        }\n    }\n\n};\n\nexport default HandlerMap;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/HandlerMap.js\n **/","import {isObject, isArray, isDefined, isUndefined} from '../utils/utils';\n\n/**\n * Utility class to create, modify and delete nested hashes and values\n *\n * @constructor\n */\nexport default function ValueMap (data)\n{\n    this.data = data || {};\n}\n\nValueMap.prototype =\n{\n    data: null,\n\n    set: function (path, value)\n    {\n        set(this.data, path, value);\n        return this;\n    },\n\n    add:function(path, value)\n    {\n        add(this.data, path, value);\n        return this;\n    },\n\n    insert:function(path, value)\n    {\n        insert(this.data, path, value);\n        return this;\n    },\n\n    get:function(path)\n    {\n        return get(this.data, path);\n    },\n\n    has: function (path, value = undefined)\n    {\n        return has(this.data, path, value)\n    },\n\n    indexOf: function (path, value)\n    {\n        return indexOf(this.data, path, value)\n    },\n\n    remove: function (path, value = undefined)\n    {\n        remove(this.data, path, value);\n        return this;\n    },\n\n    keys:function(path)\n    {\n        return Object.keys(get(this.data, path));\n    },\n\n    values:function(path)\n    {\n        return values(this.data, path);\n    }\n\n};\n\nfunction create(obj, keys)\n{\n    let key;\n    while(keys.length)\n    {\n        key = keys.shift();\n        if( ! isObject(obj[key]) )\n        {\n            obj[key] = {};\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n\nexport function set(obj, path, value, index = -1)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    obj[key] = value;\n}\n\nfunction add(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    obj[key].push(value);\n}\n\nfunction insert(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    let parent = obj[key],\n        index = parent.indexOf(value);\n    if(index === -1)\n    {\n        parent.push(value);\n    }\n    else\n    {\n        parent[index] = value;\n    }\n}\n\nexport function get(obj, path)\n{\n    if(isUndefined(path) || path == '')\n    {\n        return obj;\n    }\n\n    let key,\n        keys = String(path).split('.');\n    while(keys.length > 1)\n    {\n        key = keys.shift();\n        if( ! obj.hasOwnProperty(key) )\n        {\n            return;\n        }\n        obj = obj[key];\n    }\n    key = keys.shift();\n    return obj[key];\n}\n\nexport function has(obj, path, value)\n{\n    let parent = get(obj, path);\n    return !! (isArray(parent) && isDefined(value)\n        ? parent.indexOf(value) !== -1\n        : isUndefined(value)\n            ? isDefined(parent)\n            : parent === value);\n}\n\nexport function indexOf (obj, path, value)\n{\n    let arr = get(obj, path);\n    if(isArray(arr))\n    {\n        return arr.indexOf(value);\n    }\n    return -1;\n}\n\nexport function remove(obj, path, value)\n{\n    let parent = obj,\n        keys = String(path || '').split('.'),\n        key = keys.pop();\n\n    if(keys.length)\n    {\n        parent = get(obj, keys.join('.'))\n    }\n    if(isDefined(value) && isArray(parent[key]))\n    {\n        let target = parent[key];\n        var index = target.indexOf(value);\n        if(index > -1)\n        {\n            target.splice(index, 1);\n            if(target.length === 0)\n            {\n                delete parent[key];\n            }\n            return true;\n        }\n        return false;\n    }\n    else\n    {\n        if(isObject(parent) && obj.hasOwnProperty(key))\n        {\n            delete parent[key];\n            return true;\n        }\n    }\n    return false\n}\n\nexport function values(obj, path)\n{\n    var values = [];\n    var target = get(obj, path);\n    if(isObject(target))\n    {\n        for(var name in target)\n        {\n            if(target.hasOwnProperty(name))\n            {\n                values.push(target[name]);\n            }\n        }\n    }\n    return values;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/ValueMap.js\n **/","// ------------------------------------------------------------------------------------------------\n// setup\n\n    /**\n     * @prop {string}       namespace   The Event namespace; i.e. state or action\n     * @prop {string}       type        The Event type;      i.e. leave/enter (state) or start/end (action)\n     * @prop {string}       target      The Event target;    i.e. intro (state), next (action), or * (all states or types)\n     * @prop {Transition}   transition  The transition which generated the event\n     */\n    let event =\n    {\n        // properties\n        namespace   : null,\n        type        : null,\n        target      : null,\n        transition          : null\n    };\n\n    function initialize (event, namespace, type, target, transition)\n    {\n        event.namespace     = namespace;\n        event.type          = type;\n        event.target        = target;\n        event.transition    = transition;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// ActionEvent\n\n    export function ActionEvent (type, target, transition)\n    {\n        initialize(this, 'action' ,type, target, transition);\n    }\n    ActionEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// StateEvent\n\n    export function StateEvent (type, target, transition)\n    {\n        initialize(this, 'state' ,type, target, transition);\n    }\n    StateEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// SystemEvent\n\n    export function SystemEvent (type, key, value)\n    {\n        this.type   = type;\n        this.key    = key;\n        this.value  = value;\n    }\n\n    SystemEvent.prototype =\n    {\n        namespace   : 'system',\n        type        : '',\n        key         : '',\n        value       : null\n    };\n\n\n// ------------------------------------------------------------------------------------------------\n// TransitionEvent\n\n    export function TransitionEvent (type)\n    {\n        this.type = type;\n    }\n\n    TransitionEvent.prototype =\n    {\n        namespace   : 'transition',\n        type        : ''\n    };\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/objects/events.js\n **/","import HandlerMeta from './HandlerMeta';\nimport { ParseError } from '../objects/errors';\nimport Lexer from '../utils/Lexer'\n\n\n// ------------------------------------------------------------------------------------------------\n// functions\n\n    function isNamespace(token)\n    {\n        return /^(system|transition|action|state)$/.test(token);\n    }\n\n    function isSystem(token)\n    {\n        return /^(add|remove|start|change|update|complete|reset)$/.test(token);\n    }\n\n    function isTransition(token)\n    {\n        return /^(pause|resume|cancel)$/.test(token);\n    }\n\n    function isAction(token, fsm)\n    {\n        return fsm.transitions.hasAction(token);\n    }\n\n    function isState(token, fsm)\n    {\n        return fsm.transitions.hasState(token);\n    }\n\n    function getNamespace(token)\n    {\n        return isSystem(token)\n            ? 'system'\n            : isTransition(token)\n                ? 'transition'\n                : null;\n    }\n\n    function getEventNamespace(token)\n    {\n        return /^(enter|leave)$/.test(token)\n            ? 'state'\n            : /^(start|end)$/.test(token)\n                ? 'action'\n                : null;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// export\n\n    /**\n     * Parses event handler id into HandlerMeta instance\n     *\n     * @param   {string}        id      The handler id to parse, i.e. '@next', 'intro:end', 'change', etc\n     * @param   {StateMachine}  fsm     A StateMachine instance to test for states and actions\n     * @return  {HandlerMeta}\n     */\n    export default function parse(id, fsm)\n    {\n        return parser.parse(id, fsm);\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// objects\n\n    var lexer = new Lexer({\n        targets  : /\\.?\\((.+?)\\)/,\n        property : /\\.(\\w+)/,\n        action   : /@(\\w+)/,\n        event    : /:(\\w+)/,\n        word     : /(\\w+)/\n    });\n\n    var parser =\n    {\n        result  :null,\n\n        /**\n         * Parses event handler id into HandlerMeta instance\n         *\n         * Resolving namespace, type and target properties\n         *\n         * @param   {string}        id\n         * @param   {StateMachine}  fsm\n         * @return  {HandlerMeta}\n         */\n        parse:function(id, fsm)\n        {\n            // variables\n            let defaults    = fsm.config.defaults;\n            let tokens      = lexer.process(id);\n            let result      = this.result = new HandlerMeta(id);\n\n            // process\n            tokens.map( token => {\n                this.parseToken(token.name, token.value, fsm);\n            });\n\n            if(!result.type)\n            {\n                result.setType(defaults[result.namespace]);\n            }\n\n            // return result\n            return result.update();\n        },\n\n        /**\n         * Parse token name and value\n         *\n         * @param   {string}        name\n         * @param   {string}        value\n         * @param   {StateMachine}  fsm\n         */\n        parseToken:function(name, value, fsm)\n        {\n            // variables\n            let namespace,\n                values;\n\n            // process\n            switch(name)\n            {\n                case 'targets':\n\n                    values = value.match(/\\w+/g);\n                    namespace = isState(values[0], fsm)\n                        ? 'state'\n                        : isAction(values[0], fsm)\n                            ? 'action'\n                            : null;\n\n                    if(namespace)\n                    {\n                        return this.result\n                            .setNamespace(namespace)\n                            .setTarget(values);\n                    }\n\n                    throw new ParseError('Unknown target(s) type \"(' +value+ ')\"');\n\n                case 'action':\n\n                    if(!isAction(value, fsm))\n                    {\n                        throw new ParseError('Unknown action \"' +value+ '\"');\n                    }\n\n                    if(!this.result.namespace)\n                    {\n                        this.result.setNamespace('action')\n                    }\n                    return this.result.namespace === 'state'\n                        ? this.result.setType(value)\n                        : this.result.setTarget(value);\n\n                case 'event':\n\n                    if((namespace = getEventNamespace(value)))\n                    {\n                        return this.result\n                            .setNamespace(namespace)\n                            .setType(value);\n                    }\n                    throw new ParseError('Unknown event \"' +value+ '\"');\n\n                // any \".property\"; could be system.change, intro.next\n                case 'property':\n\n                    return this.parseToken('word', value, fsm);\n\n                default:\n\n                    // top-level namespace, like system, transition, state\n                    if(isNamespace(value))\n                    {\n                        return this.result\n                            .setNamespace(value);\n                    }\n\n                    // generic value, like change, add, update\n                    if((namespace = getNamespace(value)))\n                    {\n                        return this.result\n                            .setNamespace(namespace)\n                            .setType(value);\n                    }\n\n                    // existing state, like a, b, c\n                    if (isState(value, fsm))\n                    {\n                        return this.result\n                            .setNamespace('state')\n                            .setTarget(value);\n                    }\n\n                    // existing action, like next, back, quit\n                    if (isAction(value, fsm))\n                    {\n                        return this.parseToken('action', value, fsm);\n                    }\n\n                    // unknown\n                    throw new ParseError('Unknown token \"' +value+ '\"');\n            }\n        }\n\n    };\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/HandlerParser.js\n **/","import { ParseError } from '../objects/errors';\n\nfunction HandlerMeta (id)\n{\n    this.id = id;\n    this.targets = ['*'];\n}\n\nHandlerMeta.prototype =\n{\n    id          : '',\n    namespace   : '',\n    type        : '',\n    targets     : [],\n    paths       : [],\n\n    setNamespace:function(value)\n    {\n        if(this.namespace && value !== this.namespace)\n        {\n            throw new ParseError('Cannot set namespace \"' +value+ '\" for existing result ' +this.toString());\n        }\n        this.namespace = value;\n        return this;\n    },\n\n    setType:function(value)\n    {\n        if(this.type && value !== this.type)\n        {\n            throw new ParseError('Cannot set type \"' +value+ '\" for existing result ' +this.toString());\n        }\n        this.type = value;\n        return this;\n    },\n\n    setTarget:function(value)\n    {\n        this.targets = Array.isArray(value) ? value : [value];\n        return this;\n    },\n\n    update:function()\n    {\n        this.paths = this.targets.map( target =>\n        {\n            var segments = this.namespace === 'action' || this.namespace === 'state'\n                ? [this.namespace, target, this.type]\n                : [this.namespace, this.type];\n            return segments.join('.');\n        });\n        return this;\n    },\n\n    toString:function()\n    {\n        var parts = this.namespace && this.type\n            ? [this.namespace, this.type]\n            : this.namespace\n                ? [this.namespace]\n                : [this.type];\n        return '[' + parts.join(':') + ']';\n    }\n\n};\n\nexport default HandlerMeta;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/HandlerMeta.js\n **/","export function ParseError(message)\n{\n    this.name = 'ParseError';\n    this.message = message;\n}\n\nParseError.prototype = Error.prototype;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/objects/errors.js\n **/","export default function Lexer(rules)\n{\n    this.rules = [];\n    if(rules)\n    {\n        Object.keys(rules).map( name => this.addRule(name, rules[name]) );\n    }\n}\n\nLexer.prototype =\n{\n    /** @var {String} */\n    source  : null,\n\n    /** @var {Rule[]} */\n    rules   : null,\n\n    /** @var {Token[]} */\n    tokens  : null,\n\n    /** @var {Number} */\n    index   : 0,\n\n    process:function(source)\n    {\n        this.source = source;\n        this.tokens = [];\n        this.index  = 0;\n        this.next();\n        return this.tokens;\n    },\n\n    addRule:function(name, rx)\n    {\n        this.rules.push(new Rule(name, new RegExp('^' + rx.source)));\n    },\n\n    next:function()\n    {\n        if(this.index < this.source.length)\n        {\n            let source  = this.source.substr(this.index);\n            let state = this.rules.some(rule =>\n            {\n                var matches = source.match(rule.rx);\n                if(matches)\n                {\n                    this.tokens.push(new Token(rule.name, matches[1]));\n                    this.index += matches[0].length;\n                    return true;\n                }\n                return false;\n            });\n\n            // not matched\n            if(!state)\n            {\n                throw new Error('Unable to match source at position ' + this.index + ': \"' +source+'\"');\n            }\n\n            // match\n            this.next();\n        }\n    }\n};\n\nfunction Token(name, value)\n{\n    this.name = name;\n    this.value = value;\n}\n\nfunction Rule(name, rx)\n{\n    this.name = name;\n    this.rx = rx;\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/utils/Lexer.js\n **/","import ValueMap from './ValueMap';\nimport parseTransition from '../parsers/TransitionParser';\n\nfunction TransitionMap ()\n{\n    this.map        = new ValueMap();\n    this.states     = [];\n    this.actions    = [];\n}\n\nTransitionMap.prototype =\n{\n    // ------------------------------------------------------------------------------------------------\n    // properties\n\n        map     : null,\n        states  : null,\n        actions : null,\n\n\n    // ------------------------------------------------------------------------------------------------\n    // add and remove states\n\n        /**\n         * Add event handler parsing\n         *\n         * @param   {string}    tx\n         * @returns {TransitionMeta[]}\n         */\n        parse: function (tx)\n        {\n            return parseTransition(tx);\n        },\n\n        /**\n         * Adds a new transition\n         * \n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @returns {TransitionMap}\n         */\n        add: function (action, from, to)\n        {\n            this.map.set(from + '.' + action, to);\n            return update(this);\n        },\n\n        /**\n         * Removes an existing state\n         *\n         * @param   {string}    state\n         * @returns {TransitionMap}\n         */\n        remove: function (state)\n        {\n            // remove \"from\" state\n            this.map.remove(state);\n\n            // remove \"to\" states\n            let data = this.map.data;\n            for(let name in data)\n            {\n                let from = data[name];\n                for(let action in from)\n                {\n                    if(from[action] === state)\n                    {\n                        delete from[action];\n                    }\n                }\n            }\n\n            // update and return\n            return update(this);\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // accessors\n\n        /**\n         * Get all available actions (or action => states map) for a given state\n         *\n         * @param   {string}    state       Name of a state to get actions for\n         * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n         * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n         */\n        getActionsFrom: function (state, asMap = false)\n        {\n            if(this.has(state))\n            {\n                let actions = this.map.get(state);\n                return actions\n                    ? asMap\n                        ? actions\n                        : Object.keys(actions)\n                    : [];\n            }\n            return [];\n        },\n\n        /**\n         * Get the first available action to move from one state to another (if there is one)\n         *\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {string|null}\n         */\n        getActionTo: function (from, to)\n        {\n            let actions = this.map.get(from);\n            for(let action in actions)\n            {\n                if(actions[action] === to)\n                {\n                    return action;\n                }\n            }\n            return null;\n        },\n\n        /**\n         * Get all available \"to\" states for a given state\n         *\n         * Loops over all actions and returns a unique array of \"to\" states\n         *\n         * @param   {string|null}    [state]    Optional name of a state to get states for. Defaults to the current state\n         * @returns {string[]}                  An array of string states\n         */\n        getToStates: function (state)\n        {\n            if(this.hasState(state))\n            {\n                let actions = this.getActionsFrom(state, true);\n                return Object.keys(actions).map( name => actions[name] );\n            }\n            return null;\n        },\n\n        /**\n         * Get all states within the system\n         *\n         * @return  {string[]}\n         */\n        getStates: function ()\n        {\n            return [].concat(this.states);\n        },\n\n        /**\n         * Get all actions within the system\n         *\n         * @return  {string[]}\n         */\n        getActions: function ()\n        {\n            return [].concat(this.actions);\n        },\n\n        /**\n         * General getter\n         *\n         * @param   {string}    path\n         * @return  {*}\n         */\n        get:function(path)\n        {\n            path = Array.prototype.slice.apply(arguments).join('.');\n            return this.map.get(path);\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // checks\n\n        /**\n         * Test if the given state exists within the system\n         *\n         * @param   {string}    state\n         * @returns {boolean}\n         */\n        hasState: function (state)\n        {\n            return this.states.indexOf(state) !== -1;\n        },\n\n        /**\n         * Test if the given action exists within the system\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        hasAction: function (action)\n        {\n            return this.actions.indexOf(action) !== -1;\n        },\n\n        /**\n         * Utility function to directly check if the composed ValueMap has the requested path\n         *\n         * @param   {string}    path    Pass a path using dot notation, i.e. 'a.next.b' or pass individual arguments, i.e. from, action, to\n         * @returns {boolean}\n         */\n        has: function (path)\n        {\n            path = Array.prototype.slice.apply(arguments).join('.');\n            return !! path\n                ? this.map.has(path)\n                : false;\n        }\n\n};\n\nTransitionMap.prototype.constructor = TransitionMap;\n\n/**\n * Private utility function to update existing states and actions\n *\n * @param   {TransitionMap} target\n * @returns {TransitionMap}\n */\nfunction update(target)\n{\n    // variables\n    var actions    = {};\n    var states     = {};\n    var data     = target.map.data;\n    var to;\n\n    // remove \"to\" states\n    for(let from in data)\n    {\n        states[from] = true;\n        for(let action in data[from])\n        {\n            actions[action] = true;\n            to = data[from][action];\n            if(typeof to !== 'function')\n            {\n                states[to] = true;\n            }\n        }\n    }\n\n    // update\n    target.states  = Object.keys(states);\n    target.actions = Object.keys(actions);\n\n    // return\n    return target;\n}\n\nexport default TransitionMap;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/TransitionMap.js\n **/","import { isString } from '../utils/utils';\nimport { ParseError } from '../objects/errors';\nimport TransitionMeta from './TransitionMeta';\n\n// ------------------------------------------------------------------------------------------------\n// functions\n\n    function getError(tx, message)\n    {\n        return 'Invalid transition shorthand pattern \"' +tx+ '\" - ' + message;\n    }\n\n    function add(transitions, action, from, to)\n    {\n        transitions.push(new TransitionMeta(action, from, to));\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// export\n\n    /**\n     * Parses/expands transition objects/strings into discrete transitions\n     *\n     * @returns {TransitionMeta[]}  An array of TransitionMeta instances\n     */\n    export default function parse (tx)\n    {\n        if(isString(tx))\n        {\n            // pre-process string\n            tx = tx\n                .replace(/([|=:<>])/g, ' $1 ')\n                .replace(/\\s+/g, ' ')\n                .replace(/^\\s+|\\s+$/g,'');\n\n            // ensure string is valid\n            if(!/^\\w+ [:|=] \\w[\\w ]*[<>] \\w[\\w ]*/.test(tx))\n            {\n                throw new ParseError(getError(tx, 'cannot determine action and states'));\n            }\n\n            // initialize variables\n            let transitions = [],\n                matches = tx.match(/([*\\w ]+|[<>])/g),\n                action  = matches.shift().replace(/\\s+/g, ''),\n                stack   = [],\n                match   = '',\n                op      = '',\n                a       = '',\n                b       = '';\n\n            // process states\n            while(matches.length)\n            {\n                // get the next match\n                match = matches.shift();\n                if(/[<>]/.test(match))\n                {\n                    op = match;\n                }\n                else\n                {\n                    match = match.match(/[*\\w]+/g);\n                    match = match.length === 1 ? match[0] : match;\n                    stack.push(match);\n                }\n\n                // process matches if stack is full\n                if(stack.length === 2)\n                {\n                    [a, b] = op === '<'\n                        ? [stack[1], stack[0]]\n                        : stack;\n                    if(Array.isArray(a) && Array.isArray(b))\n                    {\n                        throw new ParseError(getError(tx, 'transitioning between 2 arrays doesn\\'t make sense'));\n                    }\n                    if(Array.isArray(a))\n                    {\n                        a.map( a => add(transitions, action, a, b) );\n                    }\n                    else if(Array.isArray(b))\n                    {\n                        b.map( b => add(transitions, action, a, b) );\n                    }\n                    else\n                    {\n                        add(transitions, action, a, b);\n                    }\n\n                    // discard original match once processed\n                    stack.shift();\n                }\n\n            }\n\n            // return\n            return transitions;\n        }\n\n        // return objects wrapped in an array\n        return [tx];\n    }\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/TransitionParser.js\n **/","function TransitionMeta(action, from, to)\n{\n    this.action = action;\n    this.from = from;\n    this.to = to;\n}\n\nexport default TransitionMeta;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/TransitionMeta.js\n **/","import { StateEvent, ActionEvent } from '../objects/events';\nimport { isFunction } from '../utils/utils';\n\n/**\n * Transition class\n *\n * Responsible for managing events in the flow from state to state.\n *\n * This adds all handlers for the current action start/end and state from/to to an array:\n *\n * - <namespace>.<target>.<type>[]\n *\n * So going from state \"a\" to state \"b\" with action \"next\" should build:\n *\n * - action.*.start[]\n * - action.next.start[]\n * - state.a.leave[]\n * - state.*.leave[]\n * - state.*.enter[]\n * - state.b.enter[]\n * - action.next.end[]\n * - action.*.end[]\n *\n * This can be changed by passing in an order array in fsm.config\n *\n * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n *\n * From a callback, you can:\n *\n * - return false to cancel the transition\n * - return true to pause the transition\n * - not return a value (the transition continues)\n *\n * TransitionMap can also be paused, resumed, or cancelled by calling\n * the appropriate method on, or from:\n *\n * - the event\n * - the transition\n * - the state machine\n *\n * Cancelled transitions will reset the FSM to the previous \"from\" state\n *\n * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n *\n * @param {StateMachine}    fsm\n * @param {string}          action\n * @param {string}          from\n * @param {string}          to\n */\nfunction Transition (fsm, action, from, to)\n{\n    this.fsm        = fsm;\n    this.action     = action;\n    this.from       = from;\n    this.to         = to;\n    this.clear();\n}\n\n/**\n * @prop {StateMachine}    fsm\n * @prop {string}          action\n * @prop {string}          from\n * @prop {string}          to\n * @prop {Function[]}      handlers\n */\nTransition.prototype =\n{\n    fsm         : null,\n    action      : '',\n    from        : '',\n    to          : '',\n    paused      : false,\n    handlers    : null,\n\n    clear: function ()\n    {\n        this.paused = false;\n        this.handlers = [];\n    },\n\n    /**\n     * Execute the next event's callbacks\n     * @returns {*}\n     */\n\texec: function ()\n\t{\n\t    if( ! this.paused )\n        {\n            if(this.handlers.length)\n            {\n                var handler = this.handlers.shift();\n                var state = handler();\n                if(state === false)\n                {\n                    return this.fsm.cancel();\n                }\n                if(state === true)\n                {\n                    return this.fsm.pause();\n                }\n                this.exec();\n            }\n            else\n            {\n                this.fsm.end();\n            }\n        }\n        return this;\n\t},\n\n    pause: function ()\n    {\n        this.paused = true;\n        return this;\n    },\n\n    resume: function ()\n    {\n        this.paused = false;\n        return this.exec();\n    }\n};\n\nexport default\n{\n    /**\n     * Create the Transition object\n     *\n     * - Set up variables, and queue\n     * - Determine paths to relevant handlers\n     * - Build State and Action Event objects\n     * - Pre-bind all handlers\n     * - Append to queue\n     *\n     * @param {StateMachine}    fsm\n     * @param {string}          action\n     * @param {Array}           params\n     * @returns {Transition}\n     */\n    create:function (fsm, action, params)\n    {\n        // transition properties\n        let scope   = fsm.config.scope;\n        let from    = fsm.state;\n        let to      = fsm.transitions.get(from, action);\n        let vars    = {action, to, from};\n\n        // handle \"to\" being a function\n        if(isFunction(to))\n        {\n            to = to.apply(scope, params);\n            if(!fsm.transitions.hasState(to))\n            {\n                throw new Error('Invalid \"to\" state \"' +to+ '\"');\n            }\n        }\n\n        // transition\n        let queue       = [];\n        let transition  = new Transition(fsm, action, from, to);\n\n        // build handlers array\n        fsm.config.order.map( path =>\n        {\n            // replace path tokens\n            path = path.replace(/{(\\w+)}/g, (all, token) => vars[token]);\n            let handlers = fsm.handlers.get(path);\n\n            // do it!\n            if(handlers)\n            {\n                let [namespace, target, type] = path.split('.');\n                handlers = handlers.map( handler =>\n                {\n                    // build event object\n                    let Event = namespace === 'state' ? StateEvent : ActionEvent;\n                    let event = new Event(type, target, transition);\n\n                    // pre-bind handlers, scopes and params\n                    // this way scope and params don't need to be passed around\n                    // and the call from Transition is always just `value = handler()`\n                    return function()\n                    {\n                        return handler.apply(scope, [event, fsm].concat(params));\n                    }\n                });\n\n                // add to queue\n                queue = queue.concat(handlers);\n            }\n        });\n\n        // return\n        transition.handlers = queue;\n        return transition;\n    },\n\n    force: function(fsm, state)\n    {\n        let transition = new Transition(fsm, '', fsm.state, state);\n        transition.paused = fsm.transition ? fsm.transition.paused : false;\n        return transition;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/classes/Transition.js\n **/","export default function Config (options)\n{\n    'initial final start debug scope transitions'\n        .match(/\\w+/g)\n        .map( name =>\n        {\n            if(options.hasOwnProperty(name))\n            {\n                this[name] = options[name];\n            }\n        });\n\n    // order\n    this.order      = options.order || this.getDefaultOrder();\n\n    // defaults\n    this.defaults   = Object.assign({\n\n        // allow user to specify a custom initialize event name\n        initialize  :'initialize',\n\n        // allow user to specify alternate triggers for event and action ids\n        action      :'start',\n        state       :'enter'\n\n    }, options.defaults);\n}\n\nConfig.prototype =\n{\n    /** @var string */\n    initial     : '',\n\n    /** @var string */\n    final       : '',\n\n    /** @var boolean */\n    start       : true,\n\n    /** @var boolean */\n    debug       : false,\n\n    /** @var object */\n    scope       : null,\n\n    /** @var *[] */\n    transitions : null,\n\n    /**\n     * The order to run transition callbacks in\n     *\n     * @type {string[]} type.target\n     */\n    order       : null,\n\n    /**\n     * Sets defaults for various declarations\n     *\n     * @type {Object}\n     */\n    defaults    : null,\n\n    getDefaultOrder: function ()\n    {\n        return [\n            'action.*.start',\n            'action.{action}.start',\n            'state.*.{action}',\n            'state.{from}.{action}',\n            'state.{from}.leave',\n            'state.*.leave',\n            'state.*.enter',\n            'state.{to}.enter',\n            'action.{action}.end',\n            'action.*.end'\n        ];\n    }\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/classes/Config.js\n **/"],"sourceRoot":""}