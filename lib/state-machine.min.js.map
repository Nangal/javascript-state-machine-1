{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///state-machine.min.js","webpack:///webpack/bootstrap e1d9771444d8219809c6","webpack:///./src/StateMachine.js","webpack:///./src/utils/ValueMap.js","webpack:///./src/utils/utils.js","webpack:///./src/Transition.js","webpack:///./src/Events.js","webpack:///./src/utils/handlers.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","StateMachine","scope","config","arguments","length","_ref","state","states","transitions","_ValueMap2","actions","handlers","initialize","addStates","fsm","key","map","event","addState","_utils","isString","indexOf","push","Object","defineProperty","value","_typeof","Symbol","iterator","constructor","prototype","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","next","done","err","Array","isArray","TypeError","_ValueMap","_Transition","_Transition2","_Events","_handlers","parse","getPath","transition","_this","events","initial","matches","match","_matches","name","from","op","to","add","_ref2","hasOwnProperty","on","defer","defaults","assign","action","order","update","namespace","type","signature","SystemEvent","TransitionEvent","dispatch","do","can","isPaused","_len","rest","_key","create","exec","go","force","has","end","getActionForState","debug","console","info","warn","cannot","is","getStatesFor","getActionsFor","keys","_this2","asMap","get","_ret","v","isStarted","isTransitioning","paused","isComplete","pause","resume","cancel","clear","reset","set","remove","fn","_this3","_parse","_parse2","targets","log","target","isFunction","Error","path","insert","off","_this4","_parse3","_parse4","ValueMap","data","shift","isObject","String","split","pop","parent","index","isUndefined","isDefined","join","splice","values","_set","_get","_has","_indexOf","_remove","_values","toString","Function","trim","replace","Transition","handler","params","vars","apply","queue","all","token","_path$split","_path$split2","Event","StateEvent","ActionEvent","concat","isState","isAction","getTargets","determineValue","test","lookup","namespaces","segments","forEach","segment","char","start","change","complete","enter","leave"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAA,kBAAAH,GACA,gBAAAC,SACAA,QAAA,aAAAD,IAEAD,EAAA,aAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,EAAQD,EAASM,GAE/B,YA0BA,SAASS,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GE5EzE,QAASG,GAAcC,EAAOC,GAGzC,GAAuB,GAApBC,UAAUC,OACb,IAAAC,IACuBJ,EAAO,KAAzBC,GADLG,EAAA,GACaJ,EADbI,EAAA,GAKApB,KAAKgB,MAAiBA,EACtBhB,KAAKqB,MAAiB,GACtBrB,KAAKsB,UACLtB,KAAKuB,YAAiB,GAAAC,cACtBxB,KAAKyB,QAAiB,GAAAD,cACtBxB,KAAK0B,SAAiB,GAAAF,cAGnBP,GAECjB,KAAK2B,WAAWV,GAqvBxB,QAASW,GAAUC,EAAKC,EAAKP,GAEzBA,EAAYQ,IAAK,SAAAC,GAAA,MAASC,GAASJ,EAAKG,EAAMF,MAGlD,QAASG,GAAUJ,EAAKR,IAEhB,EAAAa,EAAAC,UAASd,IAAUQ,EAAIP,OAAOc,QAAQf,SAEtCQ,EAAIP,OAAOe,KAAKhB,GF7tBvBiB,OAAOC,eAAe3C,EAAS,cAC3B4C,OAAO,GAGX,IAAIC,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAU/B,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAX8B,SAAyB9B,EAAIgC,cAAgBF,QAAU9B,IAAQ8B,OAAOG,UAAY,eAAkBjC,IAElQkC,EAAiB,WAAc,QAASC,GAAcC,EAAKC,GAAK,GAAIC,MAAeC,GAAK,EAAUC,GAAK,EAAWC,EAAKC,MAAW,KAAM,IAAK,GAAiCC,GAA7BC,EAAKR,EAAIN,OAAOC,cAAmBQ,GAAMI,EAAKC,EAAGC,QAAQC,QAAoBR,EAAKb,KAAKkB,EAAGf,QAAYS,GAAKC,EAAK/B,SAAW8B,GAA3DE,GAAK,IAAoE,MAAOQ,GAAOP,GAAK,EAAMC,EAAKM,EAAO,QAAU,KAAWR,GAAMK,EAAG,WAAWA,EAAG,YAAe,QAAU,GAAIJ,EAAI,KAAMC,IAAQ,MAAOH,GAAQ,MAAO,UAAUF,EAAKC,GAAK,GAAIW,MAAMC,QAAQb,GAAQ,MAAOA,EAAY,IAAIN,OAAOC,WAAYL,QAAOU,GAAQ,MAAOD,GAAcC,EAAKC,EAAa,MAAM,IAAIa,WAAU,2DAEtlBlE,cE5DuBmB,CANxB,IAAAgD,GAAA7D,EAAA,GFsEKsB,EAAab,EAAuBoD,GErEzCC,EAAA9D,EAAA,GFyEK+D,EAAetD,EAAuBqD,GExE3CE,EAAAhE,EAAA,GACAgC,EAAAhC,EAAA,GACAiE,EAAAjE,EAAA,EAyBAa,GAAaqD,MAAbD,EAAAC,MACArD,EAAasD,QAAbF,EAAAE,QAaAtD,EAAa8B,WAiBLvB,OAAc,KA6BdC,YAAc,KA2BdE,QAAc,KA4BdC,SAAa,KAObL,MAAc,GAOdiD,WAAc,KAOdtD,MAAa,KAObC,OAAc,KAYdU,WAAW,SAAUV,GACrB,GAAAsD,GAAAvE,IAEIA,MAAKiB,OAAaA,EAGfA,EAAOD,QAENhB,KAAKgB,MAAQC,EAAOD,OAIxBY,EAAU5B,KAAM,OAAQiB,EAAOuD,QAC/B5C,EAAU5B,KAAM,KAAMiB,EAAOuD,QAGvBvD,EAAOwD,UAETxD,EAAOwD,QAAUzE,KAAKsB,OAAO,IAIjCL,EAAOuD,OAAOzC,IAAK,SAAAC,GAGf,IAAG,EAAAE,EAAAC,UAASH,GACZ,CACI,GAAI0C,GAAU1C,EAAM2C,MAAM,6CAD9BC,EAAA9B,EAEgC4B,EAFhC,GAEUG,EAFVD,EAAA,GAEgBE,EAFhBF,EAAA,GAEsBG,EAFtBH,EAAA,GAE0BI,EAF1BJ,EAAA,EAGI,IAAU,MAAPG,EAIC,MAFAR,GAAKU,IAAIJ,EAAMC,EAAME,OACrBT,GAAKU,IAAIJ,EAAMG,EAAIF,EAGvB,IAAU,MAAPC,EACH,IAAAG,IACkBF,EAAIF,EAAjBA,GADLI,EAAA,GACWF,EADXE,EAAA,GAGAX,EAAKU,IAAIJ,EAAMC,EAAME,OAMrBT,GAAKU,IAAIjD,EAAM6C,KAAM7C,EAAM8C,KAAM9C,EAAMgD,KAK/C,KAAI,GAAIH,KAAQ5D,GAAOS,SAEhBT,EAAOS,SAASyD,eAAeN,IAE9B7E,KAAKoF,GAAGP,EAAM5D,EAAOS,SAASmD,GAKhC5D,GAAOoE,QAETrF,KAAKqB,MAAQJ,EAAOwD,SAQxBxD,EAAOqE,SAAWhD,OAAOiD,QAGrB5D,WAAa,aAGb6D,OAAa,QACbnE,MAAa,SAEdJ,EAAOqE,UAOVrE,EAAOwE,MAAQxE,EAAOwE,QAElB,iBACA,wBACA,qBACA,wBACA,qBACA,gBACA,gBACA,mBAEA,sBACA,iBAaRC,OAAQ,SAAUC,EAAWC,GAC7B,GADmC9D,GACnCZ,UAAAC,OAAA,GAAAmC,SAAApC,UAAA,GAAAA,UAAA,GADyC,GAAIsB,EAC7CtB,UAAAC,OAAA,GAAAmC,SAAApC,UAAA,GAAAA,UAAA,GADqD,KAE7C2E,EAAYF,EAAY,IAAMC,EAC9B5D,EAAsB,WAAd2D,EACN,GAAAzB,GAAA4B,YAAgBF,EAAM9D,EAAKU,GAC3B,GAAA0B,GAAA6B,gBAAoBH,EAE1B,OADA5F,MAAKgG,SAASH,EAAW7D,GAClBhC,MAcXiG,KAAI,SAAUT,GAEV,GAAGxF,KAAKkG,IAAIV,KAAYxF,KAAKmG,WAC7B,QAAAC,GAAAlF,UAAAC,OAHqBkF,EAGrBzC,MAAAwC,EAAA,EAAAA,EAAA,KAAAE,EAAA,EAAAA,EAAAF,EAAAE,IAHqBD,EAGrBC,EAAA,GAAApF,UAAAoF,EAQI,OAPAtG,MAAKsE,WAAaL,aAAWsC,OAAOvG,KAAMwF,EAAQa,GAC/Cb,IAAWxF,KAAKiB,OAAOqE,SAAS3D,YAE/B3B,KAAK0F,OAAO,SAAU,cAE1B1F,KAAK0F,OAAO,SAAU,SAAU,aAAc1F,KAAKsE,YACnDtE,KAAKsE,WAAWkC,QACT,EAEX,OAAO,GAYXC,GAAI,SAAUpF,GACd,GADqBqF,GACrBxF,UAAAC,OAAA,GAAAmC,SAAApC,UAAA,IAAAA,UAAA,EACI,IAAGlB,KAAK2G,IAAItF,GACZ,CACI,GAAGqF,EAGC,MADA1G,MAAKsE,WAAaL,aAAWyC,MAAM1G,KAAMqB,GAClCrB,KAAK4G,KAEhB,IAAIpB,GAASxF,KAAK6G,kBAAkBxF,EACpC,IAAGmE,EAEC,MAAOxF,YAAQwF,EAEnBxF,MAAKiB,OAAO6F,OAASC,QAAQC,KAAK,yCAA0ChH,KAAKqB,MAAOA,OAIxFrB,MAAKiB,OAAO6F,OAASC,QAAQE,KAAK,qBAAsB5F,EAE5D,QAAO,GASX6E,IAAK,SAAUV,GAMX,MAJMxF,MAAKyB,QAAQkF,IAAInB,IAEnBxF,KAAKiB,OAAO6F,OAASC,QAAQE,KAAK,sBAAuBzB,KAEnDxF,KAAKuB,YAAYoF,IAAI3G,KAAKqB,MAAOmE,IAS/C0B,OAAQ,SAAU1B,GAEd,OAASxF,KAAKkG,IAAIV,IAStB2B,GAAI,SAAU9F,GAMV,MAJGrB,MAAKsB,OAAOc,QAAQf,SAEnBrB,KAAKiB,OAAO6F,OAASC,QAAQE,KAAK,qBAAsB5F,GAErDA,IAAUrB,KAAKqB,OAS1BsF,IAAK,SAAStF,GAEV,MAAOrB,MAAKsB,OAAOc,QAAQf,SAS/B+F,aAAc,WACd,GADwB/F,GACxBH,UAAAC,OAAA,GAAAmC,SAAApC,UAAA,GAAAA,UAAA,GADgC,IAE5BG,GAAcA,GAASrB,KAAKqB,KAC5B,IAAII,GAAUzB,KAAKqH,cAAchG,GAAO,EACxC,OAAOiB,QAAOgF,KAAK7F,GAASM,IAAK,SAAA8C,GAAA,MAAQpD,GAAQoD,MAUrDwC,cAAe,WACf,GAAAE,GAAAvH,KADyBqB,EACzBH,UAAAC,OAAA,GAAAmC,SAAApC,UAAA,GAAAA,UAAA,GADiC,GAAIsG,EACrCtG,UAAAC,OAAA,GAAAmC,SAAApC,UAAA,IAAAA,UAAA,EACIG,GAAcA,GAASrB,KAAKqB,KAC5B,IAAII,GAAUzB,KAAKuB,YAAYkG,IAAIpG,GAASrB,KAAKqB,MACjD,KAAGmG,EAWC,MAAO/F,EAVX,IAAAiG,GAAA,WACI,GAAIpG,KAKJ,OAJAG,GAAQM,IAAK,SAAAyD,GAETlE,EAAOkE,GAAU+B,EAAK9F,QAAQgG,IAAIjC,EAAS,IAAMnE,MAErDsG,EAAOrG,KANX,sCAAAoG,GAAA,YAAAjF,EAAAiF,MAAAC,EAAA,QAcJd,kBAAmB,SAAUxF,GAEzB,GAAGrB,KAAK2G,IAAItF,GACZ,CACI,GAAII,GAAUzB,KAAKqH,cAAchG,GAAO,EACxC,KAAI,GAAImE,KAAU/D,GAEd,GAAGA,EAAQ+D,KAAYnE,EAEnB,MAAOmE,GAInB,MAAO,OAYXoC,UAAW,WAEP,MAAsB,KAAf5H,KAAKqB,OAQhBwG,gBAAiB,WAEb,QAAU7H,KAAKsE,YAQnB6B,SAAU,WAEN,QAAOnG,KAAKsE,YACNtE,KAAKsE,WAAWwD,QAS1BC,WAAY,WAER,MAAO/H,MAAKqB,QAAUrB,KAAKiB,OAALjB,UAY1BgI,MAAO,WAQH,MANGhI,MAAKsE,aAAetE,KAAKmG,aAExBnG,KAAKsE,WAAW0D,QAChBhI,KAAK0F,OAAO,aAAc,SAC1B1F,KAAK0F,OAAO,SAAU,SAAU,SAAS,IAEtC1F,MAQXiI,OAAQ,WAQJ,MANGjI,MAAKsE,YAActE,KAAKmG,aAEvBnG,KAAK0F,OAAO,aAAc,UAC1B1F,KAAK0F,OAAO,SAAU,SAAU,SAAS,GACzC1F,KAAKsE,WAAW2D,UAEbjI,MAQXkI,OAAQ,WAcJ,MAZGlI,MAAKsE,aAEDtE,KAAKmG,YAEJnG,KAAK0F,OAAO,SAAU,SAAU,SAAS,GAE7C1F,KAAKqB,MAAQrB,KAAKsE,WAAWQ,KAC7B9E,KAAKsE,WAAW6D,cACTnI,MAAKsE,WACZtE,KAAK0F,OAAO,aAAc,UAC1B1F,KAAK0F,OAAO,SAAU,SAAU,aAAc,OAE3C1F,MAQX4G,IAAK,WAmBD,MAjBG5G,MAAKsE,aAEDtE,KAAKmG,YAEJnG,KAAK0F,OAAO,SAAU,SAAU,SAAS,GAE7C1F,KAAKqB,MAAQrB,KAAKsE,WAAWU,GAC7BhF,KAAKsE,WAAW6D,cACTnI,MAAKsE,WACZtE,KAAK0F,OAAO,SAAU,SAAU,QAAS1F,KAAKqB,OAC9CrB,KAAK0F,OAAO,SAAU,SAAU,QAAS1F,KAAKqB,OAC3CrB,KAAK+H,cAEJ/H,KAAK0F,OAAO,SAAU,YAE1B1F,KAAK0F,OAAO,SAAU,SAAU,aAAc,OAE3C1F,MAQXoI,MAAM,WACN,GADe3D,GACfvD,UAAAC,OAAA,GAAAmC,SAAApC,UAAA,GAAAA,UAAA,GADyB,GAEjBG,EAAQoD,GAAWzE,KAAKiB,OAAOwD,OAmBnC,OAlBAzE,MAAK0F,OAAO,SAAU,SACnB1F,KAAKsE,aAEDtE,KAAKmG,YAEJnG,KAAK0F,OAAO,SAAU,SAAU,SAAS,GAE7C1F,KAAKsE,WAAW6D,cACTnI,MAAKsE,WACZtE,KAAK0F,OAAO,aAAc,UAC1B1F,KAAK0F,OAAO,SAAU,SAAU,aAAc,OAE/C1F,KAAKqB,QAAUA,IAEdrB,KAAKqB,MAAQA,EACbrB,KAAK0F,OAAO,SAAU,SAAU,QAAS1F,KAAKqB,OAC9CrB,KAAK0F,OAAO,SAAU,SAAU,QAAS1F,KAAKqB,QAE3CrB,MAeXiF,IAAK,SAAUO,EAAQV,EAAME,GAIzB,MAFAhF,MAAKyB,QAAQ4G,IAAI7C,EAAS,IAAMV,EAAME,GACtChF,KAAKuB,YAAY0D,IAAIH,EAAMU,GACpBxF,MAWXsI,OAAQ,SAAU9C,EAAQV,EAAME,GAG5B,MADAhF,MAAKsB,OAAOgH,OAAO9C,EAAQV,GACpB9E,MAgDXoF,GAAI,SAAU/E,EAAIkI,GAClB,GAAAC,GAAAxI,KAAAyI,GACqC,EAAAtE,EAAAC,OAAMpE,KAAMK,GADjDqI,EAAA5F,EAAA2F,EAAA,GACS9C,EADT+C,EAAA,GACoB9C,EADpB8C,EAAA,GAC0BC,EAD1BD,EAAA,EAwCI,OArCG1I,MAAKiB,OAAO6F,OAEXC,QAAQ6B,IAAI,oBAAsBvI,GAAKsF,EAAWC,GAAO+C,GAG7DA,EAAQ5G,IAAK,SAAA8G,GAsBT,GAnBc,MAAXA,IAEkB,UAAdlD,EAEI6C,EAAKlH,OAAOc,QAAQyG,SAEnBL,EAAKvH,OAAO6F,OAASC,QAAQE,KAAK,uEAAwErB,EAAMiD,GAGlG,WAAdlD,IAEA6C,EAAK/G,QAAQkF,IAAIkC,IAEjBL,EAAKvH,OAAO6F,OAASC,QAAQE,KAAK,yEAA0ErB,EAAMiD,OAM1H,EAAA3G,EAAA4G,YAAWP,GAEX,KAAM,IAAIQ,OAAM,mBAAoBpD,EAAW,IAAKC,EAAM,uCAAwC2C,EAItG,IAAIS,IAAO,EAAA7E,EAAAE,SAAQsB,EAAWC,EAAMiD,EACpCL,GAAK9G,SAASuH,OAAOD,EAAMT,KAGxBvI,MAGXkJ,IAAK,SAAU7I,EAAIkI,GACnB,GAAAY,GAAAnJ,KAAAoJ,GACqC,EAAAjF,EAAAC,OAAMpE,KAAMK,GADjDgJ,EAAAvG,EAAAsG,EAAA,GACSzD,EADT0D,EAAA,GACoBzD,EADpByD,EAAA,GAC0BV,EAD1BU,EAAA,EAEIV,GAAQ5G,IAAK,SAAA8G,GAET,GAAIG,IAAO,EAAA7E,EAAAE,SAAQsB,EAAWC,EAAMiD,EACpCM,GAAKzH,SAAS4G,OAAOU,EAAMT,MAInCvC,SAAU,SAASgD,EAAMhH,GAErBhC,KAAKiB,OAAO6F,OAASC,QAAQC,KAAK,8BAA+BgC,EACjE,IAAItH,GAAW1B,KAAK0B,SAAS+F,IAAIuB,EAC9BtH,IAGCA,EAASK,IAAI,SAAAwG,GAAA,MAAMA,GAAGvG,QFmEhC,SAASnC,EAAQD,EAASM,GAE/B,YG/zBc,SAASoJ,GAAUC,GAE9BvJ,KAAKuJ,KAAOA,MA0DhB,QAAShD,GAAO3F,EAAK0G,GAGjB,IADA,GAAIxF,UACEwF,EAAKnG,QAEPW,EAAMwF,EAAKkC,SACL,EAAAtH,EAAAuH,UAAS7I,EAAIkB,MAEflB,EAAIkB,OAERlB,EAAMA,EAAIkB,EAEd,OAAOlB,GAGJ,QAASyH,GAAIzH,EAAKoI,EAAMxG,GAC/B,GACQ8E,IADRpG,UAAAC,OAAA,GAAAmC,SAAApC,UAAA,GAAAA,UAAA,MACewI,OAAOV,GAAMW,MAAM,MAC1B7H,EAAOwF,EAAKsC,KAChBhJ,GAAM2F,EAAO3F,EAAK0G,GAClB1G,EAAIkB,GAAOU,EAGf,QAASyC,GAAIrE,EAAKoI,EAAMxG,GAEpB,GAAI8E,GAAOoC,OAAOV,GAAMW,MAAM,KAC1B7H,EAAOwF,EAAKsC,KAChBhJ,GAAM2F,EAAO3F,EAAK0G,IACZ,EAAApF,EAAA2B,SAAQjD,EAAIkB,MAEdlB,EAAIkB,OAERlB,EAAIkB,GAAKO,KAAKG,GAGlB,QAASyG,GAAOrI,EAAKoI,EAAMxG,GAEvB,GAAI8E,GAAOoC,OAAOV,GAAMW,MAAM,KAC1B7H,EAAOwF,EAAKsC,KAChBhJ,GAAM2F,EAAO3F,EAAK0G,IACZ,EAAApF,EAAA2B,SAAQjD,EAAIkB,MAEdlB,EAAIkB,MAER,IAAI+H,GAASjJ,EAAIkB,GACbgI,EAAQD,EAAOzH,QAAQI,EACxBsH,QAECD,EAAOxH,KAAKG,GAIZqH,EAAOC,GAAStH,EAIjB,QAASiF,GAAI7G,EAAKoI,GAErB,IAAG,EAAA9G,EAAA6H,aAAYf,IAAiB,IAARA,EAEpB,MAAOpI,EAKX,KAFA,GAAIkB,UACAwF,EAAOoC,OAAOV,GAAMW,MAAM,KACxBrC,EAAKnG,OAAS,GACpB,CAEI,GADAW,EAAMwF,EAAKkC,SACL5I,EAAIuE,eAAerD,GAErB,MAEJlB,GAAMA,EAAIkB,GAGd,MADAA,GAAMwF,EAAKkC,QACJ5I,EAAIkB,GAGR,QAAS6E,GAAI/F,EAAKoI,EAAMxG,GAE3B,GAAIqH,GAASpC,EAAI7G,EAAKoI,EACtB,WAAW,EAAA9G,EAAA2B,SAAQgG,KAAW,EAAA3H,EAAA8H,WAAUxH,GAClCqH,EAAOzH,QAAQI,SACf,EAAAN,EAAA6H,aAAYvH,IACR,EAAAN,EAAA8H,WAAUH,GACVA,IAAWrH,GAGlB,QAASJ,GAASxB,EAAKoI,EAAMxG,GAEhC,GAAIQ,GAAMyE,EAAI7G,EAAKoI,EACnB,QAAG,EAAA9G,EAAA2B,SAAQb,GAEAA,EAAIZ,QAAQI,MAKpB,QAAS8F,GAAO1H,EAAKoI,EAAMxG,GAE9B,GAAIqH,GAASjJ,EACT0G,EAAOoC,OAAOV,GAAQ,IAAIW,MAAM,KAChC7H,EAAMwF,EAAKsC,KAMf,IAJGtC,EAAKnG,SAEJ0I,EAASpC,EAAI7G,EAAK0G,EAAK2C,KAAK,QAE7B,EAAA/H,EAAA8H,WAAUxH,KAAU,EAAAN,EAAA2B,SAAQgG,EAAO/H,IACtC,CACI,GAAI+G,GAASgB,EAAO/H,GAChBgI,EAAQjB,EAAOzG,QAAQI,EAC3B,OAAGsH,QAECjB,EAAOqB,OAAOJ,EAAO,GACA,IAAlBjB,EAAO1H,cAEC0I,GAAO/H,IAEX,GAMX,UAAG,EAAAI,EAAAuH,UAASI,KAAWjJ,EAAIuE,eAAerD,YAE/B+H,GAAO/H,IACP,GAMZ,QAASqI,GAAOvJ,EAAKoI,GAExB,GAAImB,MACAtB,EAASpB,EAAI7G,EAAKoI,EACtB,KAAG,EAAA9G,EAAAuH,UAASZ,GAER,IAAI,GAAIhE,KAAQgE,GAETA,EAAO1D,eAAeN,IAErBsF,EAAO9H,KAAKwG,EAAOhE,GAI/B,OAAOsF,GHinBV7H,OAAOC,eAAe3C,EAAS,cAC3B4C,OAAO,IAEX5C,EAAQuK,OAASvK,EAAQ0I,OAAS1I,EAAQwC,QAAUxC,EAAQ+G,IAAM/G,EAAQ6H,IAAM7H,EAAQyI,IAAM/E,OAC9F1D,aGr0BuB0J,CAPxB,IAAApH,GAAAhC,EAAA,EAYAoJ,GAASzG,WAEL0G,KAAM,KAENlB,IAAK,SAAUW,EAAMxG,GAGjB,MADA6F,GAAIrI,KAAKuJ,KAAMP,EAAMxG,GACdxC,MAGXiF,IAAI,SAAS+D,EAAMxG,GAGf,MADAyC,GAAIjF,KAAKuJ,KAAMP,EAAMxG,GACdxC,MAGXiJ,OAAO,SAASD,EAAMxG,GAGlB,MADAyG,GAAOjJ,KAAKuJ,KAAMP,EAAMxG,GACjBxC,MAGXyH,IAAI,SAASuB,GAET,MAAOvB,GAAIzH,KAAKuJ,KAAMP,IAG1BrC,IAAK,SAAUqC,GACf,GADqBxG,GACrBtB,UAAAC,OAAA,GAAAmC,SAAApC,UAAA,GAAAA,UAAA,GAD6BoC,MAEzB,OAAOqD,GAAI3G,KAAKuJ,KAAMP,EAAMxG,IAGhCJ,QAAS,SAAU4G,EAAMxG,GAErB,MAAOJ,GAAQpC,KAAKuJ,KAAMP,EAAMxG,IAGpC8F,OAAQ,SAAUU,GAClB,GADwBxG,GACxBtB,UAAAC,OAAA,GAAAmC,SAAApC,UAAA,GAAAA,UAAA,GADgCoC,MAG5B,OADAgF,GAAOtI,KAAKuJ,KAAMP,EAAMxG,GACjBxC,MAGXsH,KAAK,SAAS0B,GAEV,MAAO1G,QAAOgF,KAAKG,EAAIzH,KAAKuJ,KAAMP,KAGtCmB,OAAO,SAASnB,GAEZ,MAAOmB,GAAOnK,KAAKuJ,KAAMP,KHi2BhCpJ,EAAQyI,IAAM+B,EA6CdxK,EAAQ6H,IAAM4C,EAMdzK,EAAQ+G,IAAM2D,EASd1K,EAAQwC,QAAUmI,EA6BlB3K,EAAQ0I,OAASkC,EAajB5K,EAAQuK,OAASM,GAIZ,SAAS5K,EAAQD,GAEtB,YI3gCM,SAAS6J,GAAUjH,GAEtB,MAAiD,oBAA1CF,OAAOO,UAAU6H,SAASnK,KAAKiC,GAGnC,QAASqB,GAASrB,GAErB,MAAOA,aAAiBoB,OAGrB,QAASzB,GAAUK,GAEtB,MAAwB,gBAAVA,GAGX,QAASsG,GAAWtG,GAEvB,MAAOA,aAAiBmI,UAGrB,QAASX,GAAWxH,GAEvB,MAAwB,mBAAVA,GAGX,QAASuH,GAAavH,GAEzB,MAAwB,mBAAVA,GAGX,QAASoI,GAAMpI,GAElB,MAAOkH,QAAOlH,GAAS,IAAIqI,QAAQ,aAAc,IJ6+BpDvI,OAAOC,eAAe3C,EAAS,cAC3B4C,OAAO,IAEX5C,EIhhCe6J,WJihCf7J,EI5gCeiE,UJ6gCfjE,EIxgCeuC,WJygCfvC,EIpgCekJ,aJqgCflJ,EIhgCeoK,YJigCfpK,EI5/BemK,cJ6/BfnK,EIx/BegL,QJuhCV,SAAS/K,EAAQD,EAASM,GAE/B,YKtgCD,SAAS4K,GAAYjJ,EAAK2D,EAAQV,EAAME,GAEpChF,KAAK6B,IAAaA,EAClB7B,KAAKwF,OAAaA,EAClBxF,KAAK8E,KAAaA,EAClB9E,KAAKgF,GAAaA,EAClBhF,KAAKmI,QLkgCR7F,OAAOC,eAAe3C,EAAS,cAC3B4C,OAAO,GAGX,IAAIM,GAAiB,WAAc,QAASC,GAAcC,EAAKC,GAAK,GAAIC,MAAeC,GAAK,EAAUC,GAAK,EAAWC,EAAKC,MAAW,KAAM,IAAK,GAAiCC,GAA7BC,EAAKR,EAAIN,OAAOC,cAAmBQ,GAAMI,EAAKC,EAAGC,QAAQC,QAAoBR,EAAKb,KAAKkB,EAAGf,QAAYS,GAAKC,EAAK/B,SAAW8B,GAA3DE,GAAK,IAAoE,MAAOQ,GAAOP,GAAK,EAAMC,EAAKM,EAAO,QAAU,KAAWR,GAAMK,EAAG,WAAWA,EAAG,YAAe,QAAU,GAAIJ,EAAI,KAAMC,IAAQ,MAAOH,GAAQ,MAAO,UAAUF,EAAKC,GAAK,GAAIW,MAAMC,QAAQb,GAAQ,MAAOA,EAAY,IAAIN,OAAOC,WAAYL,QAAOU,GAAQ,MAAOD,GAAcC,EAAKC,EAAa,MAAM,IAAIa,WAAU,4DK7jCvlBI,EAAAhE,EAAA,GACAgC,EAAAhC,EAAA,EAgEA4K,GAAWjI,WAEPhB,IAAc,KACd2D,OAAc,GACdV,KAAc,GACdE,GAAc,GACd8C,QAAc,EACdpG,SAAc,KAEdyG,MAAO,WAEHnI,KAAK8H,QAAS,EACd9H,KAAK0B,aAOZ8E,KAAM,WAEF,IAAMxG,KAAK8H,OAEJ,GAAG9H,KAAK0B,SAASP,OACjB,CACI,GAAI4J,GAAU/K,KAAK0B,SAAS8H,QACxBnI,EAAQ0J,GACZ,IAAG1J,KAAU,EAET,MAAOrB,MAAK6B,IAAIqG,QAEpB,IAAG7G,KAAU,EAET,MAAOrB,MAAK6B,IAAImG,OAEpBhI,MAAKwG,WAILxG,MAAK6B,IAAI+E,KAGjB,OAAO5G,OAGXgI,MAAO,WAGH,MADAhI,MAAK8H,QAAS,EACP9H,MAGXiI,OAAQ,WAGJ,MADAjI,MAAK8H,QAAS,EACP9H,KAAKwG,SLwjCnB5G,cKpiCG2G,OAAO,SAAU1E,EAAK2D,EAAQwF,GAG1B,GAAIhK,GAAUa,EAAIb,MACd8D,EAAUjD,EAAIR,MACd2D,EAAUnD,EAAIJ,QAAQgG,IAAIjC,GAAQV,GAClCmG,GAAWzF,SAAQR,KAAIF,OAG3B,KAAG,EAAA5C,EAAA4G,YAAW9D,KAEVA,EAAKA,EAAGkG,MAAMlK,EAAOgK,GAClBnJ,EAAIP,OAAOc,QAAQ4C,SAElB,KAAM,IAAI+D,OAAM,uBAAwB/D,EAAI,IAKpD,IAAImG,MACA7G,EAAc,GAAIwG,GAAWjJ,EAAK2D,EAAQV,EAAME,EAmCpD,OAhCAnD,GAAIZ,OAAOwE,MAAM1D,IAAK,SAAAiH,GAGlBA,EAAOA,EAAK6B,QAAQ,WAAY,SAACO,EAAKC,GAAN,MAAgBJ,GAAKI,IACrD,IAAI3J,GAAWG,EAAIH,SAAS+F,IAAIuB,EAG7BtH,KACH,cAAA4J,GACoCtC,EAAKW,MAAM,KAD/C4B,EAAAzI,EAAAwI,EAAA,GACS3F,EADT4F,EAAA,GACoB1C,EADpB0C,EAAA,GAC4B3F,EAD5B2F,EAAA,EAEI7J,GAAWA,EAASK,IAAK,SAAAgJ,GAGrB,GAAIS,GAAsB,UAAd7F,EAAAzB,EAAAuH,WAAAvH,EAAAwH,YACR1J,EAAQ,GAAIwJ,GAAM5F,EAAMiD,EAAQvE,EAKpC,OAAO,YAEH,MAAOyG,GAAQG,MAAMlK,GAAQgB,EAAOH,GAAK8J,OAAOX,OAKxDG,EAAQA,EAAMQ,OAAOjK,QAK7B4C,EAAW5C,SAAWyJ,EACf7G,GAGXoC,MAAO,SAAS7E,EAAKR,GAEjB,GAAIiD,GAAa,GAAIwG,GAAWjJ,EAAK,GAAIA,EAAIR,MAAOA,EAEpD,OADAiD,GAAWwD,SAASjG,EAAIyC,YAAazC,EAAIyC,WAAWwD,OAC7CxD,KL6jCT,SAASzE,EAAQD,GAEtB,YMtvCG,SAAS+B,GAAYK,EAAO2D,EAAWC,EAAMiD,EAAQvE,GAEjDtC,EAAM2D,UAAgBA,EACtB3D,EAAM4D,KAAgBA,EACtB5D,EAAM6G,OAAgBA,EACtB7G,EAAMsC,WAAgBA,EAOnB,QAASoH,GAAa9F,EAAMiD,EAAQvE,GAEvC3C,EAAW3B,KAAM,SAAU4F,EAAMiD,EAAQvE,GAQtC,QAASmH,GAAY7F,EAAMiD,EAAQvE,GAEtC3C,EAAW3B,KAAM,QAAS4F,EAAMiD,EAAQvE,GAQrC,QAASwB,GAAaF,EAAM9D,EAAKU,GAEpCxC,KAAK4F,KAASA,EACd5F,KAAK8B,IAASA,EACd9B,KAAKwC,MAASA,EAeX,QAASuD,GAAiBH,GAE7B5F,KAAK4F,KAAOA,ENmsCnBtD,OAAOC,eAAe3C,EAAS,cAC3B4C,OAAO,IAEX5C,EM/uCmB8L,cNgvCnB9L,EMtuCmB6L,aNuuCnB7L,EM7tCmBkG,cN8tCnBlG,EM3sCmBmG,iBA5DhB,IAAI/D,IAGA2D,UAAc,KACdC,KAAc,KACdiD,OAAc,KACdvE,WAAsB,KAmB1BoH,GAAY7I,UAAYb,EAUxByJ,EAAW5I,UAAYb,EAavB8D,EAAYjD,WAER8C,UAAc,SACdC,KAAc,GACd9D,IAAc,GACdU,MAAc,MAYlBuD,EAAgBlD,WAEZ8C,UAAc,aACdC,KAAc,KN0wChB,SAAS/F,EAAQD,GAEtB,YOxzCM,SAASwE,GAAMvC,EAAKxB,GAUvB,QAASuL,GAAQpJ,GACb,MAAOX,GAAIP,OAAOc,QAAQI,QAG9B,QAASqJ,GAASrJ,GACd,MAAOX,GAAIJ,QAAQkF,IAAInE,GAG3B,QAASsJ,GAAWtJ,GAChB,MAAOA,GAAQA,EAAMmC,MAAM,cAAgB,KAG/C,QAASoH,GAAevJ,GAGjB,qCAAqCwJ,KAAKxJ,GAEzCmD,EAAYnD,EAIRA,IAASyJ,GAAOC,YAEpBvG,EAAYsG,EAAOC,WAAW1J,GAC9BoD,EAAOpD,GAIFoJ,EAAQpJ,IAAUqJ,EAASrJ,IAE5BmD,IAEAA,EAAYiG,EAAQpJ,GACd,QACA,UAIO,UAAdmD,GAAyBkG,EAASrJ,KAEjCoD,EAAOpD,GAGPmG,IAEAA,EAAUmD,EAAWtJ,KAKrB,kBAAkBwJ,KAAKxJ,KAE3BoD,EAAOpD,GA3Df,GAAI8C,GAAWzD,EAAIZ,OAAOqE,SACtB6G,SACAxG,SACAC,SACA+C,QAqHJ,OAzDAwD,GAAc9L,EAAGsE,MAAM,gCAGvBwH,EAASC,QAAQ,SAAUC,EAASpJ,EAAGkJ,GAGnC,GAAIG,GAAUD,EAAQ,GAClBlC,EAAUkC,EAAQ1H,MAAM,QACxBnC,EAAU2H,EAAO,EACrB,QAAOmC,GAGH,IAAK,IACD3G,EAAcsG,EAAOzH,OAAOhC,GAC5BoD,EAAcpD,CACd,MAGJ,KAAK,IACDmD,EAAc,QACdC,EAAcpD,CACd,MAGJ,KAAK,IACDmG,EAAUwB,EACVxE,EAAYiG,EAAQzB,EAAO,IAAM,QAAU,QAC3C,MAGJ,KAAK,IACD4B,EAAevJ,EACf,MAGJ,SACIuJ,EAAeM,MAKvB1D,IAEAA,EAAUmD,KAGVnG,IAEAA,EAAYiG,EAAQjD,EAAQ,IAAM,QAAU,UAG5C/C,IAEAA,EAAON,EAASK,KAIZA,EAAWC,EAAM+C,GAatB,QAAStE,GAAQsB,EAAWC,EAAMiD,GAErC,MAAqB,WAAdlD,GAAwC,UAAdA,GAC1BA,EAAWkD,EAAQjD,GAAMqE,KAAK,KAC/BtE,EAAY,IAAMC,EP6qC3BtD,OAAOC,eAAe3C,EAAS,cAC3B4C,OAAO,IAEX5C,EO7zCewE,QP8zCfxE,EOrrCeyE,SA1KhB,IAAI4H,IAEAC,YAEIK,MAAS,SACTC,OAAS,SACT9G,OAAS,SACT+G,SAAS,SACTrE,MAAS,SACTnD,IAAS,SACTqD,OAAS,SAETN,MAAS,aACTC,OAAS,aACTC,OAAS,cAGb1D,QAEI+H,MAAS,SACT3F,IAAS,SACT8F,MAAS,QACTC,MAAS","file":"state-machine.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StateMachine\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StateMachine\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.default = StateMachine;\n\t\n\tvar _ValueMap = __webpack_require__(1);\n\t\n\tvar _ValueMap2 = _interopRequireDefault(_ValueMap);\n\t\n\tvar _Transition = __webpack_require__(3);\n\t\n\tvar _Transition2 = _interopRequireDefault(_Transition);\n\t\n\tvar _Events = __webpack_require__(4);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _handlers = __webpack_require__(5);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction StateMachine(scope, config) {\n\t    // parameters\n\t    if (arguments.length == 1) {\n\t        var _ref = [scope, null];\n\t        config = _ref[0];\n\t        scope = _ref[1];\n\t    }\n\t\n\t    // assignment\n\t    this.scope = scope;\n\t    this.state = '';\n\t    this.states = [];\n\t    this.transitions = new _ValueMap2.default();\n\t    this.actions = new _ValueMap2.default();\n\t    this.handlers = new _ValueMap2.default();\n\t\n\t    // initialize\n\t    if (config) {\n\t        this.initialize(config);\n\t    }\n\t}\n\t\n\tStateMachine.parse = _handlers.parse;\n\tStateMachine.getPath = _handlers.getPath;\n\t\n\t/**\n\t * StateMachine prototype\n\t *\n\t * The property examples below illustrate a 4-state machine, with states:\n\t *\n\t * - intro > settings > summary > end\n\t *\n\t * And actions:\n\t *\n\t * - back | next | restart | finish\n\t */\n\tStateMachine.prototype = {\n\t    // ------------------------------------------------------------------------------------------------\n\t    // properties\n\t\n\t    /**\n\t     * Available state names\n\t     *\n\t     * - [\n\t     *     intro,\n\t     *     settings,\n\t     *     summary,\n\t     *     final\n\t     *   ]\n\t     *\n\t     * @var {string[]}\n\t     */\n\t    states: null,\n\t\n\t    /**\n\t     * Available transitions for each action\n\t     *\n\t     * action.from => to\n\t     *\n\t     * - next: {\n\t     *     intro: settings,\n\t     *     settings: summary\n\t     *   },\n\t     * - back: {\n\t     *     settings: intro\n\t     *   },\n\t     * - restart: {\n\t     *     summary:intro\n\t     *   },\n\t     * - finish: {\n\t     *     summary:final\n\t     *   },\n\t     *\n\t     * Transitions can also be functions\n\t     *\n\t     * - next: {\n\t     *     intro: function() { return '<random state>' } // jump to a random state\n\t     *   }\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    transitions: null,\n\t\n\t    /**\n\t     * Actions that are available to be called from each state\n\t     *\n\t     * state => [ action, action, ... ]\n\t     *\n\t     * - intro: [\n\t     *     'next'\n\t     *   ],\n\t     * - settings: [\n\t     *     'next',\n\t     *     'back'\n\t     *   ],\n\t     * - summary: [\n\t     *     'restart'\n\t     *     'finish',\n\t     *   ]\n\t     *\n\t     * Actions can also be expressed as wildcards\n\t     *\n\t     * - intro: [\n\t     *     '*' // any action is allowed from intro\n\t     *   ]\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    actions: null,\n\t\n\t    /**\n\t     * Handler functions that should be called on each action event / state change\n\t     *\n\t     * name.type => [ handler, handler, ... ]\n\t     *\n\t     * - next: {\n\t     *   - start: [\n\t     *       hideModal\n\t     *     ],\n\t     *   - end: [\n\t     *       showModal\n\t     *     ]\n\t     *   },\n\t     * - summary: {\n\t     *   - enter: [\n\t     *       resetForm\n\t     *     ],\n\t     *   - leave: [\n\t     *       validateForm,\n\t     *       postData,\n\t     *     ]\n\t     *   },\n\t     *   ...\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    handlers: null,\n\t\n\t    /**\n\t     * The current state\n\t     *\n\t     * @var {string}\n\t     */\n\t    state: '',\n\t\n\t    /**\n\t     * Any active Transition object that is driving the state change\n\t     *\n\t     * @var {Transition}\n\t     */\n\t    transition: null,\n\t\n\t    /**\n\t     * The scope in which to call all handlers\n\t     *\n\t     * @var {*}\n\t     */\n\t    scope: null,\n\t\n\t    /**\n\t     * The original config object\n\t     *\n\t     * @var {Object}\n\t     */\n\t    config: null,\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // private methods\n\t\n\t    /**\n\t     * Initialize the FSM with a config object\n\t     *\n\t     * @private\n\t     * @param config\n\t     */\n\t    initialize: function initialize(config) {\n\t        var _this = this;\n\t\n\t        // assign config\n\t        this.config = config;\n\t\n\t        // scope\n\t        if (config.scope) {\n\t            this.scope = config.scope;\n\t        }\n\t\n\t        // pre-collate all states\n\t        addStates(this, 'from', config.events);\n\t        addStates(this, 'to', config.events);\n\t\n\t        // initial state\n\t        if (!config.initial) {\n\t            config.initial = this.states[0];\n\t        }\n\t\n\t        // add transitions\n\t        config.events.map(function (event) {\n\t            // shorthand\n\t            if ((0, _utils.isString)(event)) {\n\t                var matches = event.match(/(\\w+)\\s*[\\|:=]\\s*(\\w+)\\s*([<>-])\\s*(\\w.*)/);\n\t\n\t                var _matches = _slicedToArray(matches, 5);\n\t\n\t                var name = _matches[1];\n\t                var from = _matches[2];\n\t                var op = _matches[3];\n\t                var to = _matches[4];\n\t\n\t                if (op === '-') {\n\t                    _this.add(name, from, to);\n\t                    _this.add(name, to, from);\n\t                    return;\n\t                }\n\t                if (op === '<') {\n\t                    var _ref2 = [to, from];\n\t                    from = _ref2[0];\n\t                    to = _ref2[1];\n\t                }\n\t                _this.add(name, from, to);\n\t            }\n\t\n\t            // keys\n\t            else {\n\t                    _this.add(event.name, event.from, event.to);\n\t                }\n\t        });\n\t\n\t        // add handlers\n\t        for (var name in config.handlers) {\n\t            if (config.handlers.hasOwnProperty(name)) {\n\t                this.on(name, config.handlers[name]);\n\t            }\n\t        }\n\t\n\t        // start automatically unless defer is set to true\n\t        if (!config.defer) {\n\t            this.state = config.initial;\n\t        }\n\t\n\t        /**\n\t         * Sets defaults for various declarations\n\t         *\n\t         * @type {Object}\n\t         */\n\t        config.defaults = Object.assign({\n\t\n\t            // initialize event\n\t            initialize: 'initialize',\n\t\n\t            // handler defaults\n\t            action: 'start',\n\t            state: 'enter'\n\t\n\t        }, config.defaults);\n\t\n\t        /**\n\t         * Sets the default order to run transition callbacks in\n\t         *\n\t         * @type {string[]} type.target\n\t         */\n\t        config.order = config.order || ['action.*.start', 'action.{action}.start', 'state.{*}.{action}', 'state.{from}.{action}', 'state.{from}.leave', 'state.*.leave', 'state.*.enter', 'state.{to}.enter',\n\t        //'state.{to}.{action}',\n\t        'action.{action}.end', 'action.*.end'];\n\t    },\n\t\n\t    /**\n\t     * Dispatch an event\n\t     *\n\t     * @param   {string}    namespace\n\t     * @param   {string}    type\n\t     * @param   {string}    key\n\t     * @param   {*}         value\n\t     * @returns {StateMachine}\n\t     */\n\t    update: function update(namespace, type) {\n\t        var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\t        var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\t\n\t        var signature = namespace + '.' + type;\n\t        var event = namespace === 'system' ? new _Events.SystemEvent(type, key, value) : new _Events.TransitionEvent(type);\n\t        this.dispatch(signature, event);\n\t        return this;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // api\n\t\n\t    /**\n\t     * Attempt to run an action, resulting in a transition to a state\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {*[]}       rest\n\t     * @returns {boolean}\n\t     */\n\t    do: function _do(action) {\n\t        if (this.can(action) && !this.isPaused()) {\n\t            for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                rest[_key - 1] = arguments[_key];\n\t            }\n\t\n\t            this.transition = _Transition2.default.create(this, action, rest);\n\t            if (action === this.config.defaults.initialize) {\n\t                this.update('system', 'initialize');\n\t            }\n\t            this.update('system', 'update', 'transition', this.transition);\n\t            this.transition.exec();\n\t            return true;\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Attempt to go to a state\n\t     *\n\t     * Finds if an appropriate transition exists, then calls the related action if it does\n\t     *\n\t     * @param   {string}    state\n\t     * @param   {boolean}   [force]\n\t     * @returns {boolean}\n\t     */\n\t    go: function go(state) {\n\t        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        if (this.has(state)) {\n\t            if (force) {\n\t                this.transition = _Transition2.default.force(this, state);\n\t                return this.end();\n\t            }\n\t            var action = this.getActionForState(state);\n\t            if (action) {\n\t                return this.do(action);\n\t            }\n\t            this.config.debug && console.info('No transition exists from \"%s\" to \"%s\"', this.state, state);\n\t        } else {\n\t            this.config.debug && console.warn('No such state \"%s\"', state);\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Query a transition to see if a named action is available\n\t     *\n\t     * @param   {string}    action\n\t     * @returns {boolean}\n\t     */\n\t    can: function can(action) {\n\t        if (!this.actions.has(action)) {\n\t            this.config.debug && console.warn('No such action \"%s\"', action);\n\t        }\n\t        return !!this.transitions.has(this.state, action);\n\t    },\n\t\n\t    /**\n\t     * Query a transition to see if a named action is unavailable\n\t     *\n\t     * @param   {string}    action\n\t     * @returns {boolean}\n\t     */\n\t    cannot: function cannot(action) {\n\t        return !this.can(action);\n\t    },\n\t\n\t    /**\n\t     * Test if the current state is the same as the supplied one\n\t     *\n\t     * @param   {string}    state       A state name to compare against the current state\n\t     * @returns {boolean}\n\t     */\n\t    is: function is(state) {\n\t        if (this.states.indexOf(state) === -1) {\n\t            this.config.debug && console.warn('No such state \"%s\"', state);\n\t        }\n\t        return state === this.state;\n\t    },\n\t\n\t    /**\n\t     * Test if a state exists\n\t     *\n\t     * @param   {string}    state\n\t     * @return  {boolean}\n\t     */\n\t    has: function has(state) {\n\t        return this.states.indexOf(state) !== -1;\n\t    },\n\t\n\t    /**\n\t     * Get the available \"to\" states for the current or supplied state\n\t     *\n\t     * @param   {string}    [state]     Optional name of a state to get states for. Defaults to the current state\n\t     * @returns {string[]}              An array of string states\n\t     */\n\t    getStatesFor: function getStatesFor() {\n\t        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\n\t        state = state || this.state;\n\t        var actions = this.getActionsFor(state, true);\n\t        return Object.keys(actions).map(function (name) {\n\t            return actions[name];\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Get the available actions (or actions and states) for the current or supplied state\n\t     *\n\t     * @param   {string}    [state]     Optional name of a state to get actions for. Defaults to the current state\n\t     * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n\t     * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n\t     */\n\t    getActionsFor: function getActionsFor() {\n\t        var _this2 = this;\n\t\n\t        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t        var asMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        state = state || this.state;\n\t        var actions = this.transitions.get(state || this.state);\n\t        if (asMap) {\n\t            var _ret = function () {\n\t                var states = {};\n\t                actions.map(function (action) {\n\t                    states[action] = _this2.actions.get(action + '.' + state);\n\t                });\n\t                return {\n\t                    v: states\n\t                };\n\t            }();\n\t\n\t            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t        } else {\n\t            return actions;\n\t        }\n\t    },\n\t\n\t    getActionForState: function getActionForState(state) {\n\t        if (this.has(state)) {\n\t            var actions = this.getActionsFor(state, true);\n\t            for (var action in actions) {\n\t                if (actions[action] === state) {\n\t                    return action;\n\t                }\n\t            }\n\t        }\n\t        return null;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // flags\n\t\n\t    /**\n\t     * Test if the FSM has started\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isStarted: function isStarted() {\n\t        return this.state !== '';\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is transitioning\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isTransitioning: function isTransitioning() {\n\t        return !!this.transition;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is paused (whilst transitioning)\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isPaused: function isPaused() {\n\t        return this.transition ? this.transition.paused : false;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is on the \"final\" state\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isComplete: function isComplete() {\n\t        return this.state === this.config.final;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // transitions\n\t\n\t    /**\n\t     * Pause any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    pause: function pause() {\n\t        if (this.transition && !this.isPaused()) {\n\t            this.transition.pause();\n\t            this.update('transition', 'pause');\n\t            this.update('system', 'update', 'pause', true);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Resume any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    resume: function resume() {\n\t        if (this.transition && this.isPaused()) {\n\t            this.update('transition', 'resume');\n\t            this.update('system', 'update', 'pause', false);\n\t            this.transition.resume();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Cancel any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    cancel: function cancel() {\n\t        if (this.transition) {\n\t            if (this.isPaused()) {\n\t                this.update('system', 'update', 'pause', false);\n\t            }\n\t            this.state = this.transition.from;\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('transition', 'cancel');\n\t            this.update('system', 'update', 'transition', null);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * End any current transition, skipping remaining handlers\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    end: function end() {\n\t        if (this.transition) {\n\t            if (this.isPaused()) {\n\t                this.update('system', 'update', 'pause', false);\n\t            }\n\t            this.state = this.transition.to;\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('system', 'change', 'state', this.state);\n\t            this.update('system', 'update', 'state', this.state);\n\t            if (this.isComplete()) {\n\t                this.update('system', 'complete');\n\t            }\n\t            this.update('system', 'update', 'transition', null);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Reset the FSM to the initial, or supplied, state\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    reset: function reset() {\n\t        var initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t\n\t        var state = initial || this.config.initial;\n\t        this.update('system', 'reset');\n\t        if (this.transition) {\n\t            if (this.isPaused()) {\n\t                this.update('system', 'update', 'pause', false);\n\t            }\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('transition', 'cancel');\n\t            this.update('system', 'update', 'transition', null);\n\t        }\n\t        if (this.state !== state) {\n\t            this.state = state;\n\t            this.update('system', 'change', 'state', this.state);\n\t            this.update('system', 'update', 'state', this.state);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // actions\n\t\n\t    /**\n\t     * Add a transition\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @return  {StateMachine}\n\t     */\n\t    add: function add(action, from, to) {\n\t        this.actions.set(action + '.' + from, to);\n\t        this.transitions.add(from, action);\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Remove a transition\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @return  {StateMachine}\n\t     */\n\t    remove: function remove(action, from, to) {\n\t        this.states.remove(action, from);\n\t        return this;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // handlers\n\t\n\t    /**\n\t     * Add an event handler\n\t     *\n\t     * Event handler signature:\n\t     *\n\t     * - namespace.type:target1 target2 target3 ...\n\t     *\n\t     * Valid event namespaces / types:\n\t     *\n\t     * - system.(change|update|complete|reset)\n\t     * - action.(start|end)\n\t     * - state.(add|remove|leave|enter)\n\t     * - transition.(pause|resume|cancel)\n\t     *\n\t     * As event types are unique, they can be used without the namespace:\n\t     *\n\t     * - change\n\t     * - pause\n\t     * - start\n\t     * - end\n\t     * - leave:red\n\t     * - enter:blue green\n\t     * - start:next\n\t     * - end:back\n\t     *\n\t     * You can also just pass action or names to target individual state.leave / action.end events:\n\t     *\n\t     * - next\n\t     * - intro\n\t     *\n\t     * Finally, you can target a state with an action:\n\t     *\n\t     * - state@action\n\t     * - intro@next\n\t     * - form@submit\n\t     * - form@leave (built-in state/action)\n\t     *\n\t     * @param id\n\t     * @param fn\n\t     * @return {StateMachine}\n\t     */\n\t    on: function on(id, fn) {\n\t        var _this3 = this;\n\t\n\t        var _parse = (0, _handlers.parse)(this, id);\n\t\n\t        var _parse2 = _slicedToArray(_parse, 3);\n\t\n\t        var namespace = _parse2[0];\n\t        var type = _parse2[1];\n\t        var targets = _parse2[2];\n\t\n\t\n\t        if (this.config.debug) {\n\t            console.log('StateMachine on: ' + id, [namespace, type], targets);\n\t        }\n\t\n\t        targets.map(function (target) {\n\t            // warn for invalid actions / states\n\t            if (target !== '*') {\n\t                if (namespace === 'state') {\n\t                    if (_this3.states.indexOf(target) === -1) {\n\t                        _this3.config.debug && console.warn('StateMachine: Warning assigning state.%s handler; no such state \"%s\"', type, target);\n\t                    }\n\t                } else if (namespace === 'action') {\n\t                    if (!_this3.actions.has(target)) {\n\t                        _this3.config.debug && console.warn('StateMachine: Warning assigning action.%s handler; no such action \"%s\"', type, target);\n\t                    }\n\t                }\n\t            }\n\t\n\t            // check handler is a function\n\t            if (!(0, _utils.isFunction)(fn)) {\n\t                throw new Error('Error assigning ' + namespace + '.' + type + ' handler; callback is not a Function', fn);\n\t            }\n\t\n\t            // assign\n\t            var path = (0, _handlers.getPath)(namespace, type, target);\n\t            _this3.handlers.insert(path, fn);\n\t        });\n\t\n\t        return this;\n\t    },\n\t\n\t    off: function off(id, fn) {\n\t        var _this4 = this;\n\t\n\t        var _parse3 = (0, _handlers.parse)(this, id);\n\t\n\t        var _parse4 = _slicedToArray(_parse3, 3);\n\t\n\t        var namespace = _parse4[0];\n\t        var type = _parse4[1];\n\t        var targets = _parse4[2];\n\t\n\t        targets.map(function (target) {\n\t            var path = (0, _handlers.getPath)(namespace, type, target);\n\t            _this4.handlers.remove(path, fn);\n\t        });\n\t    },\n\t\n\t    dispatch: function dispatch(path, event) {\n\t        this.config.debug && console.info('StateMachine: dispatch \"%s\"', path);\n\t        var handlers = this.handlers.get(path);\n\t        if (handlers) {\n\t            // do we need to pass additional arguments?\n\t            handlers.map(function (fn) {\n\t                return fn(event);\n\t            });\n\t        }\n\t    }\n\t\n\t};\n\t\n\t/**\n\t * Parses config and adds unique state names to states array\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          key\n\t * @param {Object[]}        transitions\n\t */\n\tfunction addStates(fsm, key, transitions) {\n\t    transitions.map(function (event) {\n\t        return addState(fsm, event[key]);\n\t    });\n\t}\n\t\n\tfunction addState(fsm, state) {\n\t    if ((0, _utils.isString)(state) && fsm.states.indexOf(state) === -1) {\n\t        fsm.states.push(state);\n\t    }\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.values = exports.remove = exports.indexOf = exports.has = exports.get = exports.set = undefined;\n\texports.default = ValueMap;\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\t/**\n\t * Utility class to create, modify and delete nested hashes and values\n\t *\n\t * @constructor\n\t */\n\tfunction ValueMap(data) {\n\t    this.data = data || {};\n\t}\n\t\n\tValueMap.prototype = {\n\t    data: null,\n\t\n\t    set: function set(path, value) {\n\t        _set(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    add: function add(path, value) {\n\t        _add(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    insert: function insert(path, value) {\n\t        _insert(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    get: function get(path) {\n\t        return _get(this.data, path);\n\t    },\n\t\n\t    has: function has(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        return _has(this.data, path, value);\n\t    },\n\t\n\t    indexOf: function indexOf(path, value) {\n\t        return _indexOf(this.data, path, value);\n\t    },\n\t\n\t    remove: function remove(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        _remove(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    keys: function keys(path) {\n\t        return Object.keys(_get(this.data, path));\n\t    },\n\t\n\t    values: function values(path) {\n\t        return _values(this.data, path);\n\t    }\n\t\n\t};\n\t\n\tfunction create(obj, keys) {\n\t    var key = void 0;\n\t    while (keys.length) {\n\t        key = keys.shift();\n\t        if (!(0, _utils.isObject)(obj[key])) {\n\t            obj[key] = {};\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    return obj;\n\t}\n\t\n\tfunction _set(obj, path, value) {\n\t    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n\t\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    obj[key] = value;\n\t}\n\t\n\texports.set = _set;\n\tfunction _add(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    obj[key].push(value);\n\t}\n\t\n\tfunction _insert(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    var parent = obj[key],\n\t        index = parent.indexOf(value);\n\t    if (index === -1) {\n\t        parent.push(value);\n\t    } else {\n\t        parent[index] = value;\n\t    }\n\t}\n\t\n\tfunction _get(obj, path) {\n\t    if ((0, _utils.isUndefined)(path) || path == '') {\n\t        return obj;\n\t    }\n\t\n\t    var key = void 0,\n\t        keys = String(path).split('.');\n\t    while (keys.length > 1) {\n\t        key = keys.shift();\n\t        if (!obj.hasOwnProperty(key)) {\n\t            return;\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    key = keys.shift();\n\t    return obj[key];\n\t}\n\t\n\texports.get = _get;\n\tfunction _has(obj, path, value) {\n\t    var parent = _get(obj, path);\n\t    return !!((0, _utils.isArray)(parent) && (0, _utils.isDefined)(value) ? parent.indexOf(value) !== -1 : (0, _utils.isUndefined)(value) ? (0, _utils.isDefined)(parent) : parent === value);\n\t}\n\t\n\texports.has = _has;\n\tfunction _indexOf(obj, path, value) {\n\t    var arr = _get(obj, path);\n\t    if ((0, _utils.isArray)(arr)) {\n\t        return arr.indexOf(value);\n\t    }\n\t    return -1;\n\t}\n\t\n\texports.indexOf = _indexOf;\n\tfunction _remove(obj, path, value) {\n\t    var parent = obj,\n\t        keys = String(path || '').split('.'),\n\t        key = keys.pop();\n\t\n\t    if (keys.length) {\n\t        parent = _get(obj, keys.join('.'));\n\t    }\n\t    if ((0, _utils.isDefined)(value) && (0, _utils.isArray)(parent[key])) {\n\t        var target = parent[key];\n\t        var index = target.indexOf(value);\n\t        if (index > -1) {\n\t            target.splice(index, 1);\n\t            if (target.length === 0) {\n\t                delete parent[key];\n\t            }\n\t            return true;\n\t        }\n\t        return false;\n\t    } else {\n\t        if ((0, _utils.isObject)(parent) && obj.hasOwnProperty(key)) {\n\t            delete parent[key];\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\t\n\texports.remove = _remove;\n\tfunction _values(obj, path) {\n\t    var values = [];\n\t    var target = _get(obj, path);\n\t    if ((0, _utils.isObject)(target)) {\n\t        for (var name in target) {\n\t            if (target.hasOwnProperty(name)) {\n\t                values.push(target[name]);\n\t            }\n\t        }\n\t    }\n\t    return values;\n\t}\n\texports.values = _values;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.isObject = isObject;\n\texports.isArray = isArray;\n\texports.isString = isString;\n\texports.isFunction = isFunction;\n\texports.isDefined = isDefined;\n\texports.isUndefined = isUndefined;\n\texports.trim = trim;\n\tfunction isObject(value) {\n\t    return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\t\n\tfunction isArray(value) {\n\t    return value instanceof Array;\n\t}\n\t\n\tfunction isString(value) {\n\t    return typeof value === 'string';\n\t}\n\t\n\tfunction isFunction(value) {\n\t    return value instanceof Function;\n\t}\n\t\n\tfunction isDefined(value) {\n\t    return typeof value !== 'undefined';\n\t}\n\t\n\tfunction isUndefined(value) {\n\t    return typeof value === 'undefined';\n\t}\n\t\n\tfunction trim(value) {\n\t    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _Events = __webpack_require__(4);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\t/**\n\t * Transition class\n\t *\n\t * Responsible for managing events in the flow from state to state.\n\t *\n\t * This adds all handlers for the current action start/end and state from/to to an array:\n\t *\n\t * - <namespace>.<target>.<type>[]\n\t *\n\t * So going from state \"a\" to state \"b\" with action \"next\" should build:\n\t *\n\t * - action.*.start[]\n\t * - action.next.start[]\n\t * - state.a.leave[]\n\t * - state.*.leave[]\n\t * - state.*.enter[]\n\t * - state.b.enter[]\n\t * - action.next.end[]\n\t * - action.*.end[]\n\t *\n\t * This can be changed by passing in an order array in fsm.config\n\t *\n\t * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n\t *\n\t * From a callback, you can:\n\t *\n\t * - return false to cancel the transition\n\t * - return true to pause the transition\n\t * - not return a value (the transition continues)\n\t *\n\t * Transitions can also be paused, resumed, or cancelled by calling\n\t * the appropriate method on, or from:\n\t *\n\t * - the event\n\t * - the transition\n\t * - the state machine\n\t *\n\t * Cancelled transitions will reset the FSM to the previous \"from\" state\n\t *\n\t * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          action\n\t * @param {string}          from\n\t * @param {string}          to\n\t */\n\tfunction Transition(fsm, action, from, to) {\n\t    this.fsm = fsm;\n\t    this.action = action;\n\t    this.from = from;\n\t    this.to = to;\n\t    this.clear();\n\t}\n\t\n\t/**\n\t * @prop {StateMachine}    fsm\n\t * @prop {string}          action\n\t * @prop {string}          from\n\t * @prop {string}          to\n\t * @prop {Function[]}      handlers\n\t */\n\tTransition.prototype = {\n\t    fsm: null,\n\t    action: '',\n\t    from: '',\n\t    to: '',\n\t    paused: false,\n\t    handlers: null,\n\t\n\t    clear: function clear() {\n\t        this.paused = false;\n\t        this.handlers = [];\n\t    },\n\t\n\t    /**\n\t     * Execute the next event's callbacks\n\t     * @returns {*}\n\t     */\n\t    exec: function exec() {\n\t        if (!this.paused) {\n\t            if (this.handlers.length) {\n\t                var handler = this.handlers.shift();\n\t                var state = handler();\n\t                if (state === false) {\n\t                    return this.fsm.cancel();\n\t                }\n\t                if (state === true) {\n\t                    return this.fsm.pause();\n\t                }\n\t                this.exec();\n\t            } else {\n\t                this.fsm.end();\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t\n\t    pause: function pause() {\n\t        this.paused = true;\n\t        return this;\n\t    },\n\t\n\t    resume: function resume() {\n\t        this.paused = false;\n\t        return this.exec();\n\t    }\n\t};\n\t\n\texports.default = {\n\t    /**\n\t     * Create the Transition object\n\t     *\n\t     * - Set up variables, and queue\n\t     * - Determine paths to relevant handlers\n\t     * - Build State and Action Event objects\n\t     * - Pre-bind all handlers\n\t     * - Append to queue\n\t     *\n\t     * @param {StateMachine}    fsm\n\t     * @param {string}          action\n\t     * @param {Array}           params\n\t     * @returns {Transition}\n\t     */\n\t    create: function create(fsm, action, params) {\n\t        // transition properties\n\t        var scope = fsm.scope;\n\t        var from = fsm.state;\n\t        var to = fsm.actions.get(action)[from];\n\t        var vars = { action: action, to: to, from: from };\n\t\n\t        // handle \"to\" being a function\n\t        if ((0, _utils.isFunction)(to)) {\n\t            to = to.apply(scope, params);\n\t            if (fsm.states.indexOf(to) === -1) {\n\t                throw new Error('Invalid \"to\" state \"' + to + '\"');\n\t            }\n\t        }\n\t\n\t        // transition\n\t        var queue = [];\n\t        var transition = new Transition(fsm, action, from, to);\n\t\n\t        // build handlers array\n\t        fsm.config.order.map(function (path) {\n\t            // replace path tokens\n\t            path = path.replace(/{(\\w+)}/g, function (all, token) {\n\t                return vars[token];\n\t            });\n\t            var handlers = fsm.handlers.get(path);\n\t\n\t            // do it!\n\t            if (handlers) {\n\t                (function () {\n\t                    var _path$split = path.split('.');\n\t\n\t                    var _path$split2 = _slicedToArray(_path$split, 3);\n\t\n\t                    var namespace = _path$split2[0];\n\t                    var target = _path$split2[1];\n\t                    var type = _path$split2[2];\n\t\n\t                    handlers = handlers.map(function (handler) {\n\t                        // build event object\n\t                        var Event = namespace === 'state' ? _Events.StateEvent : _Events.ActionEvent;\n\t                        var event = new Event(type, target, transition);\n\t\n\t                        // pre-bind handlers, scopes and params\n\t                        // this way scope and params don't need to be passed around\n\t                        // and the call from Transition is always just `value = handler()`\n\t                        return function () {\n\t                            return handler.apply(scope, [event, fsm].concat(params));\n\t                        };\n\t                    });\n\t\n\t                    // add to queue\n\t                    queue = queue.concat(handlers);\n\t                })();\n\t            }\n\t        });\n\t\n\t        // return\n\t        transition.handlers = queue;\n\t        return transition;\n\t    },\n\t\n\t    force: function force(fsm, state) {\n\t        var transition = new Transition(fsm, '', fsm.state, state);\n\t        transition.paused = fsm.transition ? fsm.transition.paused : false;\n\t        return transition;\n\t    }\n\t\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ActionEvent = ActionEvent;\n\texports.StateEvent = StateEvent;\n\texports.SystemEvent = SystemEvent;\n\texports.TransitionEvent = TransitionEvent;\n\t// ------------------------------------------------------------------------------------------------\n\t// setup\n\t\n\t/**\n\t * @prop {string}       namespace   The Event namespace; i.e. state or action\n\t * @prop {string}       type        The Event type;      i.e. leave/enter (state) or start/end (action)\n\t * @prop {string}       target      The Event target;    i.e. intro (state), next (action), or * (all states or types)\n\t * @prop {Transition}   transition  The transition which generated the event\n\t */\n\tvar event = {\n\t    // properties\n\t    namespace: null,\n\t    type: null,\n\t    target: null,\n\t    transition: null\n\t};\n\t\n\tfunction initialize(event, namespace, type, target, transition) {\n\t    event.namespace = namespace;\n\t    event.type = type;\n\t    event.target = target;\n\t    event.transition = transition;\n\t}\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// ActionEvent\n\t\n\tfunction ActionEvent(type, target, transition) {\n\t    initialize(this, 'action', type, target, transition);\n\t}\n\tActionEvent.prototype = event;\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// StateEvent\n\t\n\tfunction StateEvent(type, target, transition) {\n\t    initialize(this, 'state', type, target, transition);\n\t}\n\tStateEvent.prototype = event;\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// SystemEvent\n\t\n\tfunction SystemEvent(type, key, value) {\n\t    this.type = type;\n\t    this.key = key;\n\t    this.value = value;\n\t}\n\t\n\tSystemEvent.prototype = {\n\t    namespace: 'system',\n\t    type: '',\n\t    key: '',\n\t    value: null\n\t};\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// TransitionEvent\n\t\n\tfunction TransitionEvent(type) {\n\t    this.type = type;\n\t}\n\t\n\tTransitionEvent.prototype = {\n\t    namespace: 'transition',\n\t    type: ''\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.parse = parse;\n\texports.getPath = getPath;\n\tvar lookup = {\n\t    namespaces: {\n\t        start: 'system',\n\t        change: 'system',\n\t        update: 'system',\n\t        complete: 'system',\n\t        reset: 'system',\n\t        add: 'system',\n\t        remove: 'system',\n\t\n\t        pause: 'transition',\n\t        resume: 'transition',\n\t        cancel: 'transition'\n\t    },\n\t\n\t    events: {\n\t        start: 'action',\n\t        end: 'action',\n\t        enter: 'state',\n\t        leave: 'state'\n\t    }\n\t};\n\t\n\t/**\n\t * Parses an event handler id into namespace, type, and target variables\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          id\n\t * @return {*[]}\n\t */\n\tfunction parse(fsm, id) {\n\t    // variables\n\t    var defaults = fsm.config.defaults,\n\t        segments = void 0,\n\t        namespace = void 0,\n\t        type = void 0,\n\t        targets = void 0;\n\t\n\t    // utility functions\n\t    function isState(value) {\n\t        return fsm.states.indexOf(value) !== -1;\n\t    }\n\t\n\t    function isAction(value) {\n\t        return fsm.actions.has(value);\n\t    }\n\t\n\t    function getTargets(value) {\n\t        return value ? value.match(/\\w[-\\w]*/g) : ['*'];\n\t    }\n\t\n\t    function determineValue(value) {\n\t\n\t        // is namespace, i.e. system, transition, state, action\n\t        if (/^(system|transition|state|action)$/.test(value)) {\n\t            namespace = value;\n\t        }\n\t\n\t        // is shortcut, i.e. update, change, pause, cancel\n\t        else if (value in lookup.namespaces) {\n\t                namespace = lookup.namespaces[value];\n\t                type = value;\n\t            }\n\t\n\t            // is state or action, i.e. a, next\n\t            else if (isState(value) || isAction(value)) {\n\t                    if (!namespace) {\n\t                        namespace = isState(value) ? 'state' : 'action';\n\t                    }\n\t\n\t                    // special case for state with action\n\t                    if (namespace === 'state' && isAction(value)) {\n\t                        type = value;\n\t                    }\n\t\n\t                    if (!targets) {\n\t                        targets = getTargets(value);\n\t                    }\n\t                }\n\t\n\t                // action / leave\n\t                else if (/^(enter|leave)$/.test(value)) {\n\t                        type = value;\n\t                    }\n\t    }\n\t\n\t    // process\n\t    segments = id.match(/:\\w+|@\\w+|\\(.+?\\)|\\.\\w+|\\w+/g);\n\t\n\t    // process segments\n\t    segments.forEach(function (segment, i, segments) {\n\t        // variables\n\t        var char = segment[0];\n\t        var values = segment.match(/\\w+/g);\n\t        var value = values[0];\n\t        switch (char) {\n\t            // event\n\t            case ':':\n\t                namespace = lookup.events[value];\n\t                type = value;\n\t                break;\n\t\n\t            // action\n\t            case '@':\n\t                namespace = 'state';\n\t                type = value;\n\t                break;\n\t\n\t            // targets\n\t            case '(':\n\t                targets = values;\n\t                namespace = isState(values[0]) ? 'state' : 'action';\n\t                break;\n\t\n\t            // property\n\t            case '.':\n\t                determineValue(value);\n\t                break;\n\t\n\t            // single word\n\t            default:\n\t                determineValue(segment);\n\t        }\n\t    });\n\t\n\t    // final processing\n\t    if (!targets) {\n\t        targets = getTargets();\n\t    }\n\t\n\t    if (!namespace) {\n\t        namespace = isState(targets[0]) ? 'state' : 'action';\n\t    }\n\t\n\t    if (!type) {\n\t        type = defaults[namespace];\n\t    }\n\t\n\t    // return values\n\t    return [namespace, type, targets];\n\t}\n\t\n\t/**\n\t * Builds the path to a handler\n\t *\n\t * System and Transition only have 2 segments, Action and State have 3\n\t *\n\t * @param {string}      namespace\n\t * @param {string}      type\n\t * @param {string}      target\n\t * @return {string}\n\t */\n\tfunction getPath(namespace, type, target) {\n\t    return namespace === 'action' || namespace === 'state' ? [namespace, target, type].join('.') : namespace + '.' + type;\n\t}\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** state-machine.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap e1d9771444d8219809c6\n **/","import ValueMap from './utils/ValueMap';\nimport Transition from './Transition';\nimport { SystemEvent, TransitionEvent } from './Events';\nimport { isString, isFunction } from './utils/utils';\nimport { getPath, parse } from './utils/handlers'\n\nexport default function StateMachine (scope, config)\n{\n    // parameters\n    if(arguments.length == 1)\n    {\n        [config, scope] = [scope, null];\n    }\n\n    // assignment\n    this.scope          = scope;\n    this.state          = '';\n    this.states         = [];\n    this.transitions    = new ValueMap();\n    this.actions        = new ValueMap();\n    this.handlers       = new ValueMap();\n\n    // initialize\n    if(config)\n    {\n        this.initialize(config);\n    }\n}\n\nStateMachine.parse = parse;\nStateMachine.getPath = getPath;\n\n/**\n * StateMachine prototype\n *\n * The property examples below illustrate a 4-state machine, with states:\n *\n * - intro > settings > summary > end\n *\n * And actions:\n *\n * - back | next | restart | finish\n */\nStateMachine.prototype =\n{\n    // ------------------------------------------------------------------------------------------------\n    // properties\n\n        /**\n         * Available state names\n         *\n         * - [\n         *     intro,\n         *     settings,\n         *     summary,\n         *     final\n         *   ]\n         *\n         * @var {string[]}\n         */\n        states      : null,\n\n        /**\n         * Available transitions for each action\n         *\n         * action.from => to\n         *\n         * - next: {\n         *     intro: settings,\n         *     settings: summary\n         *   },\n         * - back: {\n         *     settings: intro\n         *   },\n         * - restart: {\n         *     summary:intro\n         *   },\n         * - finish: {\n         *     summary:final\n         *   },\n         *\n         * Transitions can also be functions\n         *\n         * - next: {\n         *     intro: function() { return '<random state>' } // jump to a random state\n         *   }\n         *\n         * @var {ValueMap}\n         */\n        transitions : null,\n\n        /**\n         * Actions that are available to be called from each state\n         *\n         * state => [ action, action, ... ]\n         *\n         * - intro: [\n         *     'next'\n         *   ],\n         * - settings: [\n         *     'next',\n         *     'back'\n         *   ],\n         * - summary: [\n         *     'restart'\n         *     'finish',\n         *   ]\n         *\n         * Actions can also be expressed as wildcards\n         *\n         * - intro: [\n         *     '*' // any action is allowed from intro\n         *   ]\n         *\n         * @var {ValueMap}\n         */\n        actions     : null,\n\n        /**\n         * Handler functions that should be called on each action event / state change\n         *\n         * name.type => [ handler, handler, ... ]\n         *\n         * - next: {\n         *   - start: [\n         *       hideModal\n         *     ],\n         *   - end: [\n         *       showModal\n         *     ]\n         *   },\n         * - summary: {\n         *   - enter: [\n         *       resetForm\n         *     ],\n         *   - leave: [\n         *       validateForm,\n         *       postData,\n         *     ]\n         *   },\n         *   ...\n         *\n         * @var {ValueMap}\n         */\n        handlers   : null,\n\n        /**\n         * The current state\n         *\n         * @var {string}\n         */\n        state       : '',\n\n        /**\n         * Any active Transition object that is driving the state change\n         *\n         * @var {Transition}\n         */\n        transition  : null,\n\n        /**\n         * The scope in which to call all handlers\n         *\n         * @var {*}\n         */\n        scope      : null,\n\n        /**\n         * The original config object\n         *\n         * @var {Object}\n         */\n        config      : null,\n\n\n    // ------------------------------------------------------------------------------------------------\n    // private methods\n\n        /**\n         * Initialize the FSM with a config object\n         *\n         * @private\n         * @param config\n         */\n        initialize:function (config)\n        {\n            // assign config\n            this.config     = config;\n\n            // scope\n            if(config.scope)\n            {\n                this.scope = config.scope;\n            }\n\n            // pre-collate all states\n            addStates(this, 'from', config.events);\n            addStates(this, 'to', config.events);\n\n            // initial state\n            if( ! config.initial )\n            {\n                config.initial = this.states[0];\n            }\n\n            // add transitions\n            config.events.map( event =>\n            {\n                // shorthand\n                if(isString(event))\n                {\n                    let matches = event.match(/(\\w+)\\s*[\\|:=]\\s*(\\w+)\\s*([<>-])\\s*(\\w.*)/);\n                    let [,name, from, op, to] = matches;\n                    if(op === '-')\n                    {\n                        this.add(name, from, to);\n                        this.add(name, to, from);\n                        return;\n                    }\n                    if(op === '<')\n                    {\n                        [from, to] = [to, from];\n                    }\n                    this.add(name, from, to);\n                }\n\n                // keys\n                else\n                {\n                    this.add(event.name, event.from, event.to);\n                }\n            });\n\n            // add handlers\n            for(let name in config.handlers)\n            {\n                if(config.handlers.hasOwnProperty(name))\n                {\n                    this.on(name, config.handlers[name]);\n                }\n            }\n\n            // start automatically unless defer is set to true\n            if( ! config.defer )\n            {\n                this.state = config.initial;\n            }\n\n            /**\n             * Sets defaults for various declarations\n             *\n             * @type {Object}\n             */\n            config.defaults = Object.assign({\n\n                // initialize event\n                initialize  :'initialize',\n\n                // handler defaults\n                action      :'start',\n                state       :'enter'\n\n            }, config.defaults);\n\n            /**\n             * Sets the default order to run transition callbacks in\n             *\n             * @type {string[]} type.target\n             */\n            config.order = config.order ||\n            [\n                'action.*.start',\n                'action.{action}.start',\n                'state.{*}.{action}',\n                'state.{from}.{action}',\n                'state.{from}.leave',\n                'state.*.leave',\n                'state.*.enter',\n                'state.{to}.enter',\n                //'state.{to}.{action}',\n                'action.{action}.end',\n                'action.*.end'\n            ];\n        },\n\n        /**\n         * Dispatch an event\n         *\n         * @param   {string}    namespace\n         * @param   {string}    type\n         * @param   {string}    key\n         * @param   {*}         value\n         * @returns {StateMachine}\n         */\n        update: function (namespace, type, key = '', value = null)\n        {\n            let signature = namespace + '.' + type;\n            let event = namespace === 'system'\n                ? new SystemEvent(type, key, value)\n                : new TransitionEvent(type);\n            this.dispatch(signature, event);\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // api\n\n        /**\n         * Attempt to run an action, resulting in a transition to a state\n         *\n         * @param   {string}    action\n         * @param   {*[]}       rest\n         * @returns {boolean}\n         */\n        do: function (action, ...rest)\n        {\n            if(this.can(action) && !this.isPaused())\n            {\n                this.transition = Transition.create(this, action, rest);\n                if(action === this.config.defaults.initialize)\n                {\n                    this.update('system', 'initialize');\n                }\n                this.update('system', 'update', 'transition', this.transition);\n                this.transition.exec();\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Attempt to go to a state\n         *\n         * Finds if an appropriate transition exists, then calls the related action if it does\n         *\n         * @param   {string}    state\n         * @param   {boolean}   [force]\n         * @returns {boolean}\n         */\n        go: function (state, force = false)\n        {\n            if(this.has(state))\n            {\n                if(force)\n                {\n                    this.transition = Transition.force(this, state);\n                    return this.end();\n                }\n                var action = this.getActionForState(state);\n                if(action)\n                {\n                    return this.do(action);\n                }\n                this.config.debug && console.info('No transition exists from \"%s\" to \"%s\"', this.state, state);\n            }\n            else\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n            }\n            return false;\n        },\n\n        /**\n         * Query a transition to see if a named action is available\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        can: function (action)\n        {\n            if( ! this.actions.has(action) )\n            {\n                this.config.debug && console.warn('No such action \"%s\"', action);\n            }\n            return !! this.transitions.has(this.state, action);\n        },\n\n        /**\n         * Query a transition to see if a named action is unavailable\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        cannot: function (action)\n        {\n            return ! this.can(action);\n        },\n\n        /**\n         * Test if the current state is the same as the supplied one\n         *\n         * @param   {string}    state       A state name to compare against the current state\n         * @returns {boolean}\n         */\n        is: function (state)\n        {\n            if(this.states.indexOf(state) === -1)\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n            }\n            return state === this.state;\n        },\n\n        /**\n         * Test if a state exists\n         *\n         * @param   {string}    state\n         * @return  {boolean}\n         */\n        has: function(state)\n        {\n            return this.states.indexOf(state) !== -1;\n        },\n\n        /**\n         * Get the available \"to\" states for the current or supplied state\n         *\n         * @param   {string}    [state]     Optional name of a state to get states for. Defaults to the current state\n         * @returns {string[]}              An array of string states\n         */\n        getStatesFor: function (state = null)\n        {\n            state       = state || this.state;\n            let actions = this.getActionsFor(state, true);\n            return Object.keys(actions).map( name => actions[name] );\n        },\n\n        /**\n         * Get the available actions (or actions and states) for the current or supplied state\n         *\n         * @param   {string}    [state]     Optional name of a state to get actions for. Defaults to the current state\n         * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n         * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n         */\n        getActionsFor: function (state = '', asMap = false)\n        {\n            state       = state || this.state;\n            let actions = this.transitions.get(state || this.state);\n            if(asMap)\n            {\n                let states  = {};\n                actions.map( action =>\n                {\n                    states[action] = this.actions.get(action + '.' + state);\n                });\n                return states;\n            }\n            else\n            {\n                return actions;\n            }\n        },\n\n        getActionForState: function (state)\n        {\n            if(this.has(state))\n            {\n                let actions = this.getActionsFor(state, true);\n                for(let action in actions)\n                {\n                    if(actions[action] === state)\n                    {\n                        return action;\n                    }\n                }\n            }\n            return null;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // flags\n\n        /**\n         * Test if the FSM has started\n         *\n         * @returns {boolean}\n         */\n        isStarted: function ()\n        {\n            return this.state !== '';\n        },\n\n        /**\n         * Test if the FSM is transitioning\n         *\n         * @returns {boolean}\n         */\n        isTransitioning: function ()\n        {\n            return !! this.transition;\n        },\n\n        /**\n         * Test if the FSM is paused (whilst transitioning)\n         *\n         * @returns {boolean}\n         */\n        isPaused: function ()\n        {\n            return this.transition\n                ? this.transition.paused\n                : false;\n        },\n\n        /**\n         * Test if the FSM is on the \"final\" state\n         *\n         * @returns {boolean}\n         */\n        isComplete: function ()\n        {\n            return this.state === this.config.final;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // transitions\n\n        /**\n         * Pause any current transition\n         *\n         * @returns {StateMachine}\n         */\n        pause: function ()\n        {\n            if(this.transition && !this.isPaused())\n            {\n                this.transition.pause();\n                this.update('transition', 'pause');\n                this.update('system', 'update', 'pause', true);\n            }\n            return this;\n        },\n\n        /**\n         * Resume any current transition\n         *\n         * @returns {StateMachine}\n         */\n        resume: function ()\n        {\n            if(this.transition && this.isPaused())\n            {\n                this.update('transition', 'resume');\n                this.update('system', 'update', 'pause', false);\n                this.transition.resume();\n            }\n            return this;\n        },\n\n        /**\n         * Cancel any current transition\n         *\n         * @returns {StateMachine}\n         */\n        cancel: function ()\n        {\n            if(this.transition)\n            {\n                if(this.isPaused())\n                {\n                    this.update('system', 'update', 'pause', false);\n                }\n                this.state = this.transition.from;\n                this.transition.clear();\n                delete this.transition;\n                this.update('transition', 'cancel');\n                this.update('system', 'update', 'transition', null);\n            }\n            return this;\n        },\n\n        /**\n         * End any current transition, skipping remaining handlers\n         *\n         * @returns {StateMachine}\n         */\n        end: function ()\n        {\n            if(this.transition)\n            {\n                if(this.isPaused())\n                {\n                    this.update('system', 'update', 'pause', false);\n                }\n                this.state = this.transition.to;\n                this.transition.clear();\n                delete this.transition;\n                this.update('system', 'change', 'state', this.state);\n                this.update('system', 'update', 'state', this.state);\n                if(this.isComplete())\n                {\n                    this.update('system', 'complete');\n                }\n                this.update('system', 'update', 'transition', null);\n            }\n            return this;\n        },\n\n        /**\n         * Reset the FSM to the initial, or supplied, state\n         *\n         * @returns {StateMachine}\n         */\n        reset:function(initial = '')\n        {\n            let state = initial || this.config.initial;\n            this.update('system', 'reset');\n            if(this.transition)\n            {\n                if(this.isPaused())\n                {\n                    this.update('system', 'update', 'pause', false);\n                }\n                this.transition.clear();\n                delete this.transition;\n                this.update('transition', 'cancel');\n                this.update('system', 'update', 'transition', null);\n            }\n            if(this.state !== state)\n            {\n                this.state = state;\n                this.update('system', 'change', 'state', this.state);\n                this.update('system', 'update', 'state', this.state);\n            }\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // actions\n\n        /**\n         * Add a transition\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        add: function (action, from, to)\n        {\n            this.actions.set(action + '.' + from, to);\n            this.transitions.add(from, action);\n            return this;\n        },\n\n        /**\n         * Remove a transition\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        remove: function (action, from, to)\n        {\n            this.states.remove(action, from);\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // handlers\n\n        /**\n         * Add an event handler\n         *\n         * Event handler signature:\n         *\n         * - namespace.type:target1 target2 target3 ...\n         *\n         * Valid event namespaces / types:\n         *\n         * - system.(change|update|complete|reset)\n         * - action.(start|end)\n         * - state.(add|remove|leave|enter)\n         * - transition.(pause|resume|cancel)\n         *\n         * As event types are unique, they can be used without the namespace:\n         *\n         * - change\n         * - pause\n         * - start\n         * - end\n         * - leave:red\n         * - enter:blue green\n         * - start:next\n         * - end:back\n         *\n         * You can also just pass action or names to target individual state.leave / action.end events:\n         *\n         * - next\n         * - intro\n         *\n         * Finally, you can target a state with an action:\n         *\n         * - state@action\n         * - intro@next\n         * - form@submit\n         * - form@leave (built-in state/action)\n         *\n         * @param id\n         * @param fn\n         * @return {StateMachine}\n         */\n        on: function (id, fn)\n        {\n            let [namespace, type, targets] = parse(this, id);\n\n            if(this.config.debug)\n            {\n                console.log('StateMachine on: ' + id, [namespace, type], targets)\n            }\n\n            targets.map( target =>\n            {\n                // warn for invalid actions / states\n                if(target !== '*')\n                {\n                    if(namespace === 'state')\n                    {\n                        if(this.states.indexOf(target) === -1)\n                        {\n                            this.config.debug && console.warn('StateMachine: Warning assigning state.%s handler; no such state \"%s\"', type, target);\n                        }\n                    }\n                    else if(namespace === 'action')\n                    {\n                        if(!this.actions.has(target))\n                        {\n                            this.config.debug && console.warn('StateMachine: Warning assigning action.%s handler; no such action \"%s\"', type, target);\n                        }\n                    }\n                }\n\n                // check handler is a function\n                if(!isFunction(fn))\n                {\n                    throw new Error('Error assigning ' +namespace+ '.' +type+ ' handler; callback is not a Function', fn);\n                }\n\n                // assign\n                let path = getPath(namespace, type, target);\n                this.handlers.insert(path, fn);\n            });\n\n            return this;\n        },\n\n        off: function (id, fn)\n        {\n            let [namespace, type, targets] = parse(this, id);\n            targets.map( target =>\n            {\n                let path = getPath(namespace, type, target);\n                this.handlers.remove(path, fn)\n            });\n        },\n\n        dispatch: function(path, event)\n        {\n            this.config.debug && console.info('StateMachine: dispatch \"%s\"', path);\n            let handlers = this.handlers.get(path);\n            if(handlers)\n            {\n                // do we need to pass additional arguments?\n                handlers.map(fn => fn(event) );\n            }\n        }\n\n};\n\n/**\n * Parses config and adds unique state names to states array\n *\n * @param {StateMachine}    fsm\n * @param {string}          key\n * @param {Object[]}        transitions\n */\nfunction addStates(fsm, key, transitions)\n{\n    transitions.map( event => addState(fsm, event[key]) );\n}\n\nfunction addState (fsm, state)\n{\n    if (isString(state) && fsm.states.indexOf(state) === -1)\n    {\n        fsm.states.push(state);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/StateMachine.js\n **/","import {isObject, isArray, isDefined, isUndefined} from './utils';\n\n/**\n * Utility class to create, modify and delete nested hashes and values\n *\n * @constructor\n */\nexport default function ValueMap (data)\n{\n    this.data = data || {};\n}\n\nValueMap.prototype =\n{\n    data: null,\n\n    set: function (path, value)\n    {\n        set(this.data, path, value);\n        return this;\n    },\n\n    add:function(path, value)\n    {\n        add(this.data, path, value);\n        return this;\n    },\n\n    insert:function(path, value)\n    {\n        insert(this.data, path, value);\n        return this;\n    },\n\n    get:function(path)\n    {\n        return get(this.data, path);\n    },\n\n    has: function (path, value = undefined)\n    {\n        return has(this.data, path, value)\n    },\n\n    indexOf: function (path, value)\n    {\n        return indexOf(this.data, path, value)\n    },\n\n    remove: function (path, value = undefined)\n    {\n        remove(this.data, path, value);\n        return this;\n    },\n\n    keys:function(path)\n    {\n        return Object.keys(get(this.data, path));\n    },\n\n    values:function(path)\n    {\n        return values(this.data, path);\n    }\n\n};\n\nfunction create(obj, keys)\n{\n    let key;\n    while(keys.length)\n    {\n        key = keys.shift();\n        if( ! isObject(obj[key]) )\n        {\n            obj[key] = {};\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n\nexport function set(obj, path, value, index = -1)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    obj[key] = value;\n}\n\nfunction add(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    obj[key].push(value);\n}\n\nfunction insert(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    let parent = obj[key],\n        index = parent.indexOf(value);\n    if(index === -1)\n    {\n        parent.push(value);\n    }\n    else\n    {\n        parent[index] = value;\n    }\n}\n\nexport function get(obj, path)\n{\n    if(isUndefined(path) || path == '')\n    {\n        return obj;\n    }\n\n    let key,\n        keys = String(path).split('.');\n    while(keys.length > 1)\n    {\n        key = keys.shift();\n        if( ! obj.hasOwnProperty(key) )\n        {\n            return;\n        }\n        obj = obj[key];\n    }\n    key = keys.shift();\n    return obj[key];\n}\n\nexport function has(obj, path, value)\n{\n    let parent = get(obj, path);\n    return !! (isArray(parent) && isDefined(value)\n        ? parent.indexOf(value) !== -1\n        : isUndefined(value)\n            ? isDefined(parent)\n            : parent === value);\n}\n\nexport function indexOf (obj, path, value)\n{\n    let arr = get(obj, path);\n    if(isArray(arr))\n    {\n        return arr.indexOf(value);\n    }\n    return -1;\n}\n\nexport function remove(obj, path, value)\n{\n    let parent = obj,\n        keys = String(path || '').split('.'),\n        key = keys.pop();\n\n    if(keys.length)\n    {\n        parent = get(obj, keys.join('.'))\n    }\n    if(isDefined(value) && isArray(parent[key]))\n    {\n        let target = parent[key];\n        var index = target.indexOf(value);\n        if(index > -1)\n        {\n            target.splice(index, 1);\n            if(target.length === 0)\n            {\n                delete parent[key];\n            }\n            return true;\n        }\n        return false;\n    }\n    else\n    {\n        if(isObject(parent) && obj.hasOwnProperty(key))\n        {\n            delete parent[key];\n            return true;\n        }\n    }\n    return false\n}\n\nexport function values(obj, path)\n{\n    var values = [];\n    var target = get(obj, path);\n    if(isObject(target))\n    {\n        for(var name in target)\n        {\n            if(target.hasOwnProperty(name))\n            {\n                values.push(target[name]);\n            }\n        }\n    }\n    return values;\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/ValueMap.js\n **/","export function isObject (value)\n{\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport function isArray (value)\n{\n    return value instanceof Array;\n}\n\nexport function isString (value)\n{\n    return typeof value === 'string';\n}\n\nexport function isFunction(value)\n{\n    return value instanceof Function;\n}\n\nexport function isDefined (value)\n{\n    return typeof value !== 'undefined';\n}\n\nexport function isUndefined (value)\n{\n    return typeof value === 'undefined';\n}\n\nexport function trim (value)\n{\n    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/utils.js\n **/","import { StateEvent, ActionEvent } from './Events';\nimport { isFunction } from './utils/utils';\n\n/**\n * Transition class\n *\n * Responsible for managing events in the flow from state to state.\n *\n * This adds all handlers for the current action start/end and state from/to to an array:\n *\n * - <namespace>.<target>.<type>[]\n *\n * So going from state \"a\" to state \"b\" with action \"next\" should build:\n *\n * - action.*.start[]\n * - action.next.start[]\n * - state.a.leave[]\n * - state.*.leave[]\n * - state.*.enter[]\n * - state.b.enter[]\n * - action.next.end[]\n * - action.*.end[]\n *\n * This can be changed by passing in an order array in fsm.config\n *\n * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n *\n * From a callback, you can:\n *\n * - return false to cancel the transition\n * - return true to pause the transition\n * - not return a value (the transition continues)\n *\n * Transitions can also be paused, resumed, or cancelled by calling\n * the appropriate method on, or from:\n *\n * - the event\n * - the transition\n * - the state machine\n *\n * Cancelled transitions will reset the FSM to the previous \"from\" state\n *\n * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n *\n * @param {StateMachine}    fsm\n * @param {string}          action\n * @param {string}          from\n * @param {string}          to\n */\nfunction Transition (fsm, action, from, to)\n{\n    this.fsm        = fsm;\n    this.action     = action;\n    this.from       = from;\n    this.to         = to;\n    this.clear();\n}\n\n/**\n * @prop {StateMachine}    fsm\n * @prop {string}          action\n * @prop {string}          from\n * @prop {string}          to\n * @prop {Function[]}      handlers\n */\nTransition.prototype =\n{\n    fsm         : null,\n    action      : '',\n    from        : '',\n    to          : '',\n    paused      : false,\n    handlers    : null,\n\n    clear: function ()\n    {\n        this.paused = false;\n        this.handlers = [];\n    },\n\n    /**\n     * Execute the next event's callbacks\n     * @returns {*}\n     */\n\texec: function ()\n\t{\n\t    if( ! this.paused )\n        {\n            if(this.handlers.length)\n            {\n                var handler = this.handlers.shift();\n                var state = handler();\n                if(state === false)\n                {\n                    return this.fsm.cancel();\n                }\n                if(state === true)\n                {\n                    return this.fsm.pause();\n                }\n                this.exec();\n            }\n            else\n            {\n                this.fsm.end();\n            }\n        }\n        return this;\n\t},\n\n    pause: function ()\n    {\n        this.paused = true;\n        return this;\n    },\n\n    resume: function ()\n    {\n        this.paused = false;\n        return this.exec();\n    }\n};\n\nexport default\n{\n    /**\n     * Create the Transition object\n     *\n     * - Set up variables, and queue\n     * - Determine paths to relevant handlers\n     * - Build State and Action Event objects\n     * - Pre-bind all handlers\n     * - Append to queue\n     *\n     * @param {StateMachine}    fsm\n     * @param {string}          action\n     * @param {Array}           params\n     * @returns {Transition}\n     */\n    create:function (fsm, action, params)\n    {\n        // transition properties\n        let scope   = fsm.scope;\n        let from    = fsm.state;\n        let to      = fsm.actions.get(action)[from];\n        let vars    = {action, to, from};\n\n        // handle \"to\" being a function\n        if(isFunction(to))\n        {\n            to = to.apply(scope, params);\n            if(fsm.states.indexOf(to) === -1)\n            {\n                throw new Error('Invalid \"to\" state \"' +to+ '\"');\n            }\n        }\n\n        // transition\n        let queue       = [];\n        let transition  = new Transition(fsm, action, from, to);\n\n        // build handlers array\n        fsm.config.order.map( path =>\n        {\n            // replace path tokens\n            path = path.replace(/{(\\w+)}/g, (all, token) => vars[token]);\n            let handlers = fsm.handlers.get(path);\n\n            // do it!\n            if(handlers)\n            {\n                let [namespace, target, type] = path.split('.');\n                handlers = handlers.map( handler =>\n                {\n                    // build event object\n                    let Event = namespace === 'state' ? StateEvent : ActionEvent;\n                    let event = new Event(type, target, transition);\n\n                    // pre-bind handlers, scopes and params\n                    // this way scope and params don't need to be passed around\n                    // and the call from Transition is always just `value = handler()`\n                    return function()\n                    {\n                        return handler.apply(scope, [event, fsm].concat(params));\n                    }\n                });\n\n                // add to queue\n                queue = queue.concat(handlers);\n            }\n        });\n\n        // return\n        transition.handlers = queue;\n        return transition;\n    },\n\n    force: function(fsm, state)\n    {\n        let transition = new Transition(fsm, '', fsm.state, state);\n        transition.paused = fsm.transition ? fsm.transition.paused : false;\n        return transition;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/Transition.js\n **/","// ------------------------------------------------------------------------------------------------\n// setup\n\n    /**\n     * @prop {string}       namespace   The Event namespace; i.e. state or action\n     * @prop {string}       type        The Event type;      i.e. leave/enter (state) or start/end (action)\n     * @prop {string}       target      The Event target;    i.e. intro (state), next (action), or * (all states or types)\n     * @prop {Transition}   transition  The transition which generated the event\n     */\n    let event =\n    {\n        // properties\n        namespace   : null,\n        type        : null,\n        target      : null,\n        transition          : null\n    };\n\n    function initialize (event, namespace, type, target, transition)\n    {\n        event.namespace     = namespace;\n        event.type          = type;\n        event.target        = target;\n        event.transition    = transition;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// ActionEvent\n\n    export function ActionEvent (type, target, transition)\n    {\n        initialize(this, 'action' ,type, target, transition);\n    }\n    ActionEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// StateEvent\n\n    export function StateEvent (type, target, transition)\n    {\n        initialize(this, 'state' ,type, target, transition);\n    }\n    StateEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// SystemEvent\n\n    export function SystemEvent (type, key, value)\n    {\n        this.type   = type;\n        this.key    = key;\n        this.value  = value;\n    }\n\n    SystemEvent.prototype =\n    {\n        namespace   : 'system',\n        type        : '',\n        key         : '',\n        value       : null\n    };\n\n\n// ------------------------------------------------------------------------------------------------\n// TransitionEvent\n\n    export function TransitionEvent (type)\n    {\n        this.type = type;\n    }\n\n    TransitionEvent.prototype =\n    {\n        namespace   : 'transition',\n        type        : ''\n    };\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/Events.js\n **/","let lookup =\n{\n    namespaces:\n    {\n        start   :'system',\n        change  :'system',\n        update  :'system',\n        complete:'system',\n        reset   :'system',\n        add     :'system',\n        remove  :'system',\n\n        pause   :'transition',\n        resume  :'transition',\n        cancel  :'transition'\n    },\n\n    events:\n    {\n        start   :'action',\n        end     :'action',\n        enter   :'state',\n        leave   :'state'\n    }\n};\n\n/**\n * Parses an event handler id into namespace, type, and target variables\n *\n * @param {StateMachine}    fsm\n * @param {string}          id\n * @return {*[]}\n */\nexport function parse(fsm, id)\n{\n    // variables\n    let defaults = fsm.config.defaults,\n        segments,\n        namespace,\n        type,\n        targets;\n\n    // utility functions\n    function isState(value) {\n        return fsm.states.indexOf(value) !== -1;\n    }\n\n    function isAction(value) {\n        return fsm.actions.has(value);\n    }\n\n    function getTargets(value) {\n        return value ? value.match(/\\w[-\\w]*/g) : ['*'];\n    }\n\n    function determineValue(value) {\n\n        // is namespace, i.e. system, transition, state, action\n        if(/^(system|transition|state|action)$/.test(value))\n        {\n            namespace = value;\n        }\n\n        // is shortcut, i.e. update, change, pause, cancel\n        else if(value in lookup.namespaces)\n        {\n            namespace = lookup.namespaces[value];\n            type = value;\n        }\n\n        // is state or action, i.e. a, next\n        else if (isState(value) || isAction(value))\n        {\n            if(!namespace)\n            {\n                namespace = isState(value)\n                    ? 'state'\n                    : 'action';\n            }\n\n            // special case for state with action\n            if(namespace === 'state' && isAction(value))\n            {\n                type = value;\n            }\n\n            if(!targets)\n            {\n                targets = getTargets(value);\n            }\n        }\n\n        // action / leave\n        else if(/^(enter|leave)$/.test(value))\n        {\n            type = value;\n        }\n    }\n\n    // process\n    segments    = id.match(/:\\w+|@\\w+|\\(.+?\\)|\\.\\w+|\\w+/g);\n\n    // process segments\n    segments.forEach(function (segment, i, segments)\n    {\n        // variables\n        let char    = segment[0];\n        let values  = segment.match(/\\w+/g);\n        let value   = values[0];\n        switch(char)\n        {\n            // event\n            case ':':\n                namespace   = lookup.events[value];\n                type        = value;\n                break;\n\n            // action\n            case '@':\n                namespace   = 'state';\n                type        = value;\n                break;\n\n            // targets\n            case '(':\n                targets = values;\n                namespace = isState(values[0]) ? 'state' : 'action';\n                break;\n\n            // property\n            case '.':\n                determineValue(value);\n                break;\n\n            // single word\n            default:\n                determineValue(segment);\n        }\n    });\n\n    // final processing\n    if(!targets)\n    {\n        targets = getTargets();\n    }\n\n    if(!namespace)\n    {\n        namespace = isState(targets[0]) ? 'state' : 'action';\n    }\n\n    if(!type)\n    {\n        type = defaults[namespace];\n    }\n\n    // return values\n    return [namespace, type, targets];\n}\n\n/**\n * Builds the path to a handler\n *\n * System and Transition only have 2 segments, Action and State have 3\n *\n * @param {string}      namespace\n * @param {string}      type\n * @param {string}      target\n * @return {string}\n */\nexport function getPath(namespace, type, target)\n{\n    return namespace === 'action' || namespace === 'state'\n        ? [namespace, target, type].join('.')\n        : namespace + '.' + type;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/handlers.js\n **/"],"sourceRoot":""}