{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///state-machine.min.js","webpack:///webpack/bootstrap ba481e3156a1f21e1817","webpack:///./src/StateMachine.js","webpack:///./src/utils/ValueMap.js","webpack:///./src/utils/utils.js","webpack:///./src/Transition.js","webpack:///./src/Events.js","webpack:///./src/utils/handlers.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","StateMachine","scope","config","arguments","length","_ref","state","states","transitions","_ValueMap2","actions","handlers","initialize","addState","fsm","_utils","isString","indexOf","push","Object","defineProperty","value","_typeof","Symbol","iterator","constructor","prototype","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","next","done","err","Array","isArray","TypeError","_ValueMap","_Transition","_Transition2","_Events","_handlers","parse","transition","_this","newError","tx","message","Error","add","name","from","to","map","replace","test","matches","match","action","shift","stack","op","a","b","_ref2","_ref3","initial","hasOwnProperty","on","defer","defaults","assign","order","update","namespace","type","key","signature","event","SystemEvent","TransitionEvent","dispatch","do","can","isPaused","_len","rest","_key","create","exec","go","force","has","end","getActionForState","debug","console","info","warn","cannot","is","getStatesFor","getActionsFor","keys","_this2","asMap","get","_ret3","v","isStarted","isTransitioning","paused","isComplete","pause","resume","cancel","clear","reset","set","remove","fn","_this3","result","log","paths","path","index","target","targets","isFunction","insert","off","_this4","_this5","ValueMap","data","isObject","String","split","pop","parent","isUndefined","isDefined","join","splice","values","_set","_get","_has","_indexOf","_remove","_values","toString","Function","trim","Transition","handler","params","vars","apply","queue","all","token","_path$split","_path$split2","Event","StateEvent","ActionEvent","concat","isState","isAction","getTargets","determineValue","lookup","namespaces","segments","forEach","segment","char","events","ParseResult","start","change","complete","enter","leave"],"mappings":"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","file":"state-machine.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StateMachine\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StateMachine\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.default = StateMachine;\n\t\n\tvar _ValueMap = __webpack_require__(1);\n\t\n\tvar _ValueMap2 = _interopRequireDefault(_ValueMap);\n\t\n\tvar _Transition = __webpack_require__(3);\n\t\n\tvar _Transition2 = _interopRequireDefault(_Transition);\n\t\n\tvar _Events = __webpack_require__(4);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _handlers = __webpack_require__(5);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction StateMachine(scope, config) {\n\t    // allow [scope, config] or [config] as parameters\n\t    if (arguments.length == 1) {\n\t        var _ref = [scope, null];\n\t        config = _ref[0];\n\t        scope = _ref[1];\n\t    }\n\t\n\t    // assignment\n\t    this.scope = scope;\n\t    this.state = '';\n\t    this.states = [];\n\t    this.transitions = new _ValueMap2.default();\n\t    this.actions = new _ValueMap2.default();\n\t    this.handlers = new _ValueMap2.default();\n\t\n\t    // initialize\n\t    if (config) {\n\t        this.initialize(config);\n\t    }\n\t}\n\t\n\tStateMachine.parse = _handlers.parse;\n\t\n\t/**\n\t * StateMachine prototype\n\t *\n\t * The property examples below illustrate a 4-state machine, with states:\n\t *\n\t * - intro > settings > summary > end\n\t *\n\t * And actions:\n\t *\n\t * - back | next | restart | finish\n\t */\n\tStateMachine.prototype = {\n\t    // ------------------------------------------------------------------------------------------------\n\t    // properties\n\t\n\t    /**\n\t     * Available state names\n\t     *\n\t     * - [\n\t     *     intro,\n\t     *     settings,\n\t     *     summary,\n\t     *     final\n\t     *   ]\n\t     *\n\t     * @var {string[]}\n\t     */\n\t    states: null,\n\t\n\t    /**\n\t     * Available transitions for each action\n\t     *\n\t     * action.from => to\n\t     *\n\t     * - next: {\n\t     *     intro: settings,\n\t     *     settings: summary\n\t     *   },\n\t     * - back: {\n\t     *     settings: intro\n\t     *   },\n\t     * - restart: {\n\t     *     summary:intro\n\t     *   },\n\t     * - finish: {\n\t     *     summary:final\n\t     *   },\n\t     *\n\t     * Transitions can also be functions\n\t     *\n\t     * - next: {\n\t     *     intro: function() { return '<random state>' } // jump to a random state\n\t     *   }\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    transitions: null,\n\t\n\t    /**\n\t     * Actions that are available to be called from each state\n\t     *\n\t     * state => [ action, action, ... ]\n\t     *\n\t     * - intro: [\n\t     *     'next'\n\t     *   ],\n\t     * - settings: [\n\t     *     'next',\n\t     *     'back'\n\t     *   ],\n\t     * - summary: [\n\t     *     'restart'\n\t     *     'finish',\n\t     *   ]\n\t     *\n\t     * Actions can also be expressed as wildcards\n\t     *\n\t     * - intro: [\n\t     *     '*' // any action is allowed from intro\n\t     *   ]\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    actions: null,\n\t\n\t    /**\n\t     * Handler functions that should be called on each action event / state change\n\t     *\n\t     * name.type => [ handler, handler, ... ]\n\t     *\n\t     * - next: {\n\t     *   - start: [\n\t     *       hideModal\n\t     *     ],\n\t     *   - end: [\n\t     *       showModal\n\t     *     ]\n\t     *   },\n\t     * - summary: {\n\t     *   - enter: [\n\t     *       resetForm\n\t     *     ],\n\t     *   - leave: [\n\t     *       validateForm,\n\t     *       postData,\n\t     *     ]\n\t     *   },\n\t     *   ...\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    handlers: null,\n\t\n\t    /**\n\t     * The current state\n\t     *\n\t     * @var {string}\n\t     */\n\t    state: '',\n\t\n\t    /**\n\t     * Any active Transition object that is driving the state change\n\t     *\n\t     * @var {Transition}\n\t     */\n\t    transition: null,\n\t\n\t    /**\n\t     * The scope in which to call all handlers\n\t     *\n\t     * @var {*}\n\t     */\n\t    scope: null,\n\t\n\t    /**\n\t     * The original config object\n\t     *\n\t     * @var {Object}\n\t     */\n\t    config: null,\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // private methods\n\t\n\t    /**\n\t     * Initialize the FSM with a config object\n\t     *\n\t     * @private\n\t     * @param config\n\t     */\n\t    initialize: function initialize(config) {\n\t        var _this = this;\n\t\n\t        // assign config\n\t        this.config = config;\n\t\n\t        // scope\n\t        if (config.scope) {\n\t            this.scope = config.scope;\n\t        }\n\t\n\t        // pre-process transitions\n\t        if (config.transitions) {\n\t            (function () {\n\t                var newError = function newError(tx, message) {\n\t                    return new Error('Invalid transition shorthand pattern \"' + tx + '\" - ' + message);\n\t                };\n\t\n\t                var add = function add(name, from, to) {\n\t                    transitions.push({ name: name, from: from, to: to });\n\t                };\n\t\n\t                var transitions = [];\n\t\n\t                config.transitions.map(function (tx) {\n\t                    // convert shorthand to objects\n\t                    if ((0, _utils.isString)(tx)) {\n\t                        (function () {\n\t                            // pre-process string\n\t                            tx = tx.replace(/([|=:<>])/g, ' $1 ').replace(/\\s+/g, ' ').replace(/^\\s+|\\s+$/g, '');\n\t\n\t                            // ensure string is valid\n\t                            if (!/^\\w+ [:|=] \\w[\\w ]*[<>] \\w[\\w ]*/.test(tx)) {\n\t                                throw newError(tx, 'cannot determine action and states');\n\t                            }\n\t\n\t                            // initialize variables\n\t                            var matches = tx.match(/([*\\w ]+|[<>])/g),\n\t                                action = matches.shift().replace(/\\s+/g, ''),\n\t                                stack = [],\n\t                                match = '',\n\t                                op = '',\n\t                                a = '',\n\t                                b = '';\n\t\n\t                            // process remaining tokens\n\t                            while (matches.length) {\n\t                                // get the next match\n\t                                match = matches.shift();\n\t                                if (/[<>]/.test(match)) {\n\t                                    op = match;\n\t                                } else {\n\t                                    match = match.match(/[*\\w]+/g);\n\t                                    match = match.length === 1 ? match[0] : match;\n\t                                    stack.push(match);\n\t                                }\n\t\n\t                                // process matches if stack is full\n\t                                if (stack.length === 2) {\n\t                                    var _ref2 = op === '<' ? [stack[1], stack[0]] : stack;\n\t\n\t                                    var _ref3 = _slicedToArray(_ref2, 2);\n\t\n\t                                    a = _ref3[0];\n\t                                    b = _ref3[1];\n\t\n\t                                    if (Array.isArray(a) && Array.isArray(b)) {\n\t                                        throw newError(tx, 'transitioning between 2 arrays doesn\\'t make sense');\n\t                                    }\n\t                                    if (Array.isArray(a)) {\n\t                                        a.map(function (a) {\n\t                                            return add(action, a, b);\n\t                                        });\n\t                                    } else if (Array.isArray(b)) {\n\t                                        b.map(function (b) {\n\t                                            return add(action, a, b);\n\t                                        });\n\t                                    } else {\n\t                                        add(action, a, b);\n\t                                    }\n\t\n\t                                    // once processed, shift the original\n\t                                    stack.shift();\n\t                                }\n\t                            }\n\t                        })();\n\t                    }\n\t\n\t                    // just add objects as-is\n\t                    else {\n\t                            transitions.push(tx);\n\t                        }\n\t                });\n\t\n\t                // pre-collate all states\n\t                transitions.map(function (tx) {\n\t                    [tx.from, tx.to].map(function (state) {\n\t                        return addState(_this, state);\n\t                    });\n\t                });\n\t\n\t                // initial state (must be done after\n\t                if (!config.initial) {\n\t                    config.initial = _this.states[0];\n\t                }\n\t\n\t                // add transitions\n\t                if (Array.isArray(transitions)) {\n\t                    transitions.map(function (transition) {\n\t                        _this.add(transition.name, transition.from, transition.to);\n\t                    });\n\t                }\n\t            })();\n\t        }\n\t\n\t        // add handlers\n\t        if (config.handlers) {\n\t            for (var name in config.handlers) {\n\t                if (config.handlers.hasOwnProperty(name)) {\n\t                    this.on(name, config.handlers[name]);\n\t                }\n\t            }\n\t        }\n\t\n\t        // start automatically unless defer is set to true\n\t        if (!config.defer) {\n\t            this.state = config.initial;\n\t        }\n\t\n\t        /**\n\t         * Sets defaults for various declarations\n\t         *\n\t         * @type {Object}\n\t         */\n\t        config.defaults = Object.assign({\n\t\n\t            // initialize event\n\t            initialize: 'initialize',\n\t\n\t            // handler defaults\n\t            action: 'start',\n\t            state: 'enter'\n\t\n\t        }, config.defaults);\n\t\n\t        /**\n\t         * Sets the default order to run transition callbacks in\n\t         *\n\t         * @type {string[]} type.target\n\t         */\n\t        config.order = config.order || ['action.*.start', 'action.{action}.start', 'state.{*}.{action}', 'state.{from}.{action}', 'state.{from}.leave', 'state.*.leave', 'state.*.enter', 'state.{to}.enter', 'action.{action}.end', 'action.*.end'];\n\t    },\n\t\n\t    /**\n\t     * Dispatch an event\n\t     *\n\t     * @param   {string}    namespace\n\t     * @param   {string}    type\n\t     * @param   {string}    key\n\t     * @param   {*}         value\n\t     * @returns {StateMachine}\n\t     */\n\t    update: function update(namespace, type) {\n\t        var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\t        var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\t\n\t        var signature = namespace + '.' + type;\n\t        var event = namespace === 'system' ? new _Events.SystemEvent(type, key, value) : new _Events.TransitionEvent(type);\n\t        this.dispatch(signature, event);\n\t        return this;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // api\n\t\n\t    /**\n\t     * Attempt to run an action, resulting in a transition to a state\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {*[]}       rest\n\t     * @returns {boolean}\n\t     */\n\t    do: function _do(action) {\n\t        if (this.can(action) && !this.isPaused()) {\n\t            for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                rest[_key - 1] = arguments[_key];\n\t            }\n\t\n\t            this.transition = _Transition2.default.create(this, action, rest);\n\t            if (action === this.config.defaults.initialize) {\n\t                this.update('system', 'initialize');\n\t            }\n\t            this.update('system', 'update', 'transition', this.transition);\n\t            this.transition.exec();\n\t            return true;\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Attempt to go to a state\n\t     *\n\t     * Finds if an appropriate transition exists, then calls the related action if it does\n\t     *\n\t     * @param   {string}    state\n\t     * @param   {boolean}   [force]\n\t     * @returns {boolean}\n\t     */\n\t    go: function go(state) {\n\t        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        if (this.has(state)) {\n\t            if (force) {\n\t                this.transition = _Transition2.default.force(this, state);\n\t                return this.end();\n\t            }\n\t            var action = this.getActionForState(state);\n\t            if (action) {\n\t                return this.do(action);\n\t            }\n\t            this.config.debug && console.info('No transition exists from \"%s\" to \"%s\"', this.state, state);\n\t        } else {\n\t            this.config.debug && console.warn('No such state \"%s\"', state);\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Query a transition to see if a named action is available\n\t     *\n\t     * @param   {string}    action\n\t     * @returns {boolean}\n\t     */\n\t    can: function can(action) {\n\t        if (!this.actions.has(action)) {\n\t            this.config.debug && console.warn('No such action \"%s\"', action);\n\t        }\n\t        return !!this.transitions.has(this.state, action);\n\t    },\n\t\n\t    /**\n\t     * Query a transition to see if a named action is unavailable\n\t     *\n\t     * @param   {string}    action\n\t     * @returns {boolean}\n\t     */\n\t    cannot: function cannot(action) {\n\t        return !this.can(action);\n\t    },\n\t\n\t    /**\n\t     * Test if the current state is the same as the supplied one\n\t     *\n\t     * @param   {string}    state       A state name to compare against the current state\n\t     * @returns {boolean}\n\t     */\n\t    is: function is(state) {\n\t        if (this.states.indexOf(state) === -1) {\n\t            this.config.debug && console.warn('No such state \"%s\"', state);\n\t        }\n\t        return state === this.state;\n\t    },\n\t\n\t    /**\n\t     * Test if a state exists\n\t     *\n\t     * @param   {string}    state\n\t     * @return  {boolean}\n\t     */\n\t    has: function has(state) {\n\t        return this.states.indexOf(state) !== -1;\n\t    },\n\t\n\t    /**\n\t     * Get the available \"to\" states for the current or supplied state\n\t     *\n\t     * @param   {string}    [state]     Optional name of a state to get states for. Defaults to the current state\n\t     * @returns {string[]}              An array of string states\n\t     */\n\t    getStatesFor: function getStatesFor() {\n\t        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\n\t        state = state || this.state;\n\t        var actions = this.getActionsFor(state, true);\n\t        return Object.keys(actions).map(function (name) {\n\t            return actions[name];\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Get the available actions (or actions and states) for the current or supplied state\n\t     *\n\t     * @param   {string}    [state]     Optional name of a state to get actions for. Defaults to the current state\n\t     * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n\t     * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n\t     */\n\t    getActionsFor: function getActionsFor() {\n\t        var _this2 = this;\n\t\n\t        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t        var asMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        state = state || this.state;\n\t        var actions = this.transitions.get(state || this.state);\n\t        if (asMap) {\n\t            var _ret3 = function () {\n\t                var states = {};\n\t                actions.map(function (action) {\n\t                    states[action] = _this2.actions.get(action + '.' + state);\n\t                });\n\t                return {\n\t                    v: states\n\t                };\n\t            }();\n\t\n\t            if ((typeof _ret3 === 'undefined' ? 'undefined' : _typeof(_ret3)) === \"object\") return _ret3.v;\n\t        } else {\n\t            return actions;\n\t        }\n\t    },\n\t\n\t    getActionForState: function getActionForState(state) {\n\t        if (this.has(state)) {\n\t            var actions = this.getActionsFor(state, true);\n\t            for (var action in actions) {\n\t                if (actions[action] === state) {\n\t                    return action;\n\t                }\n\t            }\n\t        }\n\t        return null;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // flags\n\t\n\t    /**\n\t     * Test if the FSM has started\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isStarted: function isStarted() {\n\t        return this.state !== '';\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is transitioning\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isTransitioning: function isTransitioning() {\n\t        return !!this.transition;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is paused (whilst transitioning)\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isPaused: function isPaused() {\n\t        return this.transition ? this.transition.paused : false;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is on the \"final\" state\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isComplete: function isComplete() {\n\t        return this.state === this.config.final;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // transitions\n\t\n\t    /**\n\t     * Pause any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    pause: function pause() {\n\t        if (this.transition && !this.isPaused()) {\n\t            this.transition.pause();\n\t            this.update('transition', 'pause');\n\t            this.update('system', 'update', 'pause', true);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Resume any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    resume: function resume() {\n\t        if (this.transition && this.isPaused()) {\n\t            this.update('transition', 'resume');\n\t            this.update('system', 'update', 'pause', false);\n\t            this.transition.resume();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Cancel any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    cancel: function cancel() {\n\t        if (this.transition) {\n\t            if (this.isPaused()) {\n\t                this.update('system', 'update', 'pause', false);\n\t            }\n\t            this.state = this.transition.from;\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('transition', 'cancel');\n\t            this.update('system', 'update', 'transition', null);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * End any current transition, skipping remaining handlers\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    end: function end() {\n\t        if (this.transition) {\n\t            if (this.isPaused()) {\n\t                this.update('system', 'update', 'pause', false);\n\t            }\n\t            this.state = this.transition.to;\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('system', 'change', 'state', this.state);\n\t            this.update('system', 'update', 'state', this.state);\n\t            if (this.isComplete()) {\n\t                this.update('system', 'complete');\n\t            }\n\t            this.update('system', 'update', 'transition', null);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Reset the FSM to the initial, or supplied, state\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    reset: function reset() {\n\t        var initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t\n\t        var state = initial || this.config.initial;\n\t        this.update('system', 'reset');\n\t        if (this.transition) {\n\t            if (this.isPaused()) {\n\t                this.update('system', 'update', 'pause', false);\n\t            }\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('transition', 'cancel');\n\t            this.update('system', 'update', 'transition', null);\n\t        }\n\t        if (this.state !== state) {\n\t            this.state = state;\n\t            this.update('system', 'change', 'state', this.state);\n\t            this.update('system', 'update', 'state', this.state);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // actions\n\t\n\t    /**\n\t     * Add a transition\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @return  {StateMachine}\n\t     */\n\t    add: function add(action, from, to) {\n\t        this.actions.set(action + '.' + from, to);\n\t        this.transitions.add(from, action);\n\t        addState(this, from);\n\t        addState(this, to);\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Remove a transition\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @return  {StateMachine}\n\t     */\n\t    remove: function remove(action, from, to) {\n\t        this.states.remove(action, from);\n\t        return this;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // handlers\n\t\n\t    /**\n\t     * Add an event handler\n\t     *\n\t     * Event handler signatures are build from the following grammar:\n\t     *\n\t     * - token      foo\n\t     * - property   .foo\n\t     * - event      :foo\n\t     * - action     @foo\n\t     * - targets    (foo|bar|baz)\n\t     *\n\t     * For example:\n\t     *\n\t     * - change\n\t     * - transition.pause\n\t     * - next:end\n\t     * - (a|b)@next\n\t     * - a@next\n\t     *\n\t     * The main event types are unique, so can be used without the namespace:\n\t     *\n\t     * - change\n\t     * - pause\n\t     * - complete\n\t     * - ...\n\t     *\n\t     * If your states and events are unique, they can also be used without qualification.\n\t     *\n\t     * See docs and demo for more information\n\t     *\n\t     * @param   {string}        id\n\t     * @param   {Function}      fn\n\t     * @return  {StateMachine}\n\t     */\n\t    on: function on(id, fn) {\n\t        var _this3 = this;\n\t\n\t        /** @type {ParseResult} */\n\t        var result = (0, _handlers.parse)(this, id);\n\t\n\t        if (this.config.debug) {\n\t            console.log('StateMachine on: ' + id, [result.namespace, result.type], result.paths);\n\t        }\n\t\n\t        result.paths.map(function (path, index) {\n\t            var target = result.targets[index];\n\t\n\t            // warn for invalid actions / states\n\t            if (target !== '*') {\n\t                if (result.namespace === 'state') {\n\t                    if (_this3.states.indexOf(target) === -1) {\n\t                        _this3.config.debug && console.warn('StateMachine: Warning assigning state.%s handler; no such state \"%s\"', result.type, target);\n\t                    }\n\t                } else if (result.namespace === 'action') {\n\t                    if (!_this3.actions.has(target)) {\n\t                        _this3.config.debug && console.warn('StateMachine: Warning assigning action.%s handler; no such action \"%s\"', result.type, target);\n\t                    }\n\t                }\n\t            }\n\t\n\t            // check handler is a function\n\t            if (!(0, _utils.isFunction)(fn)) {\n\t                throw new Error('Error assigning ' + result.namespace + '.' + result.type + ' handler; callback is not a Function', fn);\n\t            }\n\t\n\t            // assign\n\t            _this3.handlers.insert(path, fn);\n\t        });\n\t\n\t        return this;\n\t    },\n\t\n\t    off: function off(id, fn) {\n\t        var _this4 = this;\n\t\n\t        var result = (0, _handlers.parse)(this, id);\n\t        result.paths.map(function (path) {\n\t            _this4.handlers.remove(path, fn);\n\t        });\n\t    },\n\t\n\t    dispatch: function dispatch(path, event) {\n\t        var _this5 = this;\n\t\n\t        this.config.debug && console.info('StateMachine: dispatch \"%s\"', path);\n\t        var handlers = this.handlers.get(path);\n\t        if (handlers) {\n\t            handlers.map(function (fn) {\n\t                return fn(event, _this5);\n\t            });\n\t        }\n\t    }\n\t\n\t};\n\t\n\tfunction addState(fsm, state) {\n\t    if ((0, _utils.isString)(state) && fsm.states.indexOf(state) === -1) {\n\t        fsm.states.push(state);\n\t    }\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.values = exports.remove = exports.indexOf = exports.has = exports.get = exports.set = undefined;\n\texports.default = ValueMap;\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\t/**\n\t * Utility class to create, modify and delete nested hashes and values\n\t *\n\t * @constructor\n\t */\n\tfunction ValueMap(data) {\n\t    this.data = data || {};\n\t}\n\t\n\tValueMap.prototype = {\n\t    data: null,\n\t\n\t    set: function set(path, value) {\n\t        _set(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    add: function add(path, value) {\n\t        _add(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    insert: function insert(path, value) {\n\t        _insert(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    get: function get(path) {\n\t        return _get(this.data, path);\n\t    },\n\t\n\t    has: function has(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        return _has(this.data, path, value);\n\t    },\n\t\n\t    indexOf: function indexOf(path, value) {\n\t        return _indexOf(this.data, path, value);\n\t    },\n\t\n\t    remove: function remove(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        _remove(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    keys: function keys(path) {\n\t        return Object.keys(_get(this.data, path));\n\t    },\n\t\n\t    values: function values(path) {\n\t        return _values(this.data, path);\n\t    }\n\t\n\t};\n\t\n\tfunction create(obj, keys) {\n\t    var key = void 0;\n\t    while (keys.length) {\n\t        key = keys.shift();\n\t        if (!(0, _utils.isObject)(obj[key])) {\n\t            obj[key] = {};\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    return obj;\n\t}\n\t\n\tfunction _set(obj, path, value) {\n\t    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n\t\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    obj[key] = value;\n\t}\n\t\n\texports.set = _set;\n\tfunction _add(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    obj[key].push(value);\n\t}\n\t\n\tfunction _insert(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    var parent = obj[key],\n\t        index = parent.indexOf(value);\n\t    if (index === -1) {\n\t        parent.push(value);\n\t    } else {\n\t        parent[index] = value;\n\t    }\n\t}\n\t\n\tfunction _get(obj, path) {\n\t    if ((0, _utils.isUndefined)(path) || path == '') {\n\t        return obj;\n\t    }\n\t\n\t    var key = void 0,\n\t        keys = String(path).split('.');\n\t    while (keys.length > 1) {\n\t        key = keys.shift();\n\t        if (!obj.hasOwnProperty(key)) {\n\t            return;\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    key = keys.shift();\n\t    return obj[key];\n\t}\n\t\n\texports.get = _get;\n\tfunction _has(obj, path, value) {\n\t    var parent = _get(obj, path);\n\t    return !!((0, _utils.isArray)(parent) && (0, _utils.isDefined)(value) ? parent.indexOf(value) !== -1 : (0, _utils.isUndefined)(value) ? (0, _utils.isDefined)(parent) : parent === value);\n\t}\n\t\n\texports.has = _has;\n\tfunction _indexOf(obj, path, value) {\n\t    var arr = _get(obj, path);\n\t    if ((0, _utils.isArray)(arr)) {\n\t        return arr.indexOf(value);\n\t    }\n\t    return -1;\n\t}\n\t\n\texports.indexOf = _indexOf;\n\tfunction _remove(obj, path, value) {\n\t    var parent = obj,\n\t        keys = String(path || '').split('.'),\n\t        key = keys.pop();\n\t\n\t    if (keys.length) {\n\t        parent = _get(obj, keys.join('.'));\n\t    }\n\t    if ((0, _utils.isDefined)(value) && (0, _utils.isArray)(parent[key])) {\n\t        var target = parent[key];\n\t        var index = target.indexOf(value);\n\t        if (index > -1) {\n\t            target.splice(index, 1);\n\t            if (target.length === 0) {\n\t                delete parent[key];\n\t            }\n\t            return true;\n\t        }\n\t        return false;\n\t    } else {\n\t        if ((0, _utils.isObject)(parent) && obj.hasOwnProperty(key)) {\n\t            delete parent[key];\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\t\n\texports.remove = _remove;\n\tfunction _values(obj, path) {\n\t    var values = [];\n\t    var target = _get(obj, path);\n\t    if ((0, _utils.isObject)(target)) {\n\t        for (var name in target) {\n\t            if (target.hasOwnProperty(name)) {\n\t                values.push(target[name]);\n\t            }\n\t        }\n\t    }\n\t    return values;\n\t}\n\texports.values = _values;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.isObject = isObject;\n\texports.isArray = isArray;\n\texports.isString = isString;\n\texports.isFunction = isFunction;\n\texports.isDefined = isDefined;\n\texports.isUndefined = isUndefined;\n\texports.trim = trim;\n\tfunction isObject(value) {\n\t    return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\t\n\tfunction isArray(value) {\n\t    return value instanceof Array;\n\t}\n\t\n\tfunction isString(value) {\n\t    return typeof value === 'string';\n\t}\n\t\n\tfunction isFunction(value) {\n\t    return value instanceof Function;\n\t}\n\t\n\tfunction isDefined(value) {\n\t    return typeof value !== 'undefined';\n\t}\n\t\n\tfunction isUndefined(value) {\n\t    return typeof value === 'undefined';\n\t}\n\t\n\tfunction trim(value) {\n\t    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _Events = __webpack_require__(4);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\t/**\n\t * Transition class\n\t *\n\t * Responsible for managing events in the flow from state to state.\n\t *\n\t * This adds all handlers for the current action start/end and state from/to to an array:\n\t *\n\t * - <namespace>.<target>.<type>[]\n\t *\n\t * So going from state \"a\" to state \"b\" with action \"next\" should build:\n\t *\n\t * - action.*.start[]\n\t * - action.next.start[]\n\t * - state.a.leave[]\n\t * - state.*.leave[]\n\t * - state.*.enter[]\n\t * - state.b.enter[]\n\t * - action.next.end[]\n\t * - action.*.end[]\n\t *\n\t * This can be changed by passing in an order array in fsm.config\n\t *\n\t * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n\t *\n\t * From a callback, you can:\n\t *\n\t * - return false to cancel the transition\n\t * - return true to pause the transition\n\t * - not return a value (the transition continues)\n\t *\n\t * Transitions can also be paused, resumed, or cancelled by calling\n\t * the appropriate method on, or from:\n\t *\n\t * - the event\n\t * - the transition\n\t * - the state machine\n\t *\n\t * Cancelled transitions will reset the FSM to the previous \"from\" state\n\t *\n\t * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          action\n\t * @param {string}          from\n\t * @param {string}          to\n\t */\n\tfunction Transition(fsm, action, from, to) {\n\t    this.fsm = fsm;\n\t    this.action = action;\n\t    this.from = from;\n\t    this.to = to;\n\t    this.clear();\n\t}\n\t\n\t/**\n\t * @prop {StateMachine}    fsm\n\t * @prop {string}          action\n\t * @prop {string}          from\n\t * @prop {string}          to\n\t * @prop {Function[]}      handlers\n\t */\n\tTransition.prototype = {\n\t    fsm: null,\n\t    action: '',\n\t    from: '',\n\t    to: '',\n\t    paused: false,\n\t    handlers: null,\n\t\n\t    clear: function clear() {\n\t        this.paused = false;\n\t        this.handlers = [];\n\t    },\n\t\n\t    /**\n\t     * Execute the next event's callbacks\n\t     * @returns {*}\n\t     */\n\t    exec: function exec() {\n\t        if (!this.paused) {\n\t            if (this.handlers.length) {\n\t                var handler = this.handlers.shift();\n\t                var state = handler();\n\t                if (state === false) {\n\t                    return this.fsm.cancel();\n\t                }\n\t                if (state === true) {\n\t                    return this.fsm.pause();\n\t                }\n\t                this.exec();\n\t            } else {\n\t                this.fsm.end();\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t\n\t    pause: function pause() {\n\t        this.paused = true;\n\t        return this;\n\t    },\n\t\n\t    resume: function resume() {\n\t        this.paused = false;\n\t        return this.exec();\n\t    }\n\t};\n\t\n\texports.default = {\n\t    /**\n\t     * Create the Transition object\n\t     *\n\t     * - Set up variables, and queue\n\t     * - Determine paths to relevant handlers\n\t     * - Build State and Action Event objects\n\t     * - Pre-bind all handlers\n\t     * - Append to queue\n\t     *\n\t     * @param {StateMachine}    fsm\n\t     * @param {string}          action\n\t     * @param {Array}           params\n\t     * @returns {Transition}\n\t     */\n\t    create: function create(fsm, action, params) {\n\t        // transition properties\n\t        var scope = fsm.scope;\n\t        var from = fsm.state;\n\t        var to = fsm.actions.get(action)[from];\n\t        var vars = { action: action, to: to, from: from };\n\t\n\t        // handle \"to\" being a function\n\t        if ((0, _utils.isFunction)(to)) {\n\t            to = to.apply(scope, params);\n\t            if (fsm.states.indexOf(to) === -1) {\n\t                throw new Error('Invalid \"to\" state \"' + to + '\"');\n\t            }\n\t        }\n\t\n\t        // transition\n\t        var queue = [];\n\t        var transition = new Transition(fsm, action, from, to);\n\t\n\t        // build handlers array\n\t        fsm.config.order.map(function (path) {\n\t            // replace path tokens\n\t            path = path.replace(/{(\\w+)}/g, function (all, token) {\n\t                return vars[token];\n\t            });\n\t            var handlers = fsm.handlers.get(path);\n\t\n\t            // do it!\n\t            if (handlers) {\n\t                (function () {\n\t                    var _path$split = path.split('.');\n\t\n\t                    var _path$split2 = _slicedToArray(_path$split, 3);\n\t\n\t                    var namespace = _path$split2[0];\n\t                    var target = _path$split2[1];\n\t                    var type = _path$split2[2];\n\t\n\t                    handlers = handlers.map(function (handler) {\n\t                        // build event object\n\t                        var Event = namespace === 'state' ? _Events.StateEvent : _Events.ActionEvent;\n\t                        var event = new Event(type, target, transition);\n\t\n\t                        // pre-bind handlers, scopes and params\n\t                        // this way scope and params don't need to be passed around\n\t                        // and the call from Transition is always just `value = handler()`\n\t                        return function () {\n\t                            return handler.apply(scope, [event, fsm].concat(params));\n\t                        };\n\t                    });\n\t\n\t                    // add to queue\n\t                    queue = queue.concat(handlers);\n\t                })();\n\t            }\n\t        });\n\t\n\t        // return\n\t        transition.handlers = queue;\n\t        return transition;\n\t    },\n\t\n\t    force: function force(fsm, state) {\n\t        var transition = new Transition(fsm, '', fsm.state, state);\n\t        transition.paused = fsm.transition ? fsm.transition.paused : false;\n\t        return transition;\n\t    }\n\t\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ActionEvent = ActionEvent;\n\texports.StateEvent = StateEvent;\n\texports.SystemEvent = SystemEvent;\n\texports.TransitionEvent = TransitionEvent;\n\t// ------------------------------------------------------------------------------------------------\n\t// setup\n\t\n\t/**\n\t * @prop {string}       namespace   The Event namespace; i.e. state or action\n\t * @prop {string}       type        The Event type;      i.e. leave/enter (state) or start/end (action)\n\t * @prop {string}       target      The Event target;    i.e. intro (state), next (action), or * (all states or types)\n\t * @prop {Transition}   transition  The transition which generated the event\n\t */\n\tvar event = {\n\t    // properties\n\t    namespace: null,\n\t    type: null,\n\t    target: null,\n\t    transition: null\n\t};\n\t\n\tfunction initialize(event, namespace, type, target, transition) {\n\t    event.namespace = namespace;\n\t    event.type = type;\n\t    event.target = target;\n\t    event.transition = transition;\n\t}\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// ActionEvent\n\t\n\tfunction ActionEvent(type, target, transition) {\n\t    initialize(this, 'action', type, target, transition);\n\t}\n\tActionEvent.prototype = event;\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// StateEvent\n\t\n\tfunction StateEvent(type, target, transition) {\n\t    initialize(this, 'state', type, target, transition);\n\t}\n\tStateEvent.prototype = event;\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// SystemEvent\n\t\n\tfunction SystemEvent(type, key, value) {\n\t    this.type = type;\n\t    this.key = key;\n\t    this.value = value;\n\t}\n\t\n\tSystemEvent.prototype = {\n\t    namespace: 'system',\n\t    type: '',\n\t    key: '',\n\t    value: null\n\t};\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// TransitionEvent\n\t\n\tfunction TransitionEvent(type) {\n\t    this.type = type;\n\t}\n\t\n\tTransitionEvent.prototype = {\n\t    namespace: 'transition',\n\t    type: ''\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.parse = parse;\n\tvar lookup = {\n\t    namespaces: {\n\t        start: 'system',\n\t        change: 'system',\n\t        update: 'system',\n\t        complete: 'system',\n\t        reset: 'system',\n\t        add: 'system',\n\t        remove: 'system',\n\t\n\t        pause: 'transition',\n\t        resume: 'transition',\n\t        cancel: 'transition'\n\t    },\n\t\n\t    events: {\n\t        start: 'action',\n\t        end: 'action',\n\t        enter: 'state',\n\t        leave: 'state'\n\t    }\n\t};\n\t\n\t/**\n\t * Parses an event handler id into namespace, type, and target variables\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          id\n\t * @return {ParseResult}\n\t */\n\tfunction parse(fsm, id) {\n\t    // variables\n\t    var defaults = fsm.config.defaults,\n\t        segments = void 0,\n\t        namespace = void 0,\n\t        type = void 0,\n\t        targets = void 0;\n\t\n\t    // utility functions\n\t    function isState(value) {\n\t        return fsm.states.indexOf(value) !== -1;\n\t    }\n\t\n\t    function isAction(value) {\n\t        return fsm.actions.has(value);\n\t    }\n\t\n\t    function getTargets(value) {\n\t        return value ? value.match(/\\w[-\\w]*/g) : ['*'];\n\t    }\n\t\n\t    function determineValue(value) {\n\t\n\t        // is namespace, i.e. system, transition, state, action\n\t        if (/^(system|transition|state|action)$/.test(value)) {\n\t            namespace = value;\n\t        }\n\t\n\t        // is shortcut, i.e. update, change, pause, cancel\n\t        else if (value in lookup.namespaces) {\n\t                namespace = lookup.namespaces[value];\n\t                type = value;\n\t            }\n\t\n\t            // is state or action, i.e. a, next\n\t            else if (isState(value) || isAction(value)) {\n\t                    if (!namespace) {\n\t                        namespace = isState(value) ? 'state' : 'action';\n\t                    }\n\t\n\t                    // special case for state with action\n\t                    if (namespace === 'state' && isAction(value)) {\n\t                        type = value;\n\t                    }\n\t\n\t                    if (!targets) {\n\t                        targets = getTargets(value);\n\t                    }\n\t                }\n\t\n\t                // action event, i.e. :event\n\t                else if (/^(enter|leave)$/.test(value)) {\n\t                        type = value;\n\t                    }\n\t    }\n\t\n\t    // process\n\t    segments = id.match(/:\\w+|@\\w+|\\(.+?\\)|\\.\\w+|\\w+/g);\n\t\n\t    // return an empty result if no matches\n\t    if (!segments) {\n\t        return new ParseResult();\n\t    }\n\t\n\t    /**\n\t     * This is the engine of the parse process\n\t     *\n\t     * The regex above matches the grammar of the expression into an array:\n\t     *\n\t     * - transition.pause   => [\"transition\", \".pause\"]\n\t     * - (a|b)@next         => [\"(a|b)\", \"@next\"]\n\t     * - a@next             => [\"a\", \"@next\"]\n\t     *\n\t     * Each segment is then analysed for its type and content, either directly\n\t     * or via the utility functions above which update the local variables.\n\t     */\n\t    segments.forEach(function (segment, i, segments) {\n\t        // variables\n\t        var char = segment[0];\n\t        var values = segment.match(/\\w+/g);\n\t        var value = values[0];\n\t        switch (char) {\n\t            // event\n\t            case ':':\n\t                namespace = lookup.events[value];\n\t                type = value;\n\t                break;\n\t\n\t            // action\n\t            case '@':\n\t                namespace = 'state';\n\t                type = value;\n\t                break;\n\t\n\t            // targets\n\t            case '(':\n\t                targets = values;\n\t                namespace = isState(values[0]) ? 'state' : 'action';\n\t                break;\n\t\n\t            // property\n\t            case '.':\n\t                determineValue(value);\n\t                break;\n\t\n\t            // single word\n\t            default:\n\t                determineValue(segment);\n\t        }\n\t    });\n\t\n\t    // final determination\n\t    if (!targets) {\n\t        targets = getTargets();\n\t    }\n\t\n\t    if (!namespace) {\n\t        namespace = isState(targets[0]) ? 'state' : 'action';\n\t    }\n\t\n\t    if (!type) {\n\t        type = defaults[namespace];\n\t    }\n\t\n\t    // return result\n\t    return new ParseResult(namespace, type, targets);\n\t}\n\t\n\tfunction ParseResult(namespace, type, targets) {\n\t    if (namespace) {\n\t        this.namespace = namespace;\n\t        this.type = type;\n\t        this.targets = targets;\n\t        this.paths = targets.map(function (target) {\n\t            return namespace === 'action' || namespace === 'state' ? [namespace, target, type].join('.') : namespace + '.' + type;\n\t        });\n\t    }\n\t}\n\t\n\tParseResult.prototype = {\n\t    namespace: '',\n\t    type: '',\n\t    targets: [],\n\t    paths: []\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** state-machine.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap ba481e3156a1f21e1817\n **/","import ValueMap from './utils/ValueMap';\nimport Transition from './Transition';\nimport { SystemEvent, TransitionEvent } from './Events';\nimport { isString, isFunction } from './utils/utils';\nimport { parse } from './utils/handlers'\n\nexport default function StateMachine (scope, config)\n{\n    // allow [scope, config] or [config] as parameters\n    if(arguments.length == 1)\n    {\n        [config, scope] = [scope, null];\n    }\n\n    // assignment\n    this.scope          = scope;\n    this.state          = '';\n    this.states         = [];\n    this.transitions    = new ValueMap();\n    this.actions        = new ValueMap();\n    this.handlers       = new ValueMap();\n\n    // initialize\n    if(config)\n    {\n        this.initialize(config);\n    }\n}\n\nStateMachine.parse = parse;\n\n/**\n * StateMachine prototype\n *\n * The property examples below illustrate a 4-state machine, with states:\n *\n * - intro > settings > summary > end\n *\n * And actions:\n *\n * - back | next | restart | finish\n */\nStateMachine.prototype =\n{\n    // ------------------------------------------------------------------------------------------------\n    // properties\n\n        /**\n         * Available state names\n         *\n         * - [\n         *     intro,\n         *     settings,\n         *     summary,\n         *     final\n         *   ]\n         *\n         * @var {string[]}\n         */\n        states      : null,\n\n        /**\n         * Available transitions for each action\n         *\n         * action.from => to\n         *\n         * - next: {\n         *     intro: settings,\n         *     settings: summary\n         *   },\n         * - back: {\n         *     settings: intro\n         *   },\n         * - restart: {\n         *     summary:intro\n         *   },\n         * - finish: {\n         *     summary:final\n         *   },\n         *\n         * Transitions can also be functions\n         *\n         * - next: {\n         *     intro: function() { return '<random state>' } // jump to a random state\n         *   }\n         *\n         * @var {ValueMap}\n         */\n        transitions : null,\n\n        /**\n         * Actions that are available to be called from each state\n         *\n         * state => [ action, action, ... ]\n         *\n         * - intro: [\n         *     'next'\n         *   ],\n         * - settings: [\n         *     'next',\n         *     'back'\n         *   ],\n         * - summary: [\n         *     'restart'\n         *     'finish',\n         *   ]\n         *\n         * Actions can also be expressed as wildcards\n         *\n         * - intro: [\n         *     '*' // any action is allowed from intro\n         *   ]\n         *\n         * @var {ValueMap}\n         */\n        actions     : null,\n\n        /**\n         * Handler functions that should be called on each action event / state change\n         *\n         * name.type => [ handler, handler, ... ]\n         *\n         * - next: {\n         *   - start: [\n         *       hideModal\n         *     ],\n         *   - end: [\n         *       showModal\n         *     ]\n         *   },\n         * - summary: {\n         *   - enter: [\n         *       resetForm\n         *     ],\n         *   - leave: [\n         *       validateForm,\n         *       postData,\n         *     ]\n         *   },\n         *   ...\n         *\n         * @var {ValueMap}\n         */\n        handlers    : null,\n\n        /**\n         * The current state\n         *\n         * @var {string}\n         */\n        state       : '',\n\n        /**\n         * Any active Transition object that is driving the state change\n         *\n         * @var {Transition}\n         */\n        transition  : null,\n\n        /**\n         * The scope in which to call all handlers\n         *\n         * @var {*}\n         */\n        scope       : null,\n\n        /**\n         * The original config object\n         *\n         * @var {Object}\n         */\n        config      : null,\n\n\n    // ------------------------------------------------------------------------------------------------\n    // private methods\n\n        /**\n         * Initialize the FSM with a config object\n         *\n         * @private\n         * @param config\n         */\n        initialize:function (config)\n        {\n            // assign config\n            this.config     = config;\n\n            // scope\n            if(config.scope)\n            {\n                this.scope = config.scope;\n            }\n\n            // pre-process transitions\n            if(config.transitions)\n            {\n                let transitions = [];\n\n                function newError(tx, message)\n                {\n                    return new Error('Invalid transition shorthand pattern \"' +tx+ '\" - ' + message);\n                }\n\n                function add(name, from, to)\n                {\n                    transitions.push({name, from, to});\n                }\n\n                config.transitions.map( tx =>\n                {\n                    // convert shorthand to objects\n                    if(isString(tx))\n                    {\n                        // pre-process string\n                        tx = tx\n                            .replace(/([|=:<>])/g, ' $1 ')\n                            .replace(/\\s+/g, ' ')\n                            .replace(/^\\s+|\\s+$/g,'');\n\n                        // ensure string is valid\n                        if(!/^\\w+ [:|=] \\w[\\w ]*[<>] \\w[\\w ]*/.test(tx))\n                        {\n                            throw newError(tx, 'cannot determine action and states');\n                        }\n\n                        // initialize variables\n                        let matches = tx.match(/([*\\w ]+|[<>])/g),\n                            action  = matches.shift().replace(/\\s+/g, ''),\n                            stack   = [],\n                            match   = '',\n                            op      = '',\n                            a       = '',\n                            b       = '';\n\n                        // process remaining tokens\n                        while(matches.length)\n                        {\n                            // get the next match\n                            match = matches.shift();\n                            if(/[<>]/.test(match))\n                            {\n                                op = match;\n                            }\n                            else\n                            {\n                                match = match.match(/[*\\w]+/g);\n                                match = match.length === 1 ? match[0] : match;\n                                stack.push(match);\n                            }\n\n                            // process matches if stack is full\n                            if(stack.length === 2)\n                            {\n                                [a, b] = op === '<'\n                                    ? [stack[1], stack[0]]\n                                    : stack;\n                                if(Array.isArray(a) && Array.isArray(b))\n                                {\n                                    throw newError(tx, 'transitioning between 2 arrays doesn\\'t make sense');\n                                }\n                                if(Array.isArray(a))\n                                {\n                                    a.map( a => add(action, a, b) );\n                                }\n                                else if(Array.isArray(b))\n                                {\n                                    b.map( b => add(action, a, b) );\n                                }\n                                else\n                                {\n                                    add(action, a, b);\n                                }\n\n                                // once processed, shift the original\n                                stack.shift();\n                            }\n\n                        }\n                    }\n\n                    // just add objects as-is\n                    else\n                    {\n                        transitions.push(tx);\n                    }\n                });\n\n                // pre-collate all states\n                transitions.map( tx =>\n                {\n                    [tx.from, tx.to].map( state => addState(this, state) );\n                });\n\n                // initial state (must be done after\n                if( ! config.initial )\n                {\n                    config.initial = this.states[0];\n                }\n\n                // add transitions\n                if(Array.isArray(transitions))\n                {\n                    transitions.map( transition =>\n                    {\n                        this.add(transition.name, transition.from, transition.to);\n                    });\n                }\n            }\n\n            // add handlers\n            if(config.handlers)\n            {\n                for(let name in config.handlers)\n                {\n                    if(config.handlers.hasOwnProperty(name))\n                    {\n                        this.on(name, config.handlers[name]);\n                    }\n                }\n            }\n\n            // start automatically unless defer is set to true\n            if( ! config.defer )\n            {\n                this.state = config.initial;\n            }\n\n            /**\n             * Sets defaults for various declarations\n             *\n             * @type {Object}\n             */\n            config.defaults = Object.assign({\n\n                // initialize event\n                initialize  :'initialize',\n\n                // handler defaults\n                action      :'start',\n                state       :'enter'\n\n            }, config.defaults);\n\n            /**\n             * Sets the default order to run transition callbacks in\n             *\n             * @type {string[]} type.target\n             */\n            config.order = config.order ||\n            [\n                'action.*.start',\n                'action.{action}.start',\n                'state.{*}.{action}',\n                'state.{from}.{action}',\n                'state.{from}.leave',\n                'state.*.leave',\n                'state.*.enter',\n                'state.{to}.enter',\n                'action.{action}.end',\n                'action.*.end'\n            ];\n        },\n\n        /**\n         * Dispatch an event\n         *\n         * @param   {string}    namespace\n         * @param   {string}    type\n         * @param   {string}    key\n         * @param   {*}         value\n         * @returns {StateMachine}\n         */\n        update: function (namespace, type, key = '', value = null)\n        {\n            let signature = namespace + '.' + type;\n            let event = namespace === 'system'\n                ? new SystemEvent(type, key, value)\n                : new TransitionEvent(type);\n            this.dispatch(signature, event);\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // api\n\n        /**\n         * Attempt to run an action, resulting in a transition to a state\n         *\n         * @param   {string}    action\n         * @param   {*[]}       rest\n         * @returns {boolean}\n         */\n        do: function (action, ...rest)\n        {\n            if(this.can(action) && !this.isPaused())\n            {\n                this.transition = Transition.create(this, action, rest);\n                if(action === this.config.defaults.initialize)\n                {\n                    this.update('system', 'initialize');\n                }\n                this.update('system', 'update', 'transition', this.transition);\n                this.transition.exec();\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Attempt to go to a state\n         *\n         * Finds if an appropriate transition exists, then calls the related action if it does\n         *\n         * @param   {string}    state\n         * @param   {boolean}   [force]\n         * @returns {boolean}\n         */\n        go: function (state, force = false)\n        {\n            if(this.has(state))\n            {\n                if(force)\n                {\n                    this.transition = Transition.force(this, state);\n                    return this.end();\n                }\n                var action = this.getActionForState(state);\n                if(action)\n                {\n                    return this.do(action);\n                }\n                this.config.debug && console.info('No transition exists from \"%s\" to \"%s\"', this.state, state);\n            }\n            else\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n            }\n            return false;\n        },\n\n        /**\n         * Query a transition to see if a named action is available\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        can: function (action)\n        {\n            if( ! this.actions.has(action) )\n            {\n                this.config.debug && console.warn('No such action \"%s\"', action);\n            }\n            return !! this.transitions.has(this.state, action);\n        },\n\n        /**\n         * Query a transition to see if a named action is unavailable\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        cannot: function (action)\n        {\n            return ! this.can(action);\n        },\n\n        /**\n         * Test if the current state is the same as the supplied one\n         *\n         * @param   {string}    state       A state name to compare against the current state\n         * @returns {boolean}\n         */\n        is: function (state)\n        {\n            if(this.states.indexOf(state) === -1)\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n            }\n            return state === this.state;\n        },\n\n        /**\n         * Test if a state exists\n         *\n         * @param   {string}    state\n         * @return  {boolean}\n         */\n        has: function(state)\n        {\n            return this.states.indexOf(state) !== -1;\n        },\n\n        /**\n         * Get the available \"to\" states for the current or supplied state\n         *\n         * @param   {string}    [state]     Optional name of a state to get states for. Defaults to the current state\n         * @returns {string[]}              An array of string states\n         */\n        getStatesFor: function (state = null)\n        {\n            state       = state || this.state;\n            let actions = this.getActionsFor(state, true);\n            return Object.keys(actions).map( name => actions[name] );\n        },\n\n        /**\n         * Get the available actions (or actions and states) for the current or supplied state\n         *\n         * @param   {string}    [state]     Optional name of a state to get actions for. Defaults to the current state\n         * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n         * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n         */\n        getActionsFor: function (state = '', asMap = false)\n        {\n            state       = state || this.state;\n            let actions = this.transitions.get(state || this.state);\n            if(asMap)\n            {\n                let states  = {};\n                actions.map( action =>\n                {\n                    states[action] = this.actions.get(action + '.' + state);\n                });\n                return states;\n            }\n            else\n            {\n                return actions;\n            }\n        },\n\n        getActionForState: function (state)\n        {\n            if(this.has(state))\n            {\n                let actions = this.getActionsFor(state, true);\n                for(let action in actions)\n                {\n                    if(actions[action] === state)\n                    {\n                        return action;\n                    }\n                }\n            }\n            return null;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // flags\n\n        /**\n         * Test if the FSM has started\n         *\n         * @returns {boolean}\n         */\n        isStarted: function ()\n        {\n            return this.state !== '';\n        },\n\n        /**\n         * Test if the FSM is transitioning\n         *\n         * @returns {boolean}\n         */\n        isTransitioning: function ()\n        {\n            return !! this.transition;\n        },\n\n        /**\n         * Test if the FSM is paused (whilst transitioning)\n         *\n         * @returns {boolean}\n         */\n        isPaused: function ()\n        {\n            return this.transition\n                ? this.transition.paused\n                : false;\n        },\n\n        /**\n         * Test if the FSM is on the \"final\" state\n         *\n         * @returns {boolean}\n         */\n        isComplete: function ()\n        {\n            return this.state === this.config.final;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // transitions\n\n        /**\n         * Pause any current transition\n         *\n         * @returns {StateMachine}\n         */\n        pause: function ()\n        {\n            if(this.transition && !this.isPaused())\n            {\n                this.transition.pause();\n                this.update('transition', 'pause');\n                this.update('system', 'update', 'pause', true);\n            }\n            return this;\n        },\n\n        /**\n         * Resume any current transition\n         *\n         * @returns {StateMachine}\n         */\n        resume: function ()\n        {\n            if(this.transition && this.isPaused())\n            {\n                this.update('transition', 'resume');\n                this.update('system', 'update', 'pause', false);\n                this.transition.resume();\n            }\n            return this;\n        },\n\n        /**\n         * Cancel any current transition\n         *\n         * @returns {StateMachine}\n         */\n        cancel: function ()\n        {\n            if(this.transition)\n            {\n                if(this.isPaused())\n                {\n                    this.update('system', 'update', 'pause', false);\n                }\n                this.state = this.transition.from;\n                this.transition.clear();\n                delete this.transition;\n                this.update('transition', 'cancel');\n                this.update('system', 'update', 'transition', null);\n            }\n            return this;\n        },\n\n        /**\n         * End any current transition, skipping remaining handlers\n         *\n         * @returns {StateMachine}\n         */\n        end: function ()\n        {\n            if(this.transition)\n            {\n                if(this.isPaused())\n                {\n                    this.update('system', 'update', 'pause', false);\n                }\n                this.state = this.transition.to;\n                this.transition.clear();\n                delete this.transition;\n                this.update('system', 'change', 'state', this.state);\n                this.update('system', 'update', 'state', this.state);\n                if(this.isComplete())\n                {\n                    this.update('system', 'complete');\n                }\n                this.update('system', 'update', 'transition', null);\n            }\n            return this;\n        },\n\n        /**\n         * Reset the FSM to the initial, or supplied, state\n         *\n         * @returns {StateMachine}\n         */\n        reset:function(initial = '')\n        {\n            let state = initial || this.config.initial;\n            this.update('system', 'reset');\n            if(this.transition)\n            {\n                if(this.isPaused())\n                {\n                    this.update('system', 'update', 'pause', false);\n                }\n                this.transition.clear();\n                delete this.transition;\n                this.update('transition', 'cancel');\n                this.update('system', 'update', 'transition', null);\n            }\n            if(this.state !== state)\n            {\n                this.state = state;\n                this.update('system', 'change', 'state', this.state);\n                this.update('system', 'update', 'state', this.state);\n            }\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // actions\n\n        /**\n         * Add a transition\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        add: function (action, from, to)\n        {\n            this.actions.set(action + '.' + from, to);\n            this.transitions.add(from, action);\n            addState(this, from);\n            addState(this, to);\n            return this;\n        },\n\n        /**\n         * Remove a transition\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        remove: function (action, from, to)\n        {\n            this.states.remove(action, from);\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // handlers\n\n        /**\n         * Add an event handler\n         *\n         * Event handler signatures are build from the following grammar:\n         *\n         * - token      foo\n         * - property   .foo\n         * - event      :foo\n         * - action     @foo\n         * - targets    (foo|bar|baz)\n         *\n         * For example:\n         *\n         * - change\n         * - transition.pause\n         * - next:end\n         * - (a|b)@next\n         * - a@next\n         *\n         * The main event types are unique, so can be used without the namespace:\n         *\n         * - change\n         * - pause\n         * - complete\n         * - ...\n         *\n         * If your states and events are unique, they can also be used without qualification.\n         *\n         * See docs and demo for more information\n         *\n         * @param   {string}        id\n         * @param   {Function}      fn\n         * @return  {StateMachine}\n         */\n        on: function (id, fn)\n        {\n            /** @type {ParseResult} */\n            let result = parse(this, id);\n\n            if(this.config.debug)\n            {\n                console.log('StateMachine on: ' + id, [result.namespace, result.type], result.paths)\n            }\n\n            result.paths.map( (path, index) =>\n            {\n                let target = result.targets[index];\n\n                // warn for invalid actions / states\n                if(target !== '*')\n                {\n                    if(result.namespace === 'state')\n                    {\n                        if(this.states.indexOf(target) === -1)\n                        {\n                            this.config.debug && console.warn('StateMachine: Warning assigning state.%s handler; no such state \"%s\"', result.type, target);\n                        }\n                    }\n                    else if(result.namespace === 'action')\n                    {\n                        if(!this.actions.has(target))\n                        {\n                            this.config.debug && console.warn('StateMachine: Warning assigning action.%s handler; no such action \"%s\"', result.type, target);\n                        }\n                    }\n                }\n\n                // check handler is a function\n                if(!isFunction(fn))\n                {\n                    throw new Error('Error assigning ' +result.namespace+ '.' +result.type+ ' handler; callback is not a Function', fn);\n                }\n\n                // assign\n                this.handlers.insert(path, fn);\n            });\n\n            return this;\n        },\n\n        off: function (id, fn)\n        {\n            let result = parse(this, id);\n            result.paths.map( path =>\n            {\n                this.handlers.remove(path, fn)\n            });\n        },\n\n        dispatch: function(path, event)\n        {\n            this.config.debug && console.info('StateMachine: dispatch \"%s\"', path);\n            let handlers = this.handlers.get(path);\n            if(handlers)\n            {\n                handlers.map(fn => fn(event, this) );\n            }\n        }\n\n};\n\nfunction addState (fsm, state)\n{\n    if (isString(state) && fsm.states.indexOf(state) === -1)\n    {\n        fsm.states.push(state);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/StateMachine.js\n **/","import {isObject, isArray, isDefined, isUndefined} from './utils';\n\n/**\n * Utility class to create, modify and delete nested hashes and values\n *\n * @constructor\n */\nexport default function ValueMap (data)\n{\n    this.data = data || {};\n}\n\nValueMap.prototype =\n{\n    data: null,\n\n    set: function (path, value)\n    {\n        set(this.data, path, value);\n        return this;\n    },\n\n    add:function(path, value)\n    {\n        add(this.data, path, value);\n        return this;\n    },\n\n    insert:function(path, value)\n    {\n        insert(this.data, path, value);\n        return this;\n    },\n\n    get:function(path)\n    {\n        return get(this.data, path);\n    },\n\n    has: function (path, value = undefined)\n    {\n        return has(this.data, path, value)\n    },\n\n    indexOf: function (path, value)\n    {\n        return indexOf(this.data, path, value)\n    },\n\n    remove: function (path, value = undefined)\n    {\n        remove(this.data, path, value);\n        return this;\n    },\n\n    keys:function(path)\n    {\n        return Object.keys(get(this.data, path));\n    },\n\n    values:function(path)\n    {\n        return values(this.data, path);\n    }\n\n};\n\nfunction create(obj, keys)\n{\n    let key;\n    while(keys.length)\n    {\n        key = keys.shift();\n        if( ! isObject(obj[key]) )\n        {\n            obj[key] = {};\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n\nexport function set(obj, path, value, index = -1)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    obj[key] = value;\n}\n\nfunction add(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    obj[key].push(value);\n}\n\nfunction insert(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    let parent = obj[key],\n        index = parent.indexOf(value);\n    if(index === -1)\n    {\n        parent.push(value);\n    }\n    else\n    {\n        parent[index] = value;\n    }\n}\n\nexport function get(obj, path)\n{\n    if(isUndefined(path) || path == '')\n    {\n        return obj;\n    }\n\n    let key,\n        keys = String(path).split('.');\n    while(keys.length > 1)\n    {\n        key = keys.shift();\n        if( ! obj.hasOwnProperty(key) )\n        {\n            return;\n        }\n        obj = obj[key];\n    }\n    key = keys.shift();\n    return obj[key];\n}\n\nexport function has(obj, path, value)\n{\n    let parent = get(obj, path);\n    return !! (isArray(parent) && isDefined(value)\n        ? parent.indexOf(value) !== -1\n        : isUndefined(value)\n            ? isDefined(parent)\n            : parent === value);\n}\n\nexport function indexOf (obj, path, value)\n{\n    let arr = get(obj, path);\n    if(isArray(arr))\n    {\n        return arr.indexOf(value);\n    }\n    return -1;\n}\n\nexport function remove(obj, path, value)\n{\n    let parent = obj,\n        keys = String(path || '').split('.'),\n        key = keys.pop();\n\n    if(keys.length)\n    {\n        parent = get(obj, keys.join('.'))\n    }\n    if(isDefined(value) && isArray(parent[key]))\n    {\n        let target = parent[key];\n        var index = target.indexOf(value);\n        if(index > -1)\n        {\n            target.splice(index, 1);\n            if(target.length === 0)\n            {\n                delete parent[key];\n            }\n            return true;\n        }\n        return false;\n    }\n    else\n    {\n        if(isObject(parent) && obj.hasOwnProperty(key))\n        {\n            delete parent[key];\n            return true;\n        }\n    }\n    return false\n}\n\nexport function values(obj, path)\n{\n    var values = [];\n    var target = get(obj, path);\n    if(isObject(target))\n    {\n        for(var name in target)\n        {\n            if(target.hasOwnProperty(name))\n            {\n                values.push(target[name]);\n            }\n        }\n    }\n    return values;\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/ValueMap.js\n **/","export function isObject (value)\n{\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport function isArray (value)\n{\n    return value instanceof Array;\n}\n\nexport function isString (value)\n{\n    return typeof value === 'string';\n}\n\nexport function isFunction(value)\n{\n    return value instanceof Function;\n}\n\nexport function isDefined (value)\n{\n    return typeof value !== 'undefined';\n}\n\nexport function isUndefined (value)\n{\n    return typeof value === 'undefined';\n}\n\nexport function trim (value)\n{\n    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/utils.js\n **/","import { StateEvent, ActionEvent } from './Events';\nimport { isFunction } from './utils/utils';\n\n/**\n * Transition class\n *\n * Responsible for managing events in the flow from state to state.\n *\n * This adds all handlers for the current action start/end and state from/to to an array:\n *\n * - <namespace>.<target>.<type>[]\n *\n * So going from state \"a\" to state \"b\" with action \"next\" should build:\n *\n * - action.*.start[]\n * - action.next.start[]\n * - state.a.leave[]\n * - state.*.leave[]\n * - state.*.enter[]\n * - state.b.enter[]\n * - action.next.end[]\n * - action.*.end[]\n *\n * This can be changed by passing in an order array in fsm.config\n *\n * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n *\n * From a callback, you can:\n *\n * - return false to cancel the transition\n * - return true to pause the transition\n * - not return a value (the transition continues)\n *\n * Transitions can also be paused, resumed, or cancelled by calling\n * the appropriate method on, or from:\n *\n * - the event\n * - the transition\n * - the state machine\n *\n * Cancelled transitions will reset the FSM to the previous \"from\" state\n *\n * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n *\n * @param {StateMachine}    fsm\n * @param {string}          action\n * @param {string}          from\n * @param {string}          to\n */\nfunction Transition (fsm, action, from, to)\n{\n    this.fsm        = fsm;\n    this.action     = action;\n    this.from       = from;\n    this.to         = to;\n    this.clear();\n}\n\n/**\n * @prop {StateMachine}    fsm\n * @prop {string}          action\n * @prop {string}          from\n * @prop {string}          to\n * @prop {Function[]}      handlers\n */\nTransition.prototype =\n{\n    fsm         : null,\n    action      : '',\n    from        : '',\n    to          : '',\n    paused      : false,\n    handlers    : null,\n\n    clear: function ()\n    {\n        this.paused = false;\n        this.handlers = [];\n    },\n\n    /**\n     * Execute the next event's callbacks\n     * @returns {*}\n     */\n\texec: function ()\n\t{\n\t    if( ! this.paused )\n        {\n            if(this.handlers.length)\n            {\n                var handler = this.handlers.shift();\n                var state = handler();\n                if(state === false)\n                {\n                    return this.fsm.cancel();\n                }\n                if(state === true)\n                {\n                    return this.fsm.pause();\n                }\n                this.exec();\n            }\n            else\n            {\n                this.fsm.end();\n            }\n        }\n        return this;\n\t},\n\n    pause: function ()\n    {\n        this.paused = true;\n        return this;\n    },\n\n    resume: function ()\n    {\n        this.paused = false;\n        return this.exec();\n    }\n};\n\nexport default\n{\n    /**\n     * Create the Transition object\n     *\n     * - Set up variables, and queue\n     * - Determine paths to relevant handlers\n     * - Build State and Action Event objects\n     * - Pre-bind all handlers\n     * - Append to queue\n     *\n     * @param {StateMachine}    fsm\n     * @param {string}          action\n     * @param {Array}           params\n     * @returns {Transition}\n     */\n    create:function (fsm, action, params)\n    {\n        // transition properties\n        let scope   = fsm.scope;\n        let from    = fsm.state;\n        let to      = fsm.actions.get(action)[from];\n        let vars    = {action, to, from};\n\n        // handle \"to\" being a function\n        if(isFunction(to))\n        {\n            to = to.apply(scope, params);\n            if(fsm.states.indexOf(to) === -1)\n            {\n                throw new Error('Invalid \"to\" state \"' +to+ '\"');\n            }\n        }\n\n        // transition\n        let queue       = [];\n        let transition  = new Transition(fsm, action, from, to);\n\n        // build handlers array\n        fsm.config.order.map( path =>\n        {\n            // replace path tokens\n            path = path.replace(/{(\\w+)}/g, (all, token) => vars[token]);\n            let handlers = fsm.handlers.get(path);\n\n            // do it!\n            if(handlers)\n            {\n                let [namespace, target, type] = path.split('.');\n                handlers = handlers.map( handler =>\n                {\n                    // build event object\n                    let Event = namespace === 'state' ? StateEvent : ActionEvent;\n                    let event = new Event(type, target, transition);\n\n                    // pre-bind handlers, scopes and params\n                    // this way scope and params don't need to be passed around\n                    // and the call from Transition is always just `value = handler()`\n                    return function()\n                    {\n                        return handler.apply(scope, [event, fsm].concat(params));\n                    }\n                });\n\n                // add to queue\n                queue = queue.concat(handlers);\n            }\n        });\n\n        // return\n        transition.handlers = queue;\n        return transition;\n    },\n\n    force: function(fsm, state)\n    {\n        let transition = new Transition(fsm, '', fsm.state, state);\n        transition.paused = fsm.transition ? fsm.transition.paused : false;\n        return transition;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/Transition.js\n **/","// ------------------------------------------------------------------------------------------------\n// setup\n\n    /**\n     * @prop {string}       namespace   The Event namespace; i.e. state or action\n     * @prop {string}       type        The Event type;      i.e. leave/enter (state) or start/end (action)\n     * @prop {string}       target      The Event target;    i.e. intro (state), next (action), or * (all states or types)\n     * @prop {Transition}   transition  The transition which generated the event\n     */\n    let event =\n    {\n        // properties\n        namespace   : null,\n        type        : null,\n        target      : null,\n        transition          : null\n    };\n\n    function initialize (event, namespace, type, target, transition)\n    {\n        event.namespace     = namespace;\n        event.type          = type;\n        event.target        = target;\n        event.transition    = transition;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// ActionEvent\n\n    export function ActionEvent (type, target, transition)\n    {\n        initialize(this, 'action' ,type, target, transition);\n    }\n    ActionEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// StateEvent\n\n    export function StateEvent (type, target, transition)\n    {\n        initialize(this, 'state' ,type, target, transition);\n    }\n    StateEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// SystemEvent\n\n    export function SystemEvent (type, key, value)\n    {\n        this.type   = type;\n        this.key    = key;\n        this.value  = value;\n    }\n\n    SystemEvent.prototype =\n    {\n        namespace   : 'system',\n        type        : '',\n        key         : '',\n        value       : null\n    };\n\n\n// ------------------------------------------------------------------------------------------------\n// TransitionEvent\n\n    export function TransitionEvent (type)\n    {\n        this.type = type;\n    }\n\n    TransitionEvent.prototype =\n    {\n        namespace   : 'transition',\n        type        : ''\n    };\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/Events.js\n **/","let lookup =\n{\n    namespaces:\n    {\n        start   :'system',\n        change  :'system',\n        update  :'system',\n        complete:'system',\n        reset   :'system',\n        add     :'system',\n        remove  :'system',\n\n        pause   :'transition',\n        resume  :'transition',\n        cancel  :'transition'\n    },\n\n    events:\n    {\n        start   :'action',\n        end     :'action',\n        enter   :'state',\n        leave   :'state'\n    }\n};\n\n/**\n * Parses an event handler id into namespace, type, and target variables\n *\n * @param {StateMachine}    fsm\n * @param {string}          id\n * @return {ParseResult}\n */\nexport function parse(fsm, id)\n{\n    // variables\n    let defaults = fsm.config.defaults,\n        segments,\n        namespace,\n        type,\n        targets;\n\n    // utility functions\n    function isState(value) {\n        return fsm.states.indexOf(value) !== -1;\n    }\n\n    function isAction(value) {\n        return fsm.actions.has(value);\n    }\n\n    function getTargets(value) {\n        return value ? value.match(/\\w[-\\w]*/g) : ['*'];\n    }\n\n    function determineValue(value) {\n\n        // is namespace, i.e. system, transition, state, action\n        if(/^(system|transition|state|action)$/.test(value))\n        {\n            namespace = value;\n        }\n\n        // is shortcut, i.e. update, change, pause, cancel\n        else if(value in lookup.namespaces)\n        {\n            namespace = lookup.namespaces[value];\n            type = value;\n        }\n\n        // is state or action, i.e. a, next\n        else if (isState(value) || isAction(value))\n        {\n            if(!namespace)\n            {\n                namespace = isState(value)\n                    ? 'state'\n                    : 'action';\n            }\n\n            // special case for state with action\n            if(namespace === 'state' && isAction(value))\n            {\n                type = value;\n            }\n\n            if(!targets)\n            {\n                targets = getTargets(value);\n            }\n        }\n\n        // action event, i.e. :event\n        else if(/^(enter|leave)$/.test(value))\n        {\n            type = value;\n        }\n    }\n\n    // process\n    segments    = id.match(/:\\w+|@\\w+|\\(.+?\\)|\\.\\w+|\\w+/g);\n\n    // return an empty result if no matches\n    if(!segments)\n    {\n        return new ParseResult();\n    }\n\n    /**\n     * This is the engine of the parse process\n     *\n     * The regex above matches the grammar of the expression into an array:\n     *\n     * - transition.pause   => [\"transition\", \".pause\"]\n     * - (a|b)@next         => [\"(a|b)\", \"@next\"]\n     * - a@next             => [\"a\", \"@next\"]\n     *\n     * Each segment is then analysed for its type and content, either directly\n     * or via the utility functions above which update the local variables.\n     */\n    segments.forEach(function (segment, i, segments)\n    {\n        // variables\n        let char    = segment[0];\n        let values  = segment.match(/\\w+/g);\n        let value   = values[0];\n        switch(char)\n        {\n            // event\n            case ':':\n                namespace   = lookup.events[value];\n                type        = value;\n                break;\n\n            // action\n            case '@':\n                namespace   = 'state';\n                type        = value;\n                break;\n\n            // targets\n            case '(':\n                targets = values;\n                namespace = isState(values[0]) ? 'state' : 'action';\n                break;\n\n            // property\n            case '.':\n                determineValue(value);\n                break;\n\n            // single word\n            default:\n                determineValue(segment);\n        }\n    });\n\n    // final determination\n    if(!targets)\n    {\n        targets = getTargets();\n    }\n\n    if(!namespace)\n    {\n        namespace = isState(targets[0]) ? 'state' : 'action';\n    }\n\n    if(!type)\n    {\n        type = defaults[namespace];\n    }\n\n    // return result\n    return new ParseResult(namespace, type, targets);\n}\n\nfunction ParseResult (namespace, type, targets)\n{\n    if(namespace)\n    {\n        this.namespace  = namespace;\n        this.type       = type;\n        this.targets    = targets;\n        this.paths      = targets.map( target => {\n            return namespace === 'action' || namespace === 'state'\n                ? [namespace, target, type].join('.')\n                : namespace + '.' + type;\n        });\n    }\n}\n\nParseResult.prototype =\n{\n    namespace   :'',\n    type        :'',\n    targets     :[],\n    paths       :[]\n};\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/handlers.js\n **/"],"sourceRoot":""}