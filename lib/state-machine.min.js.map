{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///state-machine.min.js","webpack:///webpack/bootstrap 73ff3292c36fe131dc0d","webpack:///./src/StateMachine.js","webpack:///./src/utils/ValueMap.js","webpack:///./src/utils/utils.js","webpack:///./src/Transition.js","webpack:///./src/Events.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","StateMachine","scope","config","state","states","transitions","_ValueMap2","actions","handlers","initialize","update","addStates","fsm","key","map","event","addState","_utils","isString","indexOf","push","parseHandler","matches","match","Error","_matches2","_slicedToArray","namespace","type","target","eventNamespaces","has","debug","console","warn","targets","getPath","join","Object","defineProperty","value","_typeof","Symbol","iterator","constructor","prototype","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","next","done","length","err","Array","isArray","TypeError","_ValueMap","_Transition","_Transition2","_Events","transition","_this","events","initial","_matches","name","from","op","to","add","_ref","hasOwnProperty","on","defer","order","SystemEvent","TransitionEvent","dispatch","do","action","can","_len","arguments","rest","_key","create","exec","go","getActionForState","info","cannot","is","getStatesFor","getActionsFor","keys","_this2","asMap","get","_ret","v","isStarted","isTransitioning","isPaused","paused","isComplete","pause","resume","cancel","clear","end","reset","set","remove","fn","_this3","_parseHandler","_parseHandler2","isFunction","path","insert","off","_this4","_parseHandler3","_parseHandler4","change","complete","leave","enter","start","ValueMap","data","shift","isObject","String","split","pop","parent","index","isUndefined","isDefined","splice","values","_set","_get","_has","_indexOf","_remove","_values","toString","Function","trim","replace","Transition","callbacks","_Events2","handler","params","queue","bind","apply","concat","token","_token$split","_token$split2","source","test","noop","ActionEvent","StateEvent"],"mappings":"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","file":"state-machine.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StateMachine\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StateMachine\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.default = StateMachine;\n\t\n\tvar _ValueMap = __webpack_require__(1);\n\t\n\tvar _ValueMap2 = _interopRequireDefault(_ValueMap);\n\t\n\tvar _Transition = __webpack_require__(3);\n\t\n\tvar _Transition2 = _interopRequireDefault(_Transition);\n\t\n\tvar _Events = __webpack_require__(4);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction StateMachine(scope, config) {\n\t    this.scope = scope;\n\t    this.state = '';\n\t    this.states = [];\n\t    this.transitions = new _ValueMap2.default();\n\t    this.actions = new _ValueMap2.default();\n\t    this.handlers = new _ValueMap2.default();\n\t    if (config) {\n\t        this.initialize(config);\n\t        this.update('system', 'initialize');\n\t    }\n\t}\n\t\n\t/**\n\t * StateMachine prototype\n\t *\n\t * The property examples below illustrate a 4-state machine, with states:\n\t *\n\t * - intro > settings > summary > end\n\t *\n\t * And actions:\n\t *\n\t * - back | next | restart | finish\n\t */\n\tStateMachine.prototype = {\n\t    // ------------------------------------------------------------------------------------------------\n\t    // properties\n\t\n\t    /**\n\t     * Available state names\n\t     *\n\t     * - [\n\t     *     intro,\n\t     *     settings,\n\t     *     summary,\n\t     *     final\n\t     *   ]\n\t     *\n\t     * @var {string[]}\n\t     */\n\t    states: null,\n\t\n\t    /**\n\t     * Available transitions for each action\n\t     *\n\t     * action.from => to\n\t     *\n\t     * - next: {\n\t     *     intro: settings,\n\t     *     settings: summary\n\t     *   },\n\t     * - back: {\n\t     *     settings: intro\n\t     *   },\n\t     * - restart: {\n\t     *     summary:intro\n\t     *   },\n\t     * - finish: {\n\t     *     summary:final\n\t     *   },\n\t     *\n\t     * Transitions can also be functions\n\t     *\n\t     * - next: {\n\t     *     intro: function() { return '<random state>' } // jump to a random state\n\t     *   }\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    transitions: null,\n\t\n\t    /**\n\t     * Actions that are available to be called from each state\n\t     *\n\t     * state => [ action, action, ... ]\n\t     *\n\t     * - intro: [\n\t     *     'next'\n\t     *   ],\n\t     * - settings: [\n\t     *     'next',\n\t     *     'back'\n\t     *   ],\n\t     * - summary: [\n\t     *     'restart'\n\t     *     'finish',\n\t     *   ]\n\t     *\n\t     * Actions can also be expressed as wildcards\n\t     *\n\t     * - intro: [\n\t     *     '*' // any action is allowed from intro\n\t     *   ]\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    actions: null,\n\t\n\t    /**\n\t     * Handler functions that should be called on each action event / state change\n\t     *\n\t     * name.type => [ handler, handler, ... ]\n\t     *\n\t     * - next: {\n\t     *   - start: [\n\t     *       hideModal\n\t     *     ],\n\t     *   - end: [\n\t     *       showModal\n\t     *     ]\n\t     *   },\n\t     * - summary: {\n\t     *   - enter: [\n\t     *       resetForm\n\t     *     ],\n\t     *   - leave: [\n\t     *       validateForm,\n\t     *       postData,\n\t     *     ]\n\t     *   },\n\t     *   ...\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    handlers: null,\n\t\n\t    /**\n\t     * The current state\n\t     *\n\t     * @var {string}\n\t     */\n\t    state: '',\n\t\n\t    /**\n\t     * Any active Transition object that is driving the state change\n\t     *\n\t     * @var {Transition}\n\t     */\n\t    transition: null,\n\t\n\t    /**\n\t     * The scope in which to call all handlers\n\t     *\n\t     * @var {*}\n\t     */\n\t    scope: null,\n\t\n\t    /**\n\t     * The original config object\n\t     *\n\t     * @var {Object}\n\t     */\n\t    config: null,\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // private methods\n\t\n\t    /**\n\t     * Initialize the FSM with a config object\n\t     *\n\t     * @private\n\t     * @param config\n\t     */\n\t    initialize: function initialize(config) {\n\t        var _this = this;\n\t\n\t        // assign config\n\t        this.config = config;\n\t\n\t        // pre-collate all states\n\t        addStates(this, 'from', config.events);\n\t        addStates(this, 'to', config.events);\n\t\n\t        // initial state\n\t        if (!config.initial) {\n\t            config.initial = this.states[0];\n\t        }\n\t\n\t        // add transitions\n\t        config.events.map(function (event) {\n\t            // shorthand\n\t            if ((0, _utils.isString)(event)) {\n\t                var matches = event.match(/(\\w+)\\s*[\\|:=]\\s*(\\w+)\\s*([<>-])\\s*(\\w.*)/);\n\t\n\t                var _matches = _slicedToArray(matches, 5);\n\t\n\t                var name = _matches[1];\n\t                var from = _matches[2];\n\t                var op = _matches[3];\n\t                var to = _matches[4];\n\t\n\t                if (op === '-') {\n\t                    _this.add(name, from, to);\n\t                    _this.add(name, to, from);\n\t                    return;\n\t                }\n\t                if (op === '<') {\n\t                    var _ref = [to, from];\n\t                    from = _ref[0];\n\t                    to = _ref[1];\n\t                }\n\t                _this.add(name, from, to);\n\t            }\n\t\n\t            // keys\n\t            else {\n\t                    _this.add(event.name, event.from, event.to);\n\t                }\n\t        });\n\t\n\t        // add handlers\n\t        for (var name in config.handlers) {\n\t            if (config.handlers.hasOwnProperty(name)) {\n\t                this.on(name, config.handlers[name]);\n\t            }\n\t        }\n\t\n\t        // state\n\t        if (!config.defer) {\n\t            this.state = config.initial;\n\t        }\n\t\n\t        /**\n\t         * Sets the default order to run transition callbacks in\n\t         *\n\t         * start/leave/enter/end  -> event types\n\t         * to/action              -> targeted handlers (leave:red)\n\t         * *                      -> global handlers   (leave, or leave:*)\n\t         *\n\t         * @type {string[]} type.target\n\t         */\n\t        config.order = config.order || ['start:*', 'start:action', 'leave:from', 'leave:*', 'enter:*', 'enter:to', 'end:action', 'end:*'];\n\t    },\n\t\n\t    /**\n\t     * Dispatch an event\n\t     *\n\t     * @param namespace\n\t     * @param type\n\t     */\n\t    update: function update(namespace, type) {\n\t        var event = namespace === 'system' ? _Events.SystemEvent : _Events.TransitionEvent;\n\t        this.dispatch(namespace + '.' + type, new event(type));\n\t        return this;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // api\n\t\n\t    /**\n\t     * Attempt to run an action, resulting in a transition to a state\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {*[]}       rest\n\t     * @returns {boolean}\n\t     */\n\t    do: function _do(action) {\n\t        if (this.can(action)) {\n\t            for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                rest[_key - 1] = arguments[_key];\n\t            }\n\t\n\t            this.transition = _Transition2.default.create(this, action, rest);\n\t            this.update('system', 'update');\n\t            this.transition.exec();\n\t            return true;\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Attempt to go to a state\n\t     *\n\t     * Finds if an appropriate transition exists, then calls the related action if it does\n\t     *\n\t     * @param   {string}    state\n\t     * @returns {boolean}\n\t     */\n\t    go: function go(state) {\n\t        if (this.has(state)) {\n\t            var action = this.getActionForState(state);\n\t            if (action) {\n\t                return this.do(action);\n\t            }\n\t            this.config.debug && console.info('No transition exists from \"%s\" to \"%s\"', this.state, state);\n\t        } else {\n\t            this.config.debug && console.warn('No such state \"%s\"', state);\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Query a transition to see if a named action is available\n\t     *\n\t     * @param   {string}    action\n\t     * @returns {boolean}\n\t     */\n\t    can: function can(action) {\n\t        if (!this.actions.has(action)) {\n\t            this.config.debug && console.warn('No such action \"%s\"', action);\n\t        }\n\t        return !!this.transitions.has(this.state, action);\n\t    },\n\t\n\t    /**\n\t     * Query a transition to see if a named action is unavailable\n\t     *\n\t     * @param   {string}    action\n\t     * @returns {boolean}\n\t     */\n\t    cannot: function cannot(action) {\n\t        return !this.can(action);\n\t    },\n\t\n\t    /**\n\t     * Test if the current state is the same as the supplied one\n\t     *\n\t     * @param   {string}    state       A state name to compare against the current state\n\t     * @returns {boolean}\n\t     */\n\t    is: function is(state) {\n\t        if (this.states.indexOf(state) === -1) {\n\t            this.config.debug && console.warn('No such state \"%s\"', state);\n\t        }\n\t        return state === this.state;\n\t    },\n\t\n\t    /**\n\t     * Test if a state exists\n\t     *\n\t     * @param   {string}    state\n\t     * @return  {boolean}\n\t     */\n\t    has: function has(state) {\n\t        return this.states.indexOf(state) !== -1;\n\t    },\n\t\n\t    /**\n\t     * Get the available \"to\" states for the current or supplied state\n\t     *\n\t     * @param   {string}    [state]     Optional name of a state to get states for. Defaults to the current state\n\t     * @returns {string[]}              An array of string states\n\t     */\n\t    getStatesFor: function getStatesFor() {\n\t        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\n\t        state = state || this.state;\n\t        var actions = this.getActionsFor(state, true);\n\t        return Object.keys(actions).map(function (name) {\n\t            return actions[name];\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Get the available actions (or actions and states) for the current or supplied state\n\t     *\n\t     * @param   {string}    [state]     Optional name of a state to get actions for. Defaults to the current state\n\t     * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n\t     * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n\t     */\n\t    getActionsFor: function getActionsFor() {\n\t        var _this2 = this;\n\t\n\t        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t        var asMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        state = state || this.state;\n\t        var actions = this.transitions.get(state || this.state);\n\t        if (asMap) {\n\t            var _ret = function () {\n\t                var states = {};\n\t                actions.map(function (action) {\n\t                    states[action] = _this2.actions.get(action + '.' + state);\n\t                });\n\t                return {\n\t                    v: states\n\t                };\n\t            }();\n\t\n\t            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t        } else {\n\t            return actions;\n\t        }\n\t    },\n\t\n\t    getActionForState: function getActionForState(state) {\n\t        if (this.has(state)) {\n\t            var actions = this.getActionsFor(null, true);\n\t            for (var action in actions) {\n\t                if (actions[action] === state) {\n\t                    return action;\n\t                }\n\t            }\n\t        }\n\t        return null;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // flags\n\t\n\t    /**\n\t     * Test if the FSM has started\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isStarted: function isStarted() {\n\t        return this.state !== '';\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is transitioning\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isTransitioning: function isTransitioning() {\n\t        return !!this.transition;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is paused (whilst transitioning)\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isPaused: function isPaused() {\n\t        return this.transition ? this.transition.paused : false;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is on the \"final\" state\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isComplete: function isComplete() {\n\t        return this.state === this.config.final;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // transitions\n\t\n\t    /**\n\t     * Pause any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    pause: function pause() {\n\t        if (this.transition) {\n\t            this.transition.pause();\n\t            this.update('transition', 'pause');\n\t            this.update('system', 'update');\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Resume any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    resume: function resume() {\n\t        if (this.transition) {\n\t            this.update('transition', 'resume');\n\t            this.update('system', 'update');\n\t            this.transition.resume();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Cancel any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    cancel: function cancel() {\n\t        if (this.transition) {\n\t            this.state = this.transition.from;\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('transition', 'cancel');\n\t            this.update('system', 'update');\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * End any current transition, skipping remaining handlers\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    end: function end() {\n\t        if (this.transition) {\n\t            this.state = this.transition.to;\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('system', 'change');\n\t            if (this.isComplete()) {\n\t                this.update('system', 'complete');\n\t            }\n\t            this.update('system', 'update');\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Reset the FSM to the initial, or supplied, state\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    reset: function reset(initial) {\n\t        this.state = initial || this.config.initial;\n\t        if (this.transition) {\n\t            this.transition.clear();\n\t            delete this.transition;\n\t        }\n\t        this.update('system', 'reset');\n\t        return this;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // actions\n\t\n\t    /**\n\t     * Add a transition event\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @return  {StateMachine}\n\t     */\n\t    add: function add(action, from, to) {\n\t        this.actions.set(action + '.' + from, to);\n\t        this.transitions.add(from, action);\n\t        addState(this, from);\n\t        addState(this, to);\n\t        return this;\n\t    },\n\t\n\t    remove: function remove(action, from, to) {\n\t        this.states.remove(action, from);\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // handlers\n\t\n\t    /**\n\t     * Add an event handler\n\t     *\n\t     * Event handler signature:\n\t     *\n\t     * - namespace.type:target1 target2 target3 ...\n\t     *\n\t     * Valid event signatures:\n\t     *\n\t     * - system:(change|update|complete|reset)\n\t     * - action:(start|end)\n\t     * - state:(add|remove|leave|enter)\n\t     * - transition:(pause|resume|cancel)\n\t     *\n\t     * As event types are unique, they can be used without the namespace:\n\t     *\n\t     * - change\n\t     * - pause\n\t     * - start\n\t     * - end\n\t     * - leave:red\n\t     * - enter:blue green\n\t     * - start:next\n\t     * - end:back\n\t     *\n\t     * You can also just pass action or names to target individual state.leave / action.end events:\n\t     *\n\t     * - next\n\t     * - intro\n\t     *\n\t     * @param id\n\t     * @param fn\n\t     * @return {StateMachine}\n\t     */\n\t    on: function on(id, fn) {\n\t        var _this3 = this;\n\t\n\t        var _parseHandler = parseHandler(this, id);\n\t\n\t        var _parseHandler2 = _slicedToArray(_parseHandler, 3);\n\t\n\t        var namespace = _parseHandler2[0];\n\t        var type = _parseHandler2[1];\n\t        var targets = _parseHandler2[2];\n\t\n\t\n\t        targets.map(function (target) {\n\t            // warn for invalid actions / states\n\t            if (target !== '*') {\n\t                if (namespace === 'state') {\n\t                    if (_this3.states.indexOf(target) === -1) {\n\t                        _this3.config.debug && console.warn('Warning assigning state.%s handler: no such state \"%s\"', type, target);\n\t                    }\n\t                } else if (namespace === 'action') {\n\t                    if (!_this3.actions.has(target)) {\n\t                        _this3.config.debug && console.warn('Warning assigning action.%s handler: no such action \"%s\"', type, target);\n\t                    }\n\t                }\n\t            }\n\t\n\t            // check handler is a function\n\t            if (!(0, _utils.isFunction)(fn)) {\n\t                throw new Error('Error assigning ' + namespace + '.' + type + ' handler; callback is not a Function', fn);\n\t            }\n\t\n\t            // assign\n\t            var path = getPath(namespace, type, target);\n\t            _this3.handlers.insert(path, fn);\n\t        });\n\t\n\t        return this;\n\t    },\n\t\n\t    off: function off(id, fn) {\n\t        var _this4 = this;\n\t\n\t        var _parseHandler3 = parseHandler(this, id);\n\t\n\t        var _parseHandler4 = _slicedToArray(_parseHandler3, 3);\n\t\n\t        var namespace = _parseHandler4[0];\n\t        var type = _parseHandler4[1];\n\t        var targets = _parseHandler4[2];\n\t\n\t        targets.map(function (target) {\n\t            var path = getPath(namespace, type, target);\n\t            _this4.handlers.remove(path, fn);\n\t        });\n\t    },\n\t\n\t    dispatch: function dispatch(path, event) {\n\t        this.config.debug && console.info('StateMachine dispatch \"%s\"', path);\n\t        var handlers = this.handlers.get(path);\n\t        if (handlers) {\n\t            // do we need to pass additional arguments?\n\t            handlers.map(function (fn) {\n\t                return fn(event);\n\t            });\n\t        }\n\t    }\n\t\n\t};\n\t\n\t/**\n\t * Parses config and adds unique state names to states array\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          key\n\t * @param {Object[]}        transitions\n\t */\n\tfunction addStates(fsm, key, transitions) {\n\t    transitions.map(function (event) {\n\t        return addState(fsm, event[key]);\n\t    });\n\t}\n\t\n\tfunction addState(fsm, state) {\n\t    if ((0, _utils.isString)(state) && fsm.states.indexOf(state) === -1) {\n\t        fsm.states.push(state);\n\t    }\n\t}\n\t\n\tfunction parseHandler(fsm, id) {\n\t    // get initial matches\n\t    var matches = id.match(/^(?:(\\w+)\\.)?(\\w+[-.\\w]*)(?::(.*))?/);\n\t    if (!matches) {\n\t        throw new Error('Warning parsing event handler: invalid signature \"%s\"', id);\n\t    }\n\t\n\t    var _matches2 = _slicedToArray(matches, 4);\n\t\n\t    var namespace = _matches2[1];\n\t    var type = _matches2[2];\n\t    var target = _matches2[3];\n\t\n\t    // determine namespace if not found\n\t\n\t    if (!namespace) {\n\t        // check if shorthand global was passed\n\t        namespace = eventNamespaces[type];\n\t\n\t        // if event is still null, attempt to determine type from existing states or actions\n\t        if (!namespace) {\n\t            if (fsm.states.indexOf(type) !== -1) {\n\t                target = type;\n\t                namespace = 'state';\n\t                type = 'enter';\n\t            } else if (fsm.actions.has(type)) {\n\t                target = type;\n\t                namespace = 'action';\n\t                type = 'start';\n\t            } else {\n\t                fsm.config.debug && console.warn('Warning parsing event handler: unable to map \"%s\" to a valid event or existing entity', id);\n\t            }\n\t        }\n\t    }\n\t\n\t    // determine targets\n\t    var targets = target ? target.match(/[-*\\w_]+/g) : ['*'];\n\t\n\t    // return\n\t    return [namespace, type, targets];\n\t}\n\t\n\tfunction getPath(namespace, type, target) {\n\t    return namespace === 'action' || namespace === 'state' ? [namespace, target, type].join('.') : namespace + '.' + type;\n\t}\n\t\n\tvar eventNamespaces = {\n\t    change: 'system',\n\t    update: 'system',\n\t    complete: 'system',\n\t    reset: 'system',\n\t\n\t    add: 'state',\n\t    remove: 'state',\n\t    leave: 'state',\n\t    enter: 'state',\n\t\n\t    start: 'action',\n\t    end: 'action',\n\t\n\t    pause: 'transition',\n\t    resume: 'transition',\n\t    cancel: 'transition'\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.values = exports.remove = exports.indexOf = exports.has = exports.get = exports.set = undefined;\n\texports.default = ValueMap;\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\t/**\n\t * Utility class to create, modify and delete nested hashes and values\n\t *\n\t * @constructor\n\t */\n\tfunction ValueMap(data) {\n\t    this.data = data || {};\n\t}\n\t\n\tValueMap.prototype = {\n\t    data: null,\n\t\n\t    set: function set(path, value) {\n\t        _set(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    add: function add(path, value) {\n\t        _add(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    insert: function insert(path, value) {\n\t        _insert(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    get: function get(path) {\n\t        return _get(this.data, path);\n\t    },\n\t\n\t    has: function has(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        return _has(this.data, path, value);\n\t    },\n\t\n\t    indexOf: function indexOf(path, value) {\n\t        return _indexOf(this.data, path, value);\n\t    },\n\t\n\t    remove: function remove(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        _remove(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    keys: function keys(path) {\n\t        return Object.keys(_get(this.data, path));\n\t    },\n\t\n\t    values: function values(path) {\n\t        return _values(this.data, path);\n\t    }\n\t\n\t};\n\t\n\tfunction create(obj, keys) {\n\t    var key = void 0;\n\t    while (keys.length) {\n\t        key = keys.shift();\n\t        if (!(0, _utils.isObject)(obj[key])) {\n\t            obj[key] = {};\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    return obj;\n\t}\n\t\n\tfunction _set(obj, path, value) {\n\t    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n\t\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    obj[key] = value;\n\t}\n\t\n\texports.set = _set;\n\tfunction _add(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    obj[key].push(value);\n\t}\n\t\n\tfunction _insert(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    var parent = obj[key],\n\t        index = parent.indexOf(value);\n\t    if (index === -1) {\n\t        parent.push(value);\n\t    } else {\n\t        parent[index] = value;\n\t    }\n\t}\n\t\n\tfunction _get(obj, path) {\n\t    if ((0, _utils.isUndefined)(path) || path == '') {\n\t        return obj;\n\t    }\n\t\n\t    var key = void 0,\n\t        keys = String(path).split('.');\n\t    while (keys.length > 1) {\n\t        key = keys.shift();\n\t        if (!obj.hasOwnProperty(key)) {\n\t            return;\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    key = keys.shift();\n\t    return obj[key];\n\t}\n\t\n\texports.get = _get;\n\tfunction _has(obj, path, value) {\n\t    var parent = _get(obj, path);\n\t    return !!((0, _utils.isArray)(parent) && (0, _utils.isDefined)(value) ? parent.indexOf(value) !== -1 : (0, _utils.isUndefined)(value) ? (0, _utils.isDefined)(parent) : parent === value);\n\t}\n\t\n\texports.has = _has;\n\tfunction _indexOf(obj, path, value) {\n\t    var arr = _get(obj, path);\n\t    if ((0, _utils.isArray)(arr)) {\n\t        return arr.indexOf(value);\n\t    }\n\t    return -1;\n\t}\n\t\n\texports.indexOf = _indexOf;\n\tfunction _remove(obj, path, value) {\n\t    var parent = obj,\n\t        keys = String(path || '').split('.'),\n\t        key = keys.pop();\n\t\n\t    if (keys.length) {\n\t        parent = _get(obj, keys.join('.'));\n\t    }\n\t    if ((0, _utils.isDefined)(value) && (0, _utils.isArray)(parent[key])) {\n\t        parent = parent[key];\n\t        var index = parent.indexOf(value);\n\t        if (index > -1) {\n\t            parent.splice(index, 1);\n\t            return true;\n\t        }\n\t        return false;\n\t    } else {\n\t        if ((0, _utils.isObject)(parent) && obj.hasOwnProperty(key)) {\n\t            delete parent[key];\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\t\n\texports.remove = _remove;\n\tfunction _values(obj, path) {\n\t    var values = [];\n\t    var target = _get(obj, path);\n\t    if ((0, _utils.isObject)(target)) {\n\t        for (var name in target) {\n\t            if (target.hasOwnProperty(name)) {\n\t                values.push(target[name]);\n\t            }\n\t        }\n\t    }\n\t    return values;\n\t}\n\texports.values = _values;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.isObject = isObject;\n\texports.isArray = isArray;\n\texports.isString = isString;\n\texports.isFunction = isFunction;\n\texports.isDefined = isDefined;\n\texports.isUndefined = isUndefined;\n\texports.trim = trim;\n\tfunction isObject(value) {\n\t    return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\t\n\tfunction isArray(value) {\n\t    return value instanceof Array;\n\t}\n\t\n\tfunction isString(value) {\n\t    return typeof value === 'string';\n\t}\n\t\n\tfunction isFunction(value) {\n\t    return value instanceof Function;\n\t}\n\t\n\tfunction isDefined(value) {\n\t    return typeof value !== 'undefined';\n\t}\n\t\n\tfunction isUndefined(value) {\n\t    return typeof value === 'undefined';\n\t}\n\t\n\tfunction trim(value) {\n\t    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _Events = __webpack_require__(4);\n\t\n\tvar _Events2 = _interopRequireDefault(_Events);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Transition class\n\t *\n\t * Responsible for managing events in the flow from state to state.\n\t *\n\t * This adds all handlers for the current action start/end and state from/to to an array:\n\t *\n\t * - <namespace>.<target>.<type>[]\n\t *\n\t * So going from state \"a\" to state \"b\" with action \"next\" should build:\n\t *\n\t * - action.*.start[]\n\t * - action.next.start[]\n\t * - state.a.leave[]\n\t * - state.*.leave[]\n\t * - state.*.enter[]\n\t * - state.b.enter[]\n\t * - action.next.end[]\n\t * - action.*.end[]\n\t *\n\t * This can be changed by passing in an order array in fsm.config\n\t *\n\t * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n\t *\n\t * From a callback, you can:\n\t *\n\t * - return false to cancel the transition\n\t * - return true to pause the transition\n\t * - not return a value (the transition continues)\n\t *\n\t * Transitions can also be paused, resumed, or cancelled by calling\n\t * the appropriate method on, or from:\n\t *\n\t * - the event\n\t * - the transition\n\t * - the state machine\n\t *\n\t * Cancelled transitions will reset the FSM to the previous \"from\" state\n\t *\n\t * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n\t *\n\t * @param {string}          action\n\t * @param {string}          from\n\t * @param {string}          to\n\t * @param {Function[]}      handlers\n\t * @param {Object}          callbacks\n\t */\n\tfunction Transition(action, from, to, handlers, callbacks) {\n\t    this.action = action;\n\t    this.from = from;\n\t    this.to = to;\n\t    this.handlers = handlers;\n\t    this.callbacks = callbacks;\n\t}\n\t\n\tTransition.prototype = {\n\t    action: '',\n\t    from: '',\n\t    to: '',\n\t    handlers: null,\n\t    callbacks: null,\n\t    paused: false,\n\t\n\t    clear: function clear() {\n\t        this.paused = false;\n\t        this.handlers = [];\n\t    },\n\t\n\t    /**\n\t     * Execute the next event's callbacks\n\t     * @returns {*}\n\t     */\n\t    exec: function exec() {\n\t        if (!this.paused) {\n\t            if (this.handlers.length) {\n\t                var handler = this.handlers.shift();\n\t                var state = handler();\n\t                if (state === false) {\n\t                    return this.callbacks.cancel();\n\t                }\n\t                if (state === true) {\n\t                    return this.callbacks.pause();\n\t                }\n\t                this.exec();\n\t            } else {\n\t                this.callbacks.end();\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t\n\t    pause: function pause() {\n\t        this.paused = true;\n\t        return this;\n\t    },\n\t\n\t    resume: function resume() {\n\t        this.paused = false;\n\t        return this.exec();\n\t    }\n\t};\n\t\n\texports.default = {\n\t    /**\n\t     * Create the Transition object\n\t     *\n\t     * - Set up variables, callbacks and queue\n\t     * - Determine paths to relevant callbacks\n\t     * - Build State and Action Event objects\n\t     * - Pre-bind all handlers\n\t     * - Append to queue\n\t     *\n\t     * @param {StateMachine}    fsm\n\t     * @param {string}          action\n\t     * @param {Array}           params\n\t     * @returns {Transition}\n\t     */\n\t    create: function create(fsm, action, params) {\n\t        // transition\n\t        var queue = [];\n\t        var scope = fsm.scope;\n\t        var from = fsm.state;\n\t        var to = fsm.actions.get(action)[from];\n\t        var callbacks = {\n\t            cancel: fsm.cancel.bind(fsm),\n\t            pause: fsm.pause.bind(fsm),\n\t            resume: fsm.resume.bind(fsm),\n\t            end: fsm.end.bind(fsm)\n\t        };\n\t\n\t        // handle \"to\" being a function\n\t        if ((0, _utils.isFunction)(to)) {\n\t            var actions = fsm.getActionsFor();\n\t            var state = to.apply(scope, [actions].concat(params));\n\t            var _action = fsm.getActionsFor(state);\n\t            // TODO debug this! It's wrong\n\t            if (!_action) {\n\t                throw new Error('Cannot go to state \"' + state + '\" from current state \"' + from + '\"');\n\t            }\n\t        }\n\t\n\t        // build handlers array\n\t        fsm.config.order.map(function (token) {\n\t            // determine path variables\n\t            var _token$split = token.split(':');\n\t\n\t            var _token$split2 = _slicedToArray(_token$split, 2);\n\t\n\t            var type = _token$split2[0];\n\t            var source = _token$split2[1]; // i.e. start.*, enter:to, end:action\n\t\n\t            var namespace = /^(start|end)$/.test(type) ? 'action' : 'state';\n\t            var target = void 0;\n\t            if (source === '*') {\n\t                target = '*';\n\t            } else if (namespace == 'action') {\n\t                target = action;\n\t            } else {\n\t                target = type === 'leave' ? from : to;\n\t            }\n\t\n\t            // get handlers\n\t            var path = [namespace, target, type].join('.');\n\t\n\t            var handlers = fsm.handlers.get(path);\n\t            if (handlers) {\n\t                // pre-bind handlers, scopes and params\n\t                // this way scope and params don't need to be passed around\n\t                handlers = handlers.map(function (handler) {\n\t                    return function () {\n\t                        var event = _Events2.default.create(namespace, type, target, from, to, callbacks);\n\t                        handler.apply(scope, [event].concat(params));\n\t                    };\n\t                });\n\t\n\t                // add to queue\n\t                queue = queue.concat(handlers);\n\t            }\n\t        });\n\t\n\t        // create\n\t        return new Transition(action, from, to, queue, callbacks);\n\t    }\n\t\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ActionEvent = ActionEvent;\n\texports.StateEvent = StateEvent;\n\texports.SystemEvent = SystemEvent;\n\texports.TransitionEvent = TransitionEvent;\n\t// ------------------------------------------------------------------------------------------------\n\t// setup\n\t\n\tfunction noop() {}\n\t\n\t/**\n\t * @prop {string}  namespace  The Event namespace; i.e. state or action\n\t * @prop {string}  type       The Event type;      i.e. leave/enter (state) or start/end (action)\n\t * @prop {string}  target     The Event target;    i.e. intro (state), next (action), or * (all states or types)\n\t * @prop {string}  from       The from state\n\t * @prop {string}  to         The to state\n\t */\n\tvar event = {\n\t    // properties\n\t    namespace: null,\n\t    type: null,\n\t    target: null,\n\t    from: null,\n\t    to: null,\n\t\n\t    // transition callbacks\n\t    pause: noop,\n\t    resume: noop,\n\t    cancel: noop,\n\t    complete: noop\n\t};\n\t\n\tfunction initialize(event, namespace, type, target, from, to, callbacks) {\n\t    event.namespace = namespace;\n\t    event.type = type;\n\t    event.target = target;\n\t    event.from = from;\n\t    event.to = to;\n\t\n\t    event.pause = callbacks.pause;\n\t    event.resume = callbacks.resume;\n\t    event.cancel = callbacks.cancel;\n\t    event.complete = callbacks.complete;\n\t}\n\t\n\texports.default = {\n\t    create: function create(namespace, type, target, from, to, callbacks) {\n\t        var fn = namespace == 'state' ? StateEvent : ActionEvent;\n\t        return new fn(type, target, from, to, callbacks);\n\t    }\n\t};\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// ActionEvent\n\t\n\tfunction ActionEvent(type, target, from, to, callbacks) {\n\t    initialize(this, 'action', type, target, from, to, callbacks);\n\t}\n\tActionEvent.prototype = event;\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// StateEvent\n\t\n\tfunction StateEvent(type, target, from, to, callbacks) {\n\t    initialize(this, 'state', type, target, from, to, callbacks);\n\t}\n\tStateEvent.prototype = event;\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// SystemEvent\n\t\n\tfunction SystemEvent(type) {\n\t    this.type = type;\n\t}\n\t\n\tSystemEvent.prototype = {\n\t    namespace: 'system',\n\t    type: ''\n\t};\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// TransitionEvent\n\t\n\tfunction TransitionEvent(type) {\n\t    this.type = type;\n\t}\n\t\n\tTransitionEvent.prototype = {\n\t    namespace: 'transition',\n\t    type: ''\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** state-machine.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 73ff3292c36fe131dc0d\n **/","import ValueMap from './utils/ValueMap';\nimport Transition from './Transition';\nimport { SystemEvent, TransitionEvent } from './Events';\nimport { isString, isFunction } from './utils/utils';\n\nexport default function StateMachine (scope, config)\n{\n    this.scope          = scope;\n    this.state          = '';\n    this.states         = [];\n    this.transitions    = new ValueMap();\n    this.actions        = new ValueMap();\n    this.handlers       = new ValueMap();\n    if(config)\n    {\n        this.initialize(config);\n        this.update('system', 'initialize');\n    }\n}\n\n/**\n * StateMachine prototype\n *\n * The property examples below illustrate a 4-state machine, with states:\n *\n * - intro > settings > summary > end\n *\n * And actions:\n *\n * - back | next | restart | finish\n */\nStateMachine.prototype =\n{\n    // ------------------------------------------------------------------------------------------------\n    // properties\n\n        /**\n         * Available state names\n         *\n         * - [\n         *     intro,\n         *     settings,\n         *     summary,\n         *     final\n         *   ]\n         *\n         * @var {string[]}\n         */\n        states      : null,\n\n        /**\n         * Available transitions for each action\n         *\n         * action.from => to\n         *\n         * - next: {\n         *     intro: settings,\n         *     settings: summary\n         *   },\n         * - back: {\n         *     settings: intro\n         *   },\n         * - restart: {\n         *     summary:intro\n         *   },\n         * - finish: {\n         *     summary:final\n         *   },\n         *\n         * Transitions can also be functions\n         *\n         * - next: {\n         *     intro: function() { return '<random state>' } // jump to a random state\n         *   }\n         *\n         * @var {ValueMap}\n         */\n        transitions : null,\n\n        /**\n         * Actions that are available to be called from each state\n         *\n         * state => [ action, action, ... ]\n         *\n         * - intro: [\n         *     'next'\n         *   ],\n         * - settings: [\n         *     'next',\n         *     'back'\n         *   ],\n         * - summary: [\n         *     'restart'\n         *     'finish',\n         *   ]\n         *\n         * Actions can also be expressed as wildcards\n         *\n         * - intro: [\n         *     '*' // any action is allowed from intro\n         *   ]\n         *\n         * @var {ValueMap}\n         */\n        actions     : null,\n\n        /**\n         * Handler functions that should be called on each action event / state change\n         *\n         * name.type => [ handler, handler, ... ]\n         *\n         * - next: {\n         *   - start: [\n         *       hideModal\n         *     ],\n         *   - end: [\n         *       showModal\n         *     ]\n         *   },\n         * - summary: {\n         *   - enter: [\n         *       resetForm\n         *     ],\n         *   - leave: [\n         *       validateForm,\n         *       postData,\n         *     ]\n         *   },\n         *   ...\n         *\n         * @var {ValueMap}\n         */\n        handlers   : null,\n\n        /**\n         * The current state\n         *\n         * @var {string}\n         */\n        state       : '',\n\n        /**\n         * Any active Transition object that is driving the state change\n         *\n         * @var {Transition}\n         */\n        transition  : null,\n\n        /**\n         * The scope in which to call all handlers\n         *\n         * @var {*}\n         */\n        scope      : null,\n\n        /**\n         * The original config object\n         *\n         * @var {Object}\n         */\n        config      : null,\n\n\n    // ------------------------------------------------------------------------------------------------\n    // private methods\n\n        /**\n         * Initialize the FSM with a config object\n         *\n         * @private\n         * @param config\n         */\n        initialize:function (config)\n        {\n            // assign config\n            this.config     = config;\n\n            // pre-collate all states\n            addStates(this, 'from', config.events);\n            addStates(this, 'to', config.events);\n\n            // initial state\n            if( ! config.initial )\n            {\n                config.initial = this.states[0];\n            }\n\n            // add transitions\n            config.events.map( event =>\n            {\n                // shorthand\n                if(isString(event))\n                {\n                    let matches = event.match(/(\\w+)\\s*[\\|:=]\\s*(\\w+)\\s*([<>-])\\s*(\\w.*)/);\n                    let [,name, from, op, to] = matches;\n                    if(op === '-')\n                    {\n                        this.add(name, from, to);\n                        this.add(name, to, from);\n                        return;\n                    }\n                    if(op === '<')\n                    {\n                        [from, to] = [to, from];\n                    }\n                    this.add(name, from, to);\n                }\n\n                // keys\n                else\n                {\n                    this.add(event.name, event.from, event.to);\n                }\n            });\n\n            // add handlers\n            for(let name in config.handlers)\n            {\n                if(config.handlers.hasOwnProperty(name))\n                {\n                    this.on(name, config.handlers[name]);\n                }\n            }\n\n            // state\n            if( ! config.defer )\n            {\n                this.state = config.initial;\n            }\n\n            /**\n             * Sets the default order to run transition callbacks in\n             *\n             * start/leave/enter/end  -> event types\n             * to/action              -> targeted handlers (leave:red)\n             * *                      -> global handlers   (leave, or leave:*)\n             *\n             * @type {string[]} type.target\n             */\n            config.order = config.order || [\n                'start:*',\n                'start:action',\n                'leave:from',\n                'leave:*',\n                'enter:*',\n                'enter:to',\n                'end:action',\n                'end:*'\n            ];\n        },\n\n        /**\n         * Dispatch an event\n         *\n         * @param namespace\n         * @param type\n         */\n        update: function (namespace, type)\n        {\n            let event = namespace === 'system'\n                ? SystemEvent\n                : TransitionEvent;\n            this.dispatch(namespace + '.' + type, new event(type));\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // api\n\n        /**\n         * Attempt to run an action, resulting in a transition to a state\n         *\n         * @param   {string}    action\n         * @param   {*[]}       rest\n         * @returns {boolean}\n         */\n        do: function (action, ...rest)\n        {\n            if(this.can(action))\n            {\n                this.transition = Transition.create(this, action, rest);\n                this.update('system', 'update');\n                this.transition.exec();\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Attempt to go to a state\n         *\n         * Finds if an appropriate transition exists, then calls the related action if it does\n         *\n         * @param   {string}    state\n         * @returns {boolean}\n         */\n        go: function (state)\n        {\n            if(this.has(state))\n            {\n                var action = this.getActionForState(state);\n                if(action)\n                {\n                    return this.do(action);\n                }\n                this.config.debug && console.info('No transition exists from \"%s\" to \"%s\"', this.state, state);\n            }\n            else\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n            }\n            return false;\n        },\n\n        /**\n         * Query a transition to see if a named action is available\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        can: function (action)\n        {\n            if( ! this.actions.has(action) )\n            {\n                this.config.debug && console.warn('No such action \"%s\"', action);\n            }\n            return !! this.transitions.has(this.state, action);\n        },\n\n        /**\n         * Query a transition to see if a named action is unavailable\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        cannot: function (action)\n        {\n            return ! this.can(action);\n        },\n\n        /**\n         * Test if the current state is the same as the supplied one\n         *\n         * @param   {string}    state       A state name to compare against the current state\n         * @returns {boolean}\n         */\n        is: function (state)\n        {\n            if(this.states.indexOf(state) === -1)\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n            }\n            return state === this.state;\n        },\n\n        /**\n         * Test if a state exists\n         *\n         * @param   {string}    state\n         * @return  {boolean}\n         */\n        has: function(state)\n        {\n            return this.states.indexOf(state) !== -1;\n        },\n\n        /**\n         * Get the available \"to\" states for the current or supplied state\n         *\n         * @param   {string}    [state]     Optional name of a state to get states for. Defaults to the current state\n         * @returns {string[]}              An array of string states\n         */\n        getStatesFor: function (state = null)\n        {\n            state       = state || this.state;\n            let actions = this.getActionsFor(state, true);\n            return Object.keys(actions).map( name => actions[name] );\n        },\n\n        /**\n         * Get the available actions (or actions and states) for the current or supplied state\n         *\n         * @param   {string}    [state]     Optional name of a state to get actions for. Defaults to the current state\n         * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n         * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n         */\n        getActionsFor: function (state = null, asMap = false)\n        {\n            state       = state || this.state;\n            let actions = this.transitions.get(state || this.state);\n            if(asMap)\n            {\n                let states  = {};\n                actions.map( action =>\n                {\n                    states[action] = this.actions.get(action + '.' + state);\n                });\n                return states;\n            }\n            else\n            {\n                return actions;\n            }\n        },\n\n        getActionForState: function (state)\n        {\n            if(this.has(state))\n            {\n                let actions = this.getActionsFor(null, true);\n                for(let action in actions)\n                {\n                    if(actions[action] === state)\n                    {\n                        return action;\n                    }\n                }\n            }\n            return null;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // flags\n\n        /**\n         * Test if the FSM has started\n         *\n         * @returns {boolean}\n         */\n        isStarted: function ()\n        {\n            return this.state !== '';\n        },\n\n        /**\n         * Test if the FSM is transitioning\n         *\n         * @returns {boolean}\n         */\n        isTransitioning: function ()\n        {\n            return !! this.transition;\n        },\n\n        /**\n         * Test if the FSM is paused (whilst transitioning)\n         *\n         * @returns {boolean}\n         */\n        isPaused: function ()\n        {\n            return this.transition\n                ? this.transition.paused\n                : false;\n        },\n\n        /**\n         * Test if the FSM is on the \"final\" state\n         *\n         * @returns {boolean}\n         */\n        isComplete: function ()\n        {\n            return this.state === this.config.final;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // transitions\n\n        /**\n         * Pause any current transition\n         *\n         * @returns {StateMachine}\n         */\n        pause: function ()\n        {\n            if(this.transition)\n            {\n                this.transition.pause();\n                this.update('transition', 'pause');\n                this.update('system', 'update');\n            }\n            return this;\n        },\n\n        /**\n         * Resume any current transition\n         *\n         * @returns {StateMachine}\n         */\n        resume: function ()\n        {\n            if(this.transition)\n            {\n                this.update('transition', 'resume');\n                this.update('system', 'update');\n                this.transition.resume();\n            }\n            return this;\n        },\n\n        /**\n         * Cancel any current transition\n         *\n         * @returns {StateMachine}\n         */\n        cancel: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.from;\n                this.transition.clear();\n                delete this.transition;\n                this.update('transition', 'cancel');\n                this.update('system', 'update');\n            }\n            return this;\n        },\n\n        /**\n         * End any current transition, skipping remaining handlers\n         *\n         * @returns {StateMachine}\n         */\n        end: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.to;\n                this.transition.clear();\n                delete this.transition;\n                this.update('system', 'change');\n                if(this.isComplete())\n                {\n                    this.update('system', 'complete');\n                }\n                this.update('system', 'update');\n            }\n            return this;\n        },\n\n        /**\n         * Reset the FSM to the initial, or supplied, state\n         *\n         * @returns {StateMachine}\n         */\n        reset:function(initial)\n        {\n            this.state = initial || this.config.initial;\n            if(this.transition)\n            {\n                this.transition.clear();\n                delete this.transition;\n            }\n            this.update('system', 'reset');\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // actions\n\n        /**\n         * Add a transition event\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        add: function (action, from, to)\n        {\n            this.actions.set(action + '.' + from, to);\n            this.transitions.add(from, action);\n            addState(this, from);\n            addState(this, to);\n            return this;\n        },\n\n        remove: function (action, from, to)\n        {\n            this.states.remove(action, from);\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // handlers\n\n        /**\n         * Add an event handler\n         *\n         * Event handler signature:\n         *\n         * - namespace.type:target1 target2 target3 ...\n         *\n         * Valid event signatures:\n         *\n         * - system:(change|update|complete|reset)\n         * - action:(start|end)\n         * - state:(add|remove|leave|enter)\n         * - transition:(pause|resume|cancel)\n         *\n         * As event types are unique, they can be used without the namespace:\n         *\n         * - change\n         * - pause\n         * - start\n         * - end\n         * - leave:red\n         * - enter:blue green\n         * - start:next\n         * - end:back\n         *\n         * You can also just pass action or names to target individual state.leave / action.end events:\n         *\n         * - next\n         * - intro\n         *\n         * @param id\n         * @param fn\n         * @return {StateMachine}\n         */\n        on: function (id, fn)\n        {\n            let [namespace, type, targets] = parseHandler(this, id);\n\n            targets.map( target =>\n            {\n                // warn for invalid actions / states\n                if(target !== '*')\n                {\n                    if(namespace === 'state')\n                    {\n                        if(this.states.indexOf(target) === -1)\n                        {\n                            this.config.debug && console.warn('Warning assigning state.%s handler: no such state \"%s\"', type, target);\n                        }\n                    }\n                    else if(namespace === 'action')\n                    {\n                        if(!this.actions.has(target))\n                        {\n                            this.config.debug && console.warn('Warning assigning action.%s handler: no such action \"%s\"', type, target);\n                        }\n                    }\n                }\n\n                // check handler is a function\n                if(!isFunction(fn))\n                {\n                    throw new Error('Error assigning ' +namespace+ '.' +type+ ' handler; callback is not a Function', fn);\n                }\n\n                // assign\n                let path = getPath(namespace, type, target);\n                this.handlers.insert(path, fn);\n            });\n\n            return this;\n        },\n\n        off: function (id, fn)\n        {\n            let [namespace, type, targets] = parseHandler(this, id);\n            targets.map( target =>\n            {\n                let path = getPath(namespace, type, target);\n                this.handlers.remove(path, fn)\n            });\n        },\n\n        dispatch: function(path, event)\n        {\n            this.config.debug && console.info('StateMachine dispatch \"%s\"', path);\n            let handlers = this.handlers.get(path);\n            if(handlers)\n            {\n                // do we need to pass additional arguments?\n                handlers.map(fn => fn(event) );\n            }\n        }\n\n};\n\n/**\n * Parses config and adds unique state names to states array\n *\n * @param {StateMachine}    fsm\n * @param {string}          key\n * @param {Object[]}        transitions\n */\nfunction addStates(fsm, key, transitions)\n{\n    transitions.map( event => addState(fsm, event[key]) );\n}\n\nfunction addState (fsm, state)\n{\n    if (isString(state) && fsm.states.indexOf(state) === -1)\n    {\n        fsm.states.push(state);\n    }\n}\n\nfunction parseHandler(fsm, id)\n{\n    // get initial matches\n    let matches = id.match(/^(?:(\\w+)\\.)?(\\w+[-.\\w]*)(?::(.*))?/);\n    if(!matches)\n    {\n        throw new Error('Warning parsing event handler: invalid signature \"%s\"', id);\n    }\n    let [,namespace, type, target] = matches;\n\n    // determine namespace if not found\n    if(!namespace)\n    {\n        // check if shorthand global was passed\n        namespace = eventNamespaces[type];\n\n        // if event is still null, attempt to determine type from existing states or actions\n        if(!namespace)\n        {\n            if(fsm.states.indexOf(type) !== -1)\n            {\n                target      = type;\n                namespace   = 'state';\n                type        = 'enter';\n            }\n            else if(fsm.actions.has(type))\n            {\n                target      = type;\n                namespace   = 'action';\n                type        = 'start';\n            }\n            else\n            {\n                fsm.config.debug && console.warn('Warning parsing event handler: unable to map \"%s\" to a valid event or existing entity', id);\n            }\n        }\n    }\n\n    // determine targets\n    let targets = target\n        ? target.match(/[-*\\w_]+/g)\n        : ['*'];\n\n    // return\n    return [namespace, type, targets]\n}\n\nfunction getPath(namespace, type, target)\n{\n    return namespace === 'action' || namespace === 'state'\n        ? [namespace, target, type].join('.')\n        : namespace + '.' + type;\n}\n\nlet eventNamespaces =\n{\n    change  :'system',\n    update  :'system',\n    complete:'system',\n    reset   :'system',\n\n    add     :'state',\n    remove  :'state',\n    leave   :'state',\n    enter   :'state',\n\n    start   :'action',\n    end     :'action',\n\n    pause   :'transition',\n    resume  :'transition',\n    cancel  :'transition'\n};\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/StateMachine.js\n **/","import {isObject, isArray, isDefined, isUndefined} from './utils';\n\n/**\n * Utility class to create, modify and delete nested hashes and values\n *\n * @constructor\n */\nexport default function ValueMap (data)\n{\n    this.data = data || {};\n}\n\nValueMap.prototype =\n{\n    data: null,\n\n    set: function (path, value)\n    {\n        set(this.data, path, value);\n        return this;\n    },\n\n    add:function(path, value)\n    {\n        add(this.data, path, value);\n        return this;\n    },\n\n    insert:function(path, value)\n    {\n        insert(this.data, path, value);\n        return this;\n    },\n\n    get:function(path)\n    {\n        return get(this.data, path);\n    },\n\n    has: function (path, value = undefined)\n    {\n        return has(this.data, path, value)\n    },\n\n    indexOf: function (path, value)\n    {\n        return indexOf(this.data, path, value)\n    },\n\n    remove: function (path, value = undefined)\n    {\n        remove(this.data, path, value);\n        return this;\n    },\n\n    keys:function(path)\n    {\n        return Object.keys(get(this.data, path));\n    },\n\n    values:function(path)\n    {\n        return values(this.data, path);\n    }\n\n};\n\nfunction create(obj, keys)\n{\n    let key;\n    while(keys.length)\n    {\n        key = keys.shift();\n        if( ! isObject(obj[key]) )\n        {\n            obj[key] = {};\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n\nexport function set(obj, path, value, index = -1)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    obj[key] = value;\n}\n\nfunction add(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    obj[key].push(value);\n}\n\nfunction insert(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    let parent = obj[key],\n        index = parent.indexOf(value);\n    if(index === -1)\n    {\n        parent.push(value);\n    }\n    else\n    {\n        parent[index] = value;\n    }\n}\n\nexport function get(obj, path)\n{\n    if(isUndefined(path) || path == '')\n    {\n        return obj;\n    }\n\n    let key,\n        keys = String(path).split('.');\n    while(keys.length > 1)\n    {\n        key = keys.shift();\n        if( ! obj.hasOwnProperty(key) )\n        {\n            return;\n        }\n        obj = obj[key];\n    }\n    key = keys.shift();\n    return obj[key];\n}\n\nexport function has(obj, path, value)\n{\n    let parent = get(obj, path);\n    return !! (isArray(parent) && isDefined(value)\n        ? parent.indexOf(value) !== -1\n        : isUndefined(value)\n            ? isDefined(parent)\n            : parent === value);\n}\n\nexport function indexOf (obj, path, value)\n{\n    let arr = get(obj, path);\n    if(isArray(arr))\n    {\n        return arr.indexOf(value);\n    }\n    return -1;\n}\n\nexport function remove(obj, path, value)\n{\n    let parent = obj,\n        keys = String(path || '').split('.'),\n        key = keys.pop();\n\n    if(keys.length)\n    {\n        parent = get(obj, keys.join('.'))\n    }\n    if(isDefined(value) && isArray(parent[key]))\n    {\n        parent = parent[key];\n        var index = parent.indexOf(value);\n        if(index > -1)\n        {\n            parent.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n    else\n    {\n        if(isObject(parent) && obj.hasOwnProperty(key))\n        {\n            delete parent[key];\n            return true;\n        }\n    }\n    return false\n}\n\nexport function values(obj, path)\n{\n    var values = [];\n    var target = get(obj, path);\n    if(isObject(target))\n    {\n        for(var name in target)\n        {\n            if(target.hasOwnProperty(name))\n            {\n                values.push(target[name]);\n            }\n        }\n    }\n    return values;\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/ValueMap.js\n **/","export function isObject (value)\n{\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport function isArray (value)\n{\n    return value instanceof Array;\n}\n\nexport function isString (value)\n{\n    return typeof value === 'string';\n}\n\nexport function isFunction(value)\n{\n    return value instanceof Function;\n}\n\nexport function isDefined (value)\n{\n    return typeof value !== 'undefined';\n}\n\nexport function isUndefined (value)\n{\n    return typeof value === 'undefined';\n}\n\nexport function trim (value)\n{\n    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/utils.js\n **/","import Events from './Events';\nimport { isFunction } from './utils/utils';\n\n/**\n * Transition class\n *\n * Responsible for managing events in the flow from state to state.\n *\n * This adds all handlers for the current action start/end and state from/to to an array:\n *\n * - <namespace>.<target>.<type>[]\n *\n * So going from state \"a\" to state \"b\" with action \"next\" should build:\n *\n * - action.*.start[]\n * - action.next.start[]\n * - state.a.leave[]\n * - state.*.leave[]\n * - state.*.enter[]\n * - state.b.enter[]\n * - action.next.end[]\n * - action.*.end[]\n *\n * This can be changed by passing in an order array in fsm.config\n *\n * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n *\n * From a callback, you can:\n *\n * - return false to cancel the transition\n * - return true to pause the transition\n * - not return a value (the transition continues)\n *\n * Transitions can also be paused, resumed, or cancelled by calling\n * the appropriate method on, or from:\n *\n * - the event\n * - the transition\n * - the state machine\n *\n * Cancelled transitions will reset the FSM to the previous \"from\" state\n *\n * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n *\n * @param {string}          action\n * @param {string}          from\n * @param {string}          to\n * @param {Function[]}      handlers\n * @param {Object}          callbacks\n */\nfunction Transition (action, from, to, handlers, callbacks)\n{\n    this.action     = action;\n    this.from       = from;\n    this.to         = to;\n    this.handlers   = handlers;\n    this.callbacks  = callbacks;\n}\n\nTransition.prototype =\n{\n    action      : '',\n    from        : '',\n    to          : '',\n    handlers    : null,\n    callbacks   : null,\n    paused      : false,\n\n    clear: function ()\n    {\n        this.paused = false;\n        this.handlers = [];\n    },\n\n    /**\n     * Execute the next event's callbacks\n     * @returns {*}\n     */\n\texec: function ()\n\t{\n\t    if( ! this.paused )\n        {\n            if(this.handlers.length)\n            {\n                var handler = this.handlers.shift();\n                var state = handler();\n                if(state === false)\n                {\n                    return this.callbacks.cancel();\n                }\n                if(state === true)\n                {\n                    return this.callbacks.pause();\n                }\n                this.exec();\n            }\n            else\n            {\n                this.callbacks.end();\n            }\n        }\n        return this;\n\t},\n\n    pause: function ()\n    {\n        this.paused = true;\n        return this;\n    },\n\n    resume: function ()\n    {\n        this.paused = false;\n        return this.exec();\n    }\n};\n\n\nexport default\n{\n    /**\n     * Create the Transition object\n     *\n     * - Set up variables, callbacks and queue\n     * - Determine paths to relevant callbacks\n     * - Build State and Action Event objects\n     * - Pre-bind all handlers\n     * - Append to queue\n     *\n     * @param {StateMachine}    fsm\n     * @param {string}          action\n     * @param {Array}           params\n     * @returns {Transition}\n     */\n    create:function (fsm, action, params)\n    {\n        // transition\n        var queue   = [];\n        var scope   = fsm.scope;\n        var from    = fsm.state;\n        var to      = fsm.actions.get(action)[from];\n        var callbacks =\n        {\n            cancel   :fsm.cancel.bind(fsm),\n            pause    :fsm.pause.bind(fsm),\n            resume   :fsm.resume.bind(fsm),\n            end      :fsm.end.bind(fsm)\n        };\n\n        // handle \"to\" being a function\n        if(isFunction(to))\n        {\n            let actions = fsm.getActionsFor();\n            let state   = to.apply(scope, [actions].concat(params));\n            let action  = fsm.getActionsFor(state);\n            // TODO debug this! It's wrong\n            if( ! action )\n            {\n                throw new Error('Cannot go to state \"' +state+ '\" from current state \"' +from+ '\"');\n            }\n        }\n\n        // build handlers array\n        fsm.config.order.map( token =>\n        {\n            // determine path variables\n            let [type, source]      = token.split(':'); // i.e. start.*, enter:to, end:action\n            let namespace           = /^(start|end)$/.test(type)\n                                        ? 'action'\n                                        : 'state';\n            let target;\n            if(source === '*')\n            {\n                target = '*';\n            }\n            else if(namespace == 'action')\n            {\n                target = action;\n            }\n            else\n            {\n                target = type === 'leave'\n                    ? from\n                    : to;\n            }\n\n            // get handlers\n            let path = [namespace, target, type].join('.');\n\n            let handlers = fsm.handlers.get(path);\n            if(handlers)\n            {\n                // pre-bind handlers, scopes and params\n                // this way scope and params don't need to be passed around\n                handlers = handlers.map( handler =>\n                {\n                    return function()\n                    {\n                        let event = Events.create(namespace, type, target, from, to, callbacks);\n                        handler.apply(scope, [event].concat(params));\n                    }\n                });\n\n                // add to queue\n                queue = queue.concat(handlers);\n            }\n\n        });\n\n        // create\n        return new Transition(action, from, to, queue, callbacks);\n    }\n\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/Transition.js\n **/","// ------------------------------------------------------------------------------------------------\n// setup\n\n    function noop () { }\n\n    /**\n     * @prop {string}  namespace  The Event namespace; i.e. state or action\n     * @prop {string}  type       The Event type;      i.e. leave/enter (state) or start/end (action)\n     * @prop {string}  target     The Event target;    i.e. intro (state), next (action), or * (all states or types)\n     * @prop {string}  from       The from state\n     * @prop {string}  to         The to state\n     */\n    let event =\n    {\n        // properties\n        namespace   : null,\n        type        : null,\n        target      : null,\n        from        : null,\n        to          : null,\n\n        // transition callbacks\n        pause       : noop,\n        resume      : noop,\n        cancel      : noop,\n        complete    : noop\n    };\n\n    function initialize (event, namespace, type, target, from, to, callbacks)\n    {\n        event.namespace = namespace;\n        event.type      = type;\n        event.target    = target;\n        event.from      = from;\n        event.to        = to;\n\n        event.pause     = callbacks.pause;\n        event.resume    = callbacks.resume;\n        event.cancel    = callbacks.cancel;\n        event.complete  = callbacks.complete;\n    }\n\n    export default\n    {\n        create: function(namespace, type, target, from, to, callbacks)\n        {\n            var fn = namespace == 'state'\n                ? StateEvent\n                : ActionEvent;\n            return new fn(type, target, from, to, callbacks);\n        }\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// ActionEvent\n\n    export function ActionEvent (type, target, from, to, callbacks)\n    {\n        initialize(this, 'action' ,type, target, from, to, callbacks);\n    }\n    ActionEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// StateEvent\n\n    export function StateEvent (type, target, from, to, callbacks)\n    {\n        initialize(this, 'state' ,type, target, from, to, callbacks);\n    }\n    StateEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// SystemEvent\n\n    export function SystemEvent (type)\n    {\n        this.type = type;\n    }\n\n    SystemEvent.prototype =\n    {\n        namespace: 'system',\n        type: ''\n    };\n\n\n// ------------------------------------------------------------------------------------------------\n// TransitionEvent\n\n    export function TransitionEvent (type)\n    {\n        this.type = type;\n    }\n\n    TransitionEvent.prototype =\n    {\n        namespace: 'transition',\n        type: ''\n    };\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/Events.js\n **/"],"sourceRoot":""}