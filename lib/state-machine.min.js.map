{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///state-machine.min.js","webpack:///webpack/bootstrap 7ccbc9b9ace992bae3de","webpack:///./src/StateMachine.js","webpack:///./src/utils/ValueMap.js","webpack:///./src/utils/utils.js","webpack:///./src/Transition.js","webpack:///./src/Events.js","webpack:///./src/utils/handlers.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","StateMachine","scope","config","arguments","length","_ref","state","states","transitions","_ValueMap2","actions","handlers","initialize","addStates","fsm","key","map","event","addState","_utils","isString","indexOf","push","Object","defineProperty","value","_typeof","Symbol","iterator","constructor","prototype","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","next","done","err","Array","isArray","TypeError","_ValueMap","_Transition","_Transition2","_Events","_handlers","parse","transition","_this","initial","matches","match","_matches","name","from","op","to","add","_ref2","hasOwnProperty","on","defer","defaults","assign","action","order","update","namespace","type","signature","SystemEvent","TransitionEvent","dispatch","do","can","isPaused","_len","rest","_key","create","exec","go","force","has","end","getActionForState","debug","console","info","warn","cannot","is","getStatesFor","getActionsFor","keys","_this2","asMap","get","_ret","v","isStarted","isTransitioning","paused","isComplete","pause","resume","cancel","clear","reset","set","remove","fn","_this3","result","log","paths","path","index","target","targets","isFunction","Error","insert","off","_this4","_this5","ValueMap","data","shift","isObject","String","split","pop","parent","isUndefined","isDefined","join","splice","values","_set","_get","_has","_indexOf","_remove","_values","toString","Function","trim","replace","Transition","handler","params","vars","apply","queue","all","token","_path$split","_path$split2","Event","StateEvent","ActionEvent","concat","isState","isAction","getTargets","determineValue","test","lookup","namespaces","segments","forEach","segment","char","events","ParseResult","start","change","complete","enter","leave"],"mappings":"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","file":"state-machine.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StateMachine\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StateMachine\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.default = StateMachine;\n\t\n\tvar _ValueMap = __webpack_require__(1);\n\t\n\tvar _ValueMap2 = _interopRequireDefault(_ValueMap);\n\t\n\tvar _Transition = __webpack_require__(3);\n\t\n\tvar _Transition2 = _interopRequireDefault(_Transition);\n\t\n\tvar _Events = __webpack_require__(4);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _handlers = __webpack_require__(5);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction StateMachine(scope, config) {\n\t    // allow [scope, config] or [config] as parameters\n\t    if (arguments.length == 1) {\n\t        var _ref = [scope, null];\n\t        config = _ref[0];\n\t        scope = _ref[1];\n\t    }\n\t\n\t    // assignment\n\t    this.scope = scope;\n\t    this.state = '';\n\t    this.states = [];\n\t    this.transitions = new _ValueMap2.default();\n\t    this.actions = new _ValueMap2.default();\n\t    this.handlers = new _ValueMap2.default();\n\t\n\t    // initialize\n\t    if (config) {\n\t        this.initialize(config);\n\t    }\n\t}\n\t\n\tStateMachine.parse = _handlers.parse;\n\t\n\t/**\n\t * StateMachine prototype\n\t *\n\t * The property examples below illustrate a 4-state machine, with states:\n\t *\n\t * - intro > settings > summary > end\n\t *\n\t * And actions:\n\t *\n\t * - back | next | restart | finish\n\t */\n\tStateMachine.prototype = {\n\t    // ------------------------------------------------------------------------------------------------\n\t    // properties\n\t\n\t    /**\n\t     * Available state names\n\t     *\n\t     * - [\n\t     *     intro,\n\t     *     settings,\n\t     *     summary,\n\t     *     final\n\t     *   ]\n\t     *\n\t     * @var {string[]}\n\t     */\n\t    states: null,\n\t\n\t    /**\n\t     * Available transitions for each action\n\t     *\n\t     * action.from => to\n\t     *\n\t     * - next: {\n\t     *     intro: settings,\n\t     *     settings: summary\n\t     *   },\n\t     * - back: {\n\t     *     settings: intro\n\t     *   },\n\t     * - restart: {\n\t     *     summary:intro\n\t     *   },\n\t     * - finish: {\n\t     *     summary:final\n\t     *   },\n\t     *\n\t     * Transitions can also be functions\n\t     *\n\t     * - next: {\n\t     *     intro: function() { return '<random state>' } // jump to a random state\n\t     *   }\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    transitions: null,\n\t\n\t    /**\n\t     * Actions that are available to be called from each state\n\t     *\n\t     * state => [ action, action, ... ]\n\t     *\n\t     * - intro: [\n\t     *     'next'\n\t     *   ],\n\t     * - settings: [\n\t     *     'next',\n\t     *     'back'\n\t     *   ],\n\t     * - summary: [\n\t     *     'restart'\n\t     *     'finish',\n\t     *   ]\n\t     *\n\t     * Actions can also be expressed as wildcards\n\t     *\n\t     * - intro: [\n\t     *     '*' // any action is allowed from intro\n\t     *   ]\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    actions: null,\n\t\n\t    /**\n\t     * Handler functions that should be called on each action event / state change\n\t     *\n\t     * name.type => [ handler, handler, ... ]\n\t     *\n\t     * - next: {\n\t     *   - start: [\n\t     *       hideModal\n\t     *     ],\n\t     *   - end: [\n\t     *       showModal\n\t     *     ]\n\t     *   },\n\t     * - summary: {\n\t     *   - enter: [\n\t     *       resetForm\n\t     *     ],\n\t     *   - leave: [\n\t     *       validateForm,\n\t     *       postData,\n\t     *     ]\n\t     *   },\n\t     *   ...\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    handlers: null,\n\t\n\t    /**\n\t     * The current state\n\t     *\n\t     * @var {string}\n\t     */\n\t    state: '',\n\t\n\t    /**\n\t     * Any active Transition object that is driving the state change\n\t     *\n\t     * @var {Transition}\n\t     */\n\t    transition: null,\n\t\n\t    /**\n\t     * The scope in which to call all handlers\n\t     *\n\t     * @var {*}\n\t     */\n\t    scope: null,\n\t\n\t    /**\n\t     * The original config object\n\t     *\n\t     * @var {Object}\n\t     */\n\t    config: null,\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // private methods\n\t\n\t    /**\n\t     * Initialize the FSM with a config object\n\t     *\n\t     * @private\n\t     * @param config\n\t     */\n\t    initialize: function initialize(config) {\n\t        var _this = this;\n\t\n\t        // assign config\n\t        this.config = config;\n\t\n\t        // scope\n\t        if (config.scope) {\n\t            this.scope = config.scope;\n\t        }\n\t\n\t        // pre-collate all states\n\t        addStates(this, 'from', config.transitions);\n\t        addStates(this, 'to', config.transitions);\n\t\n\t        // initial state\n\t        if (!config.initial) {\n\t            config.initial = this.states[0];\n\t        }\n\t\n\t        // add transitions\n\t        if (Array.isArray(config.transitions)) {\n\t            config.transitions.map(function (transition) {\n\t                // shorthand\n\t                if ((0, _utils.isString)(transition)) {\n\t                    var matches = transition.match(/(\\w+)\\s*[|:=]\\s*(\\w+)\\s*([<>-])\\s*(\\w.*)/);\n\t\n\t                    var _matches = _slicedToArray(matches, 5);\n\t\n\t                    var name = _matches[1];\n\t                    var from = _matches[2];\n\t                    var op = _matches[3];\n\t                    var to = _matches[4];\n\t\n\t                    if (op === '-') {\n\t                        _this.add(name, from, to);\n\t                        _this.add(name, to, from);\n\t                        return;\n\t                    }\n\t                    if (op === '<') {\n\t                        var _ref2 = [to, from];\n\t                        from = _ref2[0];\n\t                        to = _ref2[1];\n\t                    }\n\t                    _this.add(name, from, to);\n\t                }\n\t\n\t                // keys\n\t                else {\n\t                        _this.add(transition.name, transition.from, transition.to);\n\t                    }\n\t            });\n\t        }\n\t\n\t        // add handlers\n\t        if (config.handlers) {\n\t            for (var name in config.handlers) {\n\t                if (config.handlers.hasOwnProperty(name)) {\n\t                    this.on(name, config.handlers[name]);\n\t                }\n\t            }\n\t        }\n\t\n\t        // start automatically unless defer is set to true\n\t        if (!config.defer) {\n\t            this.state = config.initial;\n\t        }\n\t\n\t        /**\n\t         * Sets defaults for various declarations\n\t         *\n\t         * @type {Object}\n\t         */\n\t        config.defaults = Object.assign({\n\t\n\t            // initialize event\n\t            initialize: 'initialize',\n\t\n\t            // handler defaults\n\t            action: 'start',\n\t            state: 'enter'\n\t\n\t        }, config.defaults);\n\t\n\t        /**\n\t         * Sets the default order to run transition callbacks in\n\t         *\n\t         * @type {string[]} type.target\n\t         */\n\t        config.order = config.order || ['action.*.start', 'action.{action}.start', 'state.{*}.{action}', 'state.{from}.{action}', 'state.{from}.leave', 'state.*.leave', 'state.*.enter', 'state.{to}.enter', 'action.{action}.end', 'action.*.end'];\n\t    },\n\t\n\t    /**\n\t     * Dispatch an event\n\t     *\n\t     * @param   {string}    namespace\n\t     * @param   {string}    type\n\t     * @param   {string}    key\n\t     * @param   {*}         value\n\t     * @returns {StateMachine}\n\t     */\n\t    update: function update(namespace, type) {\n\t        var key = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\t        var value = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\t\n\t        var signature = namespace + '.' + type;\n\t        var event = namespace === 'system' ? new _Events.SystemEvent(type, key, value) : new _Events.TransitionEvent(type);\n\t        this.dispatch(signature, event);\n\t        return this;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // api\n\t\n\t    /**\n\t     * Attempt to run an action, resulting in a transition to a state\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {*[]}       rest\n\t     * @returns {boolean}\n\t     */\n\t    do: function _do(action) {\n\t        if (this.can(action) && !this.isPaused()) {\n\t            for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                rest[_key - 1] = arguments[_key];\n\t            }\n\t\n\t            this.transition = _Transition2.default.create(this, action, rest);\n\t            if (action === this.config.defaults.initialize) {\n\t                this.update('system', 'initialize');\n\t            }\n\t            this.update('system', 'update', 'transition', this.transition);\n\t            this.transition.exec();\n\t            return true;\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Attempt to go to a state\n\t     *\n\t     * Finds if an appropriate transition exists, then calls the related action if it does\n\t     *\n\t     * @param   {string}    state\n\t     * @param   {boolean}   [force]\n\t     * @returns {boolean}\n\t     */\n\t    go: function go(state) {\n\t        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        if (this.has(state)) {\n\t            if (force) {\n\t                this.transition = _Transition2.default.force(this, state);\n\t                return this.end();\n\t            }\n\t            var action = this.getActionForState(state);\n\t            if (action) {\n\t                return this.do(action);\n\t            }\n\t            this.config.debug && console.info('No transition exists from \"%s\" to \"%s\"', this.state, state);\n\t        } else {\n\t            this.config.debug && console.warn('No such state \"%s\"', state);\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Query a transition to see if a named action is available\n\t     *\n\t     * @param   {string}    action\n\t     * @returns {boolean}\n\t     */\n\t    can: function can(action) {\n\t        if (!this.actions.has(action)) {\n\t            this.config.debug && console.warn('No such action \"%s\"', action);\n\t        }\n\t        return !!this.transitions.has(this.state, action);\n\t    },\n\t\n\t    /**\n\t     * Query a transition to see if a named action is unavailable\n\t     *\n\t     * @param   {string}    action\n\t     * @returns {boolean}\n\t     */\n\t    cannot: function cannot(action) {\n\t        return !this.can(action);\n\t    },\n\t\n\t    /**\n\t     * Test if the current state is the same as the supplied one\n\t     *\n\t     * @param   {string}    state       A state name to compare against the current state\n\t     * @returns {boolean}\n\t     */\n\t    is: function is(state) {\n\t        if (this.states.indexOf(state) === -1) {\n\t            this.config.debug && console.warn('No such state \"%s\"', state);\n\t        }\n\t        return state === this.state;\n\t    },\n\t\n\t    /**\n\t     * Test if a state exists\n\t     *\n\t     * @param   {string}    state\n\t     * @return  {boolean}\n\t     */\n\t    has: function has(state) {\n\t        return this.states.indexOf(state) !== -1;\n\t    },\n\t\n\t    /**\n\t     * Get the available \"to\" states for the current or supplied state\n\t     *\n\t     * @param   {string}    [state]     Optional name of a state to get states for. Defaults to the current state\n\t     * @returns {string[]}              An array of string states\n\t     */\n\t    getStatesFor: function getStatesFor() {\n\t        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\n\t        state = state || this.state;\n\t        var actions = this.getActionsFor(state, true);\n\t        return Object.keys(actions).map(function (name) {\n\t            return actions[name];\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Get the available actions (or actions and states) for the current or supplied state\n\t     *\n\t     * @param   {string}    [state]     Optional name of a state to get actions for. Defaults to the current state\n\t     * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n\t     * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n\t     */\n\t    getActionsFor: function getActionsFor() {\n\t        var _this2 = this;\n\t\n\t        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t        var asMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        state = state || this.state;\n\t        var actions = this.transitions.get(state || this.state);\n\t        if (asMap) {\n\t            var _ret = function () {\n\t                var states = {};\n\t                actions.map(function (action) {\n\t                    states[action] = _this2.actions.get(action + '.' + state);\n\t                });\n\t                return {\n\t                    v: states\n\t                };\n\t            }();\n\t\n\t            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t        } else {\n\t            return actions;\n\t        }\n\t    },\n\t\n\t    getActionForState: function getActionForState(state) {\n\t        if (this.has(state)) {\n\t            var actions = this.getActionsFor(state, true);\n\t            for (var action in actions) {\n\t                if (actions[action] === state) {\n\t                    return action;\n\t                }\n\t            }\n\t        }\n\t        return null;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // flags\n\t\n\t    /**\n\t     * Test if the FSM has started\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isStarted: function isStarted() {\n\t        return this.state !== '';\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is transitioning\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isTransitioning: function isTransitioning() {\n\t        return !!this.transition;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is paused (whilst transitioning)\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isPaused: function isPaused() {\n\t        return this.transition ? this.transition.paused : false;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is on the \"final\" state\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isComplete: function isComplete() {\n\t        return this.state === this.config.final;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // transitions\n\t\n\t    /**\n\t     * Pause any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    pause: function pause() {\n\t        if (this.transition && !this.isPaused()) {\n\t            this.transition.pause();\n\t            this.update('transition', 'pause');\n\t            this.update('system', 'update', 'pause', true);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Resume any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    resume: function resume() {\n\t        if (this.transition && this.isPaused()) {\n\t            this.update('transition', 'resume');\n\t            this.update('system', 'update', 'pause', false);\n\t            this.transition.resume();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Cancel any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    cancel: function cancel() {\n\t        if (this.transition) {\n\t            if (this.isPaused()) {\n\t                this.update('system', 'update', 'pause', false);\n\t            }\n\t            this.state = this.transition.from;\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('transition', 'cancel');\n\t            this.update('system', 'update', 'transition', null);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * End any current transition, skipping remaining handlers\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    end: function end() {\n\t        if (this.transition) {\n\t            if (this.isPaused()) {\n\t                this.update('system', 'update', 'pause', false);\n\t            }\n\t            this.state = this.transition.to;\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('system', 'change', 'state', this.state);\n\t            this.update('system', 'update', 'state', this.state);\n\t            if (this.isComplete()) {\n\t                this.update('system', 'complete');\n\t            }\n\t            this.update('system', 'update', 'transition', null);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Reset the FSM to the initial, or supplied, state\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    reset: function reset() {\n\t        var initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t\n\t        var state = initial || this.config.initial;\n\t        this.update('system', 'reset');\n\t        if (this.transition) {\n\t            if (this.isPaused()) {\n\t                this.update('system', 'update', 'pause', false);\n\t            }\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('transition', 'cancel');\n\t            this.update('system', 'update', 'transition', null);\n\t        }\n\t        if (this.state !== state) {\n\t            this.state = state;\n\t            this.update('system', 'change', 'state', this.state);\n\t            this.update('system', 'update', 'state', this.state);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // actions\n\t\n\t    /**\n\t     * Add a transition\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @return  {StateMachine}\n\t     */\n\t    add: function add(action, from, to) {\n\t        this.actions.set(action + '.' + from, to);\n\t        this.transitions.add(from, action);\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Remove a transition\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @return  {StateMachine}\n\t     */\n\t    remove: function remove(action, from, to) {\n\t        this.states.remove(action, from);\n\t        return this;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // handlers\n\t\n\t    /**\n\t     * Add an event handler\n\t     *\n\t     * Event handler signatures are build from the following grammar:\n\t     *\n\t     * - token      foo\n\t     * - property   .foo\n\t     * - event      :foo\n\t     * - action     @foo\n\t     * - targets    (foo|bar|baz)\n\t     *\n\t     * For example:\n\t     *\n\t     * - change\n\t     * - transition.pause\n\t     * - next:end\n\t     * - (a|b)@next\n\t     * - a@next\n\t     *\n\t     * The main event types are unique, so can be used without the namespace:\n\t     *\n\t     * - change\n\t     * - pause\n\t     * - complete\n\t     * - ...\n\t     *\n\t     * If your states and events are unique, they can also be used without qualification.\n\t     *\n\t     * See docs and demo for more information\n\t     *\n\t     * @param   {string}        id\n\t     * @param   {Function}      fn\n\t     * @return  {StateMachine}\n\t     */\n\t    on: function on(id, fn) {\n\t        var _this3 = this;\n\t\n\t        /** @type {ParseResult} */\n\t        var result = (0, _handlers.parse)(this, id);\n\t\n\t        if (this.config.debug) {\n\t            console.log('StateMachine on: ' + id, [result.namespace, result.type], result.paths);\n\t        }\n\t\n\t        result.paths.map(function (path, index) {\n\t            var target = result.targets[index];\n\t\n\t            // warn for invalid actions / states\n\t            if (target !== '*') {\n\t                if (result.namespace === 'state') {\n\t                    if (_this3.states.indexOf(target) === -1) {\n\t                        _this3.config.debug && console.warn('StateMachine: Warning assigning state.%s handler; no such state \"%s\"', result.type, target);\n\t                    }\n\t                } else if (result.namespace === 'action') {\n\t                    if (!_this3.actions.has(target)) {\n\t                        _this3.config.debug && console.warn('StateMachine: Warning assigning action.%s handler; no such action \"%s\"', result.type, target);\n\t                    }\n\t                }\n\t            }\n\t\n\t            // check handler is a function\n\t            if (!(0, _utils.isFunction)(fn)) {\n\t                throw new Error('Error assigning ' + result.namespace + '.' + result.type + ' handler; callback is not a Function', fn);\n\t            }\n\t\n\t            // assign\n\t            _this3.handlers.insert(path, fn);\n\t        });\n\t\n\t        return this;\n\t    },\n\t\n\t    off: function off(id, fn) {\n\t        var _this4 = this;\n\t\n\t        var result = (0, _handlers.parse)(this, id);\n\t        result.paths.map(function (path) {\n\t            _this4.handlers.remove(path, fn);\n\t        });\n\t    },\n\t\n\t    dispatch: function dispatch(path, event) {\n\t        var _this5 = this;\n\t\n\t        this.config.debug && console.info('StateMachine: dispatch \"%s\"', path);\n\t        var handlers = this.handlers.get(path);\n\t        if (handlers) {\n\t            handlers.map(function (fn) {\n\t                return fn(event, _this5);\n\t            });\n\t        }\n\t    }\n\t\n\t};\n\t\n\t/**\n\t * Parses config and adds unique state names to states array\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          key\n\t * @param {Object[]}        transitions\n\t */\n\tfunction addStates(fsm, key, transitions) {\n\t    if (transitions) {\n\t        transitions.map(function (event) {\n\t            return addState(fsm, event[key]);\n\t        });\n\t    }\n\t}\n\t\n\tfunction addState(fsm, state) {\n\t    if ((0, _utils.isString)(state) && fsm.states.indexOf(state) === -1) {\n\t        fsm.states.push(state);\n\t    }\n\t}\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.values = exports.remove = exports.indexOf = exports.has = exports.get = exports.set = undefined;\n\texports.default = ValueMap;\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\t/**\n\t * Utility class to create, modify and delete nested hashes and values\n\t *\n\t * @constructor\n\t */\n\tfunction ValueMap(data) {\n\t    this.data = data || {};\n\t}\n\t\n\tValueMap.prototype = {\n\t    data: null,\n\t\n\t    set: function set(path, value) {\n\t        _set(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    add: function add(path, value) {\n\t        _add(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    insert: function insert(path, value) {\n\t        _insert(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    get: function get(path) {\n\t        return _get(this.data, path);\n\t    },\n\t\n\t    has: function has(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        return _has(this.data, path, value);\n\t    },\n\t\n\t    indexOf: function indexOf(path, value) {\n\t        return _indexOf(this.data, path, value);\n\t    },\n\t\n\t    remove: function remove(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        _remove(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    keys: function keys(path) {\n\t        return Object.keys(_get(this.data, path));\n\t    },\n\t\n\t    values: function values(path) {\n\t        return _values(this.data, path);\n\t    }\n\t\n\t};\n\t\n\tfunction create(obj, keys) {\n\t    var key = void 0;\n\t    while (keys.length) {\n\t        key = keys.shift();\n\t        if (!(0, _utils.isObject)(obj[key])) {\n\t            obj[key] = {};\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    return obj;\n\t}\n\t\n\tfunction _set(obj, path, value) {\n\t    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n\t\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    obj[key] = value;\n\t}\n\t\n\texports.set = _set;\n\tfunction _add(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    obj[key].push(value);\n\t}\n\t\n\tfunction _insert(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    var parent = obj[key],\n\t        index = parent.indexOf(value);\n\t    if (index === -1) {\n\t        parent.push(value);\n\t    } else {\n\t        parent[index] = value;\n\t    }\n\t}\n\t\n\tfunction _get(obj, path) {\n\t    if ((0, _utils.isUndefined)(path) || path == '') {\n\t        return obj;\n\t    }\n\t\n\t    var key = void 0,\n\t        keys = String(path).split('.');\n\t    while (keys.length > 1) {\n\t        key = keys.shift();\n\t        if (!obj.hasOwnProperty(key)) {\n\t            return;\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    key = keys.shift();\n\t    return obj[key];\n\t}\n\t\n\texports.get = _get;\n\tfunction _has(obj, path, value) {\n\t    var parent = _get(obj, path);\n\t    return !!((0, _utils.isArray)(parent) && (0, _utils.isDefined)(value) ? parent.indexOf(value) !== -1 : (0, _utils.isUndefined)(value) ? (0, _utils.isDefined)(parent) : parent === value);\n\t}\n\t\n\texports.has = _has;\n\tfunction _indexOf(obj, path, value) {\n\t    var arr = _get(obj, path);\n\t    if ((0, _utils.isArray)(arr)) {\n\t        return arr.indexOf(value);\n\t    }\n\t    return -1;\n\t}\n\t\n\texports.indexOf = _indexOf;\n\tfunction _remove(obj, path, value) {\n\t    var parent = obj,\n\t        keys = String(path || '').split('.'),\n\t        key = keys.pop();\n\t\n\t    if (keys.length) {\n\t        parent = _get(obj, keys.join('.'));\n\t    }\n\t    if ((0, _utils.isDefined)(value) && (0, _utils.isArray)(parent[key])) {\n\t        var target = parent[key];\n\t        var index = target.indexOf(value);\n\t        if (index > -1) {\n\t            target.splice(index, 1);\n\t            if (target.length === 0) {\n\t                delete parent[key];\n\t            }\n\t            return true;\n\t        }\n\t        return false;\n\t    } else {\n\t        if ((0, _utils.isObject)(parent) && obj.hasOwnProperty(key)) {\n\t            delete parent[key];\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\t\n\texports.remove = _remove;\n\tfunction _values(obj, path) {\n\t    var values = [];\n\t    var target = _get(obj, path);\n\t    if ((0, _utils.isObject)(target)) {\n\t        for (var name in target) {\n\t            if (target.hasOwnProperty(name)) {\n\t                values.push(target[name]);\n\t            }\n\t        }\n\t    }\n\t    return values;\n\t}\n\texports.values = _values;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.isObject = isObject;\n\texports.isArray = isArray;\n\texports.isString = isString;\n\texports.isFunction = isFunction;\n\texports.isDefined = isDefined;\n\texports.isUndefined = isUndefined;\n\texports.trim = trim;\n\tfunction isObject(value) {\n\t    return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\t\n\tfunction isArray(value) {\n\t    return value instanceof Array;\n\t}\n\t\n\tfunction isString(value) {\n\t    return typeof value === 'string';\n\t}\n\t\n\tfunction isFunction(value) {\n\t    return value instanceof Function;\n\t}\n\t\n\tfunction isDefined(value) {\n\t    return typeof value !== 'undefined';\n\t}\n\t\n\tfunction isUndefined(value) {\n\t    return typeof value === 'undefined';\n\t}\n\t\n\tfunction trim(value) {\n\t    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _Events = __webpack_require__(4);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\t/**\n\t * Transition class\n\t *\n\t * Responsible for managing events in the flow from state to state.\n\t *\n\t * This adds all handlers for the current action start/end and state from/to to an array:\n\t *\n\t * - <namespace>.<target>.<type>[]\n\t *\n\t * So going from state \"a\" to state \"b\" with action \"next\" should build:\n\t *\n\t * - action.*.start[]\n\t * - action.next.start[]\n\t * - state.a.leave[]\n\t * - state.*.leave[]\n\t * - state.*.enter[]\n\t * - state.b.enter[]\n\t * - action.next.end[]\n\t * - action.*.end[]\n\t *\n\t * This can be changed by passing in an order array in fsm.config\n\t *\n\t * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n\t *\n\t * From a callback, you can:\n\t *\n\t * - return false to cancel the transition\n\t * - return true to pause the transition\n\t * - not return a value (the transition continues)\n\t *\n\t * Transitions can also be paused, resumed, or cancelled by calling\n\t * the appropriate method on, or from:\n\t *\n\t * - the event\n\t * - the transition\n\t * - the state machine\n\t *\n\t * Cancelled transitions will reset the FSM to the previous \"from\" state\n\t *\n\t * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          action\n\t * @param {string}          from\n\t * @param {string}          to\n\t */\n\tfunction Transition(fsm, action, from, to) {\n\t    this.fsm = fsm;\n\t    this.action = action;\n\t    this.from = from;\n\t    this.to = to;\n\t    this.clear();\n\t}\n\t\n\t/**\n\t * @prop {StateMachine}    fsm\n\t * @prop {string}          action\n\t * @prop {string}          from\n\t * @prop {string}          to\n\t * @prop {Function[]}      handlers\n\t */\n\tTransition.prototype = {\n\t    fsm: null,\n\t    action: '',\n\t    from: '',\n\t    to: '',\n\t    paused: false,\n\t    handlers: null,\n\t\n\t    clear: function clear() {\n\t        this.paused = false;\n\t        this.handlers = [];\n\t    },\n\t\n\t    /**\n\t     * Execute the next event's callbacks\n\t     * @returns {*}\n\t     */\n\t    exec: function exec() {\n\t        if (!this.paused) {\n\t            if (this.handlers.length) {\n\t                var handler = this.handlers.shift();\n\t                var state = handler();\n\t                if (state === false) {\n\t                    return this.fsm.cancel();\n\t                }\n\t                if (state === true) {\n\t                    return this.fsm.pause();\n\t                }\n\t                this.exec();\n\t            } else {\n\t                this.fsm.end();\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t\n\t    pause: function pause() {\n\t        this.paused = true;\n\t        return this;\n\t    },\n\t\n\t    resume: function resume() {\n\t        this.paused = false;\n\t        return this.exec();\n\t    }\n\t};\n\t\n\texports.default = {\n\t    /**\n\t     * Create the Transition object\n\t     *\n\t     * - Set up variables, and queue\n\t     * - Determine paths to relevant handlers\n\t     * - Build State and Action Event objects\n\t     * - Pre-bind all handlers\n\t     * - Append to queue\n\t     *\n\t     * @param {StateMachine}    fsm\n\t     * @param {string}          action\n\t     * @param {Array}           params\n\t     * @returns {Transition}\n\t     */\n\t    create: function create(fsm, action, params) {\n\t        // transition properties\n\t        var scope = fsm.scope;\n\t        var from = fsm.state;\n\t        var to = fsm.actions.get(action)[from];\n\t        var vars = { action: action, to: to, from: from };\n\t\n\t        // handle \"to\" being a function\n\t        if ((0, _utils.isFunction)(to)) {\n\t            to = to.apply(scope, params);\n\t            if (fsm.states.indexOf(to) === -1) {\n\t                throw new Error('Invalid \"to\" state \"' + to + '\"');\n\t            }\n\t        }\n\t\n\t        // transition\n\t        var queue = [];\n\t        var transition = new Transition(fsm, action, from, to);\n\t\n\t        // build handlers array\n\t        fsm.config.order.map(function (path) {\n\t            // replace path tokens\n\t            path = path.replace(/{(\\w+)}/g, function (all, token) {\n\t                return vars[token];\n\t            });\n\t            var handlers = fsm.handlers.get(path);\n\t\n\t            // do it!\n\t            if (handlers) {\n\t                (function () {\n\t                    var _path$split = path.split('.');\n\t\n\t                    var _path$split2 = _slicedToArray(_path$split, 3);\n\t\n\t                    var namespace = _path$split2[0];\n\t                    var target = _path$split2[1];\n\t                    var type = _path$split2[2];\n\t\n\t                    handlers = handlers.map(function (handler) {\n\t                        // build event object\n\t                        var Event = namespace === 'state' ? _Events.StateEvent : _Events.ActionEvent;\n\t                        var event = new Event(type, target, transition);\n\t\n\t                        // pre-bind handlers, scopes and params\n\t                        // this way scope and params don't need to be passed around\n\t                        // and the call from Transition is always just `value = handler()`\n\t                        return function () {\n\t                            return handler.apply(scope, [event, fsm].concat(params));\n\t                        };\n\t                    });\n\t\n\t                    // add to queue\n\t                    queue = queue.concat(handlers);\n\t                })();\n\t            }\n\t        });\n\t\n\t        // return\n\t        transition.handlers = queue;\n\t        return transition;\n\t    },\n\t\n\t    force: function force(fsm, state) {\n\t        var transition = new Transition(fsm, '', fsm.state, state);\n\t        transition.paused = fsm.transition ? fsm.transition.paused : false;\n\t        return transition;\n\t    }\n\t\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ActionEvent = ActionEvent;\n\texports.StateEvent = StateEvent;\n\texports.SystemEvent = SystemEvent;\n\texports.TransitionEvent = TransitionEvent;\n\t// ------------------------------------------------------------------------------------------------\n\t// setup\n\t\n\t/**\n\t * @prop {string}       namespace   The Event namespace; i.e. state or action\n\t * @prop {string}       type        The Event type;      i.e. leave/enter (state) or start/end (action)\n\t * @prop {string}       target      The Event target;    i.e. intro (state), next (action), or * (all states or types)\n\t * @prop {Transition}   transition  The transition which generated the event\n\t */\n\tvar event = {\n\t    // properties\n\t    namespace: null,\n\t    type: null,\n\t    target: null,\n\t    transition: null\n\t};\n\t\n\tfunction initialize(event, namespace, type, target, transition) {\n\t    event.namespace = namespace;\n\t    event.type = type;\n\t    event.target = target;\n\t    event.transition = transition;\n\t}\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// ActionEvent\n\t\n\tfunction ActionEvent(type, target, transition) {\n\t    initialize(this, 'action', type, target, transition);\n\t}\n\tActionEvent.prototype = event;\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// StateEvent\n\t\n\tfunction StateEvent(type, target, transition) {\n\t    initialize(this, 'state', type, target, transition);\n\t}\n\tStateEvent.prototype = event;\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// SystemEvent\n\t\n\tfunction SystemEvent(type, key, value) {\n\t    this.type = type;\n\t    this.key = key;\n\t    this.value = value;\n\t}\n\t\n\tSystemEvent.prototype = {\n\t    namespace: 'system',\n\t    type: '',\n\t    key: '',\n\t    value: null\n\t};\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// TransitionEvent\n\t\n\tfunction TransitionEvent(type) {\n\t    this.type = type;\n\t}\n\t\n\tTransitionEvent.prototype = {\n\t    namespace: 'transition',\n\t    type: ''\n\t};\n\n/***/ },\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.parse = parse;\n\tvar lookup = {\n\t    namespaces: {\n\t        start: 'system',\n\t        change: 'system',\n\t        update: 'system',\n\t        complete: 'system',\n\t        reset: 'system',\n\t        add: 'system',\n\t        remove: 'system',\n\t\n\t        pause: 'transition',\n\t        resume: 'transition',\n\t        cancel: 'transition'\n\t    },\n\t\n\t    events: {\n\t        start: 'action',\n\t        end: 'action',\n\t        enter: 'state',\n\t        leave: 'state'\n\t    }\n\t};\n\t\n\t/**\n\t * Parses an event handler id into namespace, type, and target variables\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          id\n\t * @return {ParseResult}\n\t */\n\tfunction parse(fsm, id) {\n\t    // variables\n\t    var defaults = fsm.config.defaults,\n\t        segments = void 0,\n\t        namespace = void 0,\n\t        type = void 0,\n\t        targets = void 0;\n\t\n\t    // utility functions\n\t    function isState(value) {\n\t        return fsm.states.indexOf(value) !== -1;\n\t    }\n\t\n\t    function isAction(value) {\n\t        return fsm.actions.has(value);\n\t    }\n\t\n\t    function getTargets(value) {\n\t        return value ? value.match(/\\w[-\\w]*/g) : ['*'];\n\t    }\n\t\n\t    function determineValue(value) {\n\t\n\t        // is namespace, i.e. system, transition, state, action\n\t        if (/^(system|transition|state|action)$/.test(value)) {\n\t            namespace = value;\n\t        }\n\t\n\t        // is shortcut, i.e. update, change, pause, cancel\n\t        else if (value in lookup.namespaces) {\n\t                namespace = lookup.namespaces[value];\n\t                type = value;\n\t            }\n\t\n\t            // is state or action, i.e. a, next\n\t            else if (isState(value) || isAction(value)) {\n\t                    if (!namespace) {\n\t                        namespace = isState(value) ? 'state' : 'action';\n\t                    }\n\t\n\t                    // special case for state with action\n\t                    if (namespace === 'state' && isAction(value)) {\n\t                        type = value;\n\t                    }\n\t\n\t                    if (!targets) {\n\t                        targets = getTargets(value);\n\t                    }\n\t                }\n\t\n\t                // action event, i.e. :event\n\t                else if (/^(enter|leave)$/.test(value)) {\n\t                        type = value;\n\t                    }\n\t    }\n\t\n\t    // process\n\t    segments = id.match(/:\\w+|@\\w+|\\(.+?\\)|\\.\\w+|\\w+/g);\n\t\n\t    // return an empty result if no matches\n\t    if (!segments) {\n\t        return new ParseResult();\n\t    }\n\t\n\t    /**\n\t     * This is the engine of the parse process\n\t     *\n\t     * The regex above matches the grammar of the expression into an array:\n\t     *\n\t     * - transition.pause   => [\"transition\", \".pause\"]\n\t     * - (a|b)@next         => [\"(a|b)\", \"@next\"]\n\t     * - a@next             => [\"a\", \"@next\"]\n\t     *\n\t     * Each segment is then analysed for its type and content, either directly\n\t     * or via the utility functions above which update the local variables.\n\t     */\n\t    segments.forEach(function (segment, i, segments) {\n\t        // variables\n\t        var char = segment[0];\n\t        var values = segment.match(/\\w+/g);\n\t        var value = values[0];\n\t        switch (char) {\n\t            // event\n\t            case ':':\n\t                namespace = lookup.events[value];\n\t                type = value;\n\t                break;\n\t\n\t            // action\n\t            case '@':\n\t                namespace = 'state';\n\t                type = value;\n\t                break;\n\t\n\t            // targets\n\t            case '(':\n\t                targets = values;\n\t                namespace = isState(values[0]) ? 'state' : 'action';\n\t                break;\n\t\n\t            // property\n\t            case '.':\n\t                determineValue(value);\n\t                break;\n\t\n\t            // single word\n\t            default:\n\t                determineValue(segment);\n\t        }\n\t    });\n\t\n\t    // final determination\n\t    if (!targets) {\n\t        targets = getTargets();\n\t    }\n\t\n\t    if (!namespace) {\n\t        namespace = isState(targets[0]) ? 'state' : 'action';\n\t    }\n\t\n\t    if (!type) {\n\t        type = defaults[namespace];\n\t    }\n\t\n\t    // return result\n\t    return new ParseResult(namespace, type, targets);\n\t}\n\t\n\tfunction ParseResult(namespace, type, targets) {\n\t    if (namespace) {\n\t        this.namespace = namespace;\n\t        this.type = type;\n\t        this.targets = targets;\n\t        this.paths = targets.map(function (target) {\n\t            return namespace === 'action' || namespace === 'state' ? [namespace, target, type].join('.') : namespace + '.' + type;\n\t        });\n\t    }\n\t}\n\t\n\tParseResult.prototype = {\n\t    namespace: '',\n\t    type: '',\n\t    targets: [],\n\t    paths: []\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** state-machine.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 7ccbc9b9ace992bae3de\n **/","import ValueMap from './utils/ValueMap';\nimport Transition from './Transition';\nimport { SystemEvent, TransitionEvent } from './Events';\nimport { isString, isFunction } from './utils/utils';\nimport { parse } from './utils/handlers'\n\nexport default function StateMachine (scope, config)\n{\n    // allow [scope, config] or [config] as parameters\n    if(arguments.length == 1)\n    {\n        [config, scope] = [scope, null];\n    }\n\n    // assignment\n    this.scope          = scope;\n    this.state          = '';\n    this.states         = [];\n    this.transitions    = new ValueMap();\n    this.actions        = new ValueMap();\n    this.handlers       = new ValueMap();\n\n    // initialize\n    if(config)\n    {\n        this.initialize(config);\n    }\n}\n\nStateMachine.parse = parse;\n\n/**\n * StateMachine prototype\n *\n * The property examples below illustrate a 4-state machine, with states:\n *\n * - intro > settings > summary > end\n *\n * And actions:\n *\n * - back | next | restart | finish\n */\nStateMachine.prototype =\n{\n    // ------------------------------------------------------------------------------------------------\n    // properties\n\n        /**\n         * Available state names\n         *\n         * - [\n         *     intro,\n         *     settings,\n         *     summary,\n         *     final\n         *   ]\n         *\n         * @var {string[]}\n         */\n        states      : null,\n\n        /**\n         * Available transitions for each action\n         *\n         * action.from => to\n         *\n         * - next: {\n         *     intro: settings,\n         *     settings: summary\n         *   },\n         * - back: {\n         *     settings: intro\n         *   },\n         * - restart: {\n         *     summary:intro\n         *   },\n         * - finish: {\n         *     summary:final\n         *   },\n         *\n         * Transitions can also be functions\n         *\n         * - next: {\n         *     intro: function() { return '<random state>' } // jump to a random state\n         *   }\n         *\n         * @var {ValueMap}\n         */\n        transitions : null,\n\n        /**\n         * Actions that are available to be called from each state\n         *\n         * state => [ action, action, ... ]\n         *\n         * - intro: [\n         *     'next'\n         *   ],\n         * - settings: [\n         *     'next',\n         *     'back'\n         *   ],\n         * - summary: [\n         *     'restart'\n         *     'finish',\n         *   ]\n         *\n         * Actions can also be expressed as wildcards\n         *\n         * - intro: [\n         *     '*' // any action is allowed from intro\n         *   ]\n         *\n         * @var {ValueMap}\n         */\n        actions     : null,\n\n        /**\n         * Handler functions that should be called on each action event / state change\n         *\n         * name.type => [ handler, handler, ... ]\n         *\n         * - next: {\n         *   - start: [\n         *       hideModal\n         *     ],\n         *   - end: [\n         *       showModal\n         *     ]\n         *   },\n         * - summary: {\n         *   - enter: [\n         *       resetForm\n         *     ],\n         *   - leave: [\n         *       validateForm,\n         *       postData,\n         *     ]\n         *   },\n         *   ...\n         *\n         * @var {ValueMap}\n         */\n        handlers    : null,\n\n        /**\n         * The current state\n         *\n         * @var {string}\n         */\n        state       : '',\n\n        /**\n         * Any active Transition object that is driving the state change\n         *\n         * @var {Transition}\n         */\n        transition  : null,\n\n        /**\n         * The scope in which to call all handlers\n         *\n         * @var {*}\n         */\n        scope       : null,\n\n        /**\n         * The original config object\n         *\n         * @var {Object}\n         */\n        config      : null,\n\n\n    // ------------------------------------------------------------------------------------------------\n    // private methods\n\n        /**\n         * Initialize the FSM with a config object\n         *\n         * @private\n         * @param config\n         */\n        initialize:function (config)\n        {\n            // assign config\n            this.config     = config;\n\n            // scope\n            if(config.scope)\n            {\n                this.scope = config.scope;\n            }\n\n            // pre-collate all states\n            addStates(this, 'from', config.transitions);\n            addStates(this, 'to', config.transitions);\n\n            // initial state\n            if( ! config.initial )\n            {\n                config.initial = this.states[0];\n            }\n\n            // add transitions\n            if(Array.isArray(config.transitions))\n            {\n                config.transitions.map( transition =>\n                {\n                    // shorthand\n                    if(isString(transition))\n                    {\n                        let matches = transition.match(/(\\w+)\\s*[|:=]\\s*(\\w+)\\s*([<>-])\\s*(\\w.*)/);\n                        let [,name, from, op, to] = matches;\n                        if(op === '-')\n                        {\n                            this.add(name, from, to);\n                            this.add(name, to, from);\n                            return;\n                        }\n                        if(op === '<')\n                        {\n                            [from, to] = [to, from];\n                        }\n                        this.add(name, from, to);\n                    }\n\n                    // keys\n                    else\n                    {\n                        this.add(transition.name, transition.from, transition.to);\n                    }\n                });\n            }\n\n            // add handlers\n            if(config.handlers)\n            {\n                for(let name in config.handlers)\n                {\n                    if(config.handlers.hasOwnProperty(name))\n                    {\n                        this.on(name, config.handlers[name]);\n                    }\n                }\n            }\n\n            // start automatically unless defer is set to true\n            if( ! config.defer )\n            {\n                this.state = config.initial;\n            }\n\n            /**\n             * Sets defaults for various declarations\n             *\n             * @type {Object}\n             */\n            config.defaults = Object.assign({\n\n                // initialize event\n                initialize  :'initialize',\n\n                // handler defaults\n                action      :'start',\n                state       :'enter'\n\n            }, config.defaults);\n\n            /**\n             * Sets the default order to run transition callbacks in\n             *\n             * @type {string[]} type.target\n             */\n            config.order = config.order ||\n            [\n                'action.*.start',\n                'action.{action}.start',\n                'state.{*}.{action}',\n                'state.{from}.{action}',\n                'state.{from}.leave',\n                'state.*.leave',\n                'state.*.enter',\n                'state.{to}.enter',\n                'action.{action}.end',\n                'action.*.end'\n            ];\n        },\n\n        /**\n         * Dispatch an event\n         *\n         * @param   {string}    namespace\n         * @param   {string}    type\n         * @param   {string}    key\n         * @param   {*}         value\n         * @returns {StateMachine}\n         */\n        update: function (namespace, type, key = '', value = null)\n        {\n            let signature = namespace + '.' + type;\n            let event = namespace === 'system'\n                ? new SystemEvent(type, key, value)\n                : new TransitionEvent(type);\n            this.dispatch(signature, event);\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // api\n\n        /**\n         * Attempt to run an action, resulting in a transition to a state\n         *\n         * @param   {string}    action\n         * @param   {*[]}       rest\n         * @returns {boolean}\n         */\n        do: function (action, ...rest)\n        {\n            if(this.can(action) && !this.isPaused())\n            {\n                this.transition = Transition.create(this, action, rest);\n                if(action === this.config.defaults.initialize)\n                {\n                    this.update('system', 'initialize');\n                }\n                this.update('system', 'update', 'transition', this.transition);\n                this.transition.exec();\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Attempt to go to a state\n         *\n         * Finds if an appropriate transition exists, then calls the related action if it does\n         *\n         * @param   {string}    state\n         * @param   {boolean}   [force]\n         * @returns {boolean}\n         */\n        go: function (state, force = false)\n        {\n            if(this.has(state))\n            {\n                if(force)\n                {\n                    this.transition = Transition.force(this, state);\n                    return this.end();\n                }\n                var action = this.getActionForState(state);\n                if(action)\n                {\n                    return this.do(action);\n                }\n                this.config.debug && console.info('No transition exists from \"%s\" to \"%s\"', this.state, state);\n            }\n            else\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n            }\n            return false;\n        },\n\n        /**\n         * Query a transition to see if a named action is available\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        can: function (action)\n        {\n            if( ! this.actions.has(action) )\n            {\n                this.config.debug && console.warn('No such action \"%s\"', action);\n            }\n            return !! this.transitions.has(this.state, action);\n        },\n\n        /**\n         * Query a transition to see if a named action is unavailable\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        cannot: function (action)\n        {\n            return ! this.can(action);\n        },\n\n        /**\n         * Test if the current state is the same as the supplied one\n         *\n         * @param   {string}    state       A state name to compare against the current state\n         * @returns {boolean}\n         */\n        is: function (state)\n        {\n            if(this.states.indexOf(state) === -1)\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n            }\n            return state === this.state;\n        },\n\n        /**\n         * Test if a state exists\n         *\n         * @param   {string}    state\n         * @return  {boolean}\n         */\n        has: function(state)\n        {\n            return this.states.indexOf(state) !== -1;\n        },\n\n        /**\n         * Get the available \"to\" states for the current or supplied state\n         *\n         * @param   {string}    [state]     Optional name of a state to get states for. Defaults to the current state\n         * @returns {string[]}              An array of string states\n         */\n        getStatesFor: function (state = null)\n        {\n            state       = state || this.state;\n            let actions = this.getActionsFor(state, true);\n            return Object.keys(actions).map( name => actions[name] );\n        },\n\n        /**\n         * Get the available actions (or actions and states) for the current or supplied state\n         *\n         * @param   {string}    [state]     Optional name of a state to get actions for. Defaults to the current state\n         * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n         * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n         */\n        getActionsFor: function (state = '', asMap = false)\n        {\n            state       = state || this.state;\n            let actions = this.transitions.get(state || this.state);\n            if(asMap)\n            {\n                let states  = {};\n                actions.map( action =>\n                {\n                    states[action] = this.actions.get(action + '.' + state);\n                });\n                return states;\n            }\n            else\n            {\n                return actions;\n            }\n        },\n\n        getActionForState: function (state)\n        {\n            if(this.has(state))\n            {\n                let actions = this.getActionsFor(state, true);\n                for(let action in actions)\n                {\n                    if(actions[action] === state)\n                    {\n                        return action;\n                    }\n                }\n            }\n            return null;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // flags\n\n        /**\n         * Test if the FSM has started\n         *\n         * @returns {boolean}\n         */\n        isStarted: function ()\n        {\n            return this.state !== '';\n        },\n\n        /**\n         * Test if the FSM is transitioning\n         *\n         * @returns {boolean}\n         */\n        isTransitioning: function ()\n        {\n            return !! this.transition;\n        },\n\n        /**\n         * Test if the FSM is paused (whilst transitioning)\n         *\n         * @returns {boolean}\n         */\n        isPaused: function ()\n        {\n            return this.transition\n                ? this.transition.paused\n                : false;\n        },\n\n        /**\n         * Test if the FSM is on the \"final\" state\n         *\n         * @returns {boolean}\n         */\n        isComplete: function ()\n        {\n            return this.state === this.config.final;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // transitions\n\n        /**\n         * Pause any current transition\n         *\n         * @returns {StateMachine}\n         */\n        pause: function ()\n        {\n            if(this.transition && !this.isPaused())\n            {\n                this.transition.pause();\n                this.update('transition', 'pause');\n                this.update('system', 'update', 'pause', true);\n            }\n            return this;\n        },\n\n        /**\n         * Resume any current transition\n         *\n         * @returns {StateMachine}\n         */\n        resume: function ()\n        {\n            if(this.transition && this.isPaused())\n            {\n                this.update('transition', 'resume');\n                this.update('system', 'update', 'pause', false);\n                this.transition.resume();\n            }\n            return this;\n        },\n\n        /**\n         * Cancel any current transition\n         *\n         * @returns {StateMachine}\n         */\n        cancel: function ()\n        {\n            if(this.transition)\n            {\n                if(this.isPaused())\n                {\n                    this.update('system', 'update', 'pause', false);\n                }\n                this.state = this.transition.from;\n                this.transition.clear();\n                delete this.transition;\n                this.update('transition', 'cancel');\n                this.update('system', 'update', 'transition', null);\n            }\n            return this;\n        },\n\n        /**\n         * End any current transition, skipping remaining handlers\n         *\n         * @returns {StateMachine}\n         */\n        end: function ()\n        {\n            if(this.transition)\n            {\n                if(this.isPaused())\n                {\n                    this.update('system', 'update', 'pause', false);\n                }\n                this.state = this.transition.to;\n                this.transition.clear();\n                delete this.transition;\n                this.update('system', 'change', 'state', this.state);\n                this.update('system', 'update', 'state', this.state);\n                if(this.isComplete())\n                {\n                    this.update('system', 'complete');\n                }\n                this.update('system', 'update', 'transition', null);\n            }\n            return this;\n        },\n\n        /**\n         * Reset the FSM to the initial, or supplied, state\n         *\n         * @returns {StateMachine}\n         */\n        reset:function(initial = '')\n        {\n            let state = initial || this.config.initial;\n            this.update('system', 'reset');\n            if(this.transition)\n            {\n                if(this.isPaused())\n                {\n                    this.update('system', 'update', 'pause', false);\n                }\n                this.transition.clear();\n                delete this.transition;\n                this.update('transition', 'cancel');\n                this.update('system', 'update', 'transition', null);\n            }\n            if(this.state !== state)\n            {\n                this.state = state;\n                this.update('system', 'change', 'state', this.state);\n                this.update('system', 'update', 'state', this.state);\n            }\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // actions\n\n        /**\n         * Add a transition\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        add: function (action, from, to)\n        {\n            this.actions.set(action + '.' + from, to);\n            this.transitions.add(from, action);\n            return this;\n        },\n\n        /**\n         * Remove a transition\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        remove: function (action, from, to)\n        {\n            this.states.remove(action, from);\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // handlers\n\n        /**\n         * Add an event handler\n         *\n         * Event handler signatures are build from the following grammar:\n         *\n         * - token      foo\n         * - property   .foo\n         * - event      :foo\n         * - action     @foo\n         * - targets    (foo|bar|baz)\n         *\n         * For example:\n         *\n         * - change\n         * - transition.pause\n         * - next:end\n         * - (a|b)@next\n         * - a@next\n         *\n         * The main event types are unique, so can be used without the namespace:\n         *\n         * - change\n         * - pause\n         * - complete\n         * - ...\n         *\n         * If your states and events are unique, they can also be used without qualification.\n         *\n         * See docs and demo for more information\n         *\n         * @param   {string}        id\n         * @param   {Function}      fn\n         * @return  {StateMachine}\n         */\n        on: function (id, fn)\n        {\n            /** @type {ParseResult} */\n            let result = parse(this, id);\n\n            if(this.config.debug)\n            {\n                console.log('StateMachine on: ' + id, [result.namespace, result.type], result.paths)\n            }\n\n            result.paths.map( (path, index) =>\n            {\n                let target = result.targets[index];\n\n                // warn for invalid actions / states\n                if(target !== '*')\n                {\n                    if(result.namespace === 'state')\n                    {\n                        if(this.states.indexOf(target) === -1)\n                        {\n                            this.config.debug && console.warn('StateMachine: Warning assigning state.%s handler; no such state \"%s\"', result.type, target);\n                        }\n                    }\n                    else if(result.namespace === 'action')\n                    {\n                        if(!this.actions.has(target))\n                        {\n                            this.config.debug && console.warn('StateMachine: Warning assigning action.%s handler; no such action \"%s\"', result.type, target);\n                        }\n                    }\n                }\n\n                // check handler is a function\n                if(!isFunction(fn))\n                {\n                    throw new Error('Error assigning ' +result.namespace+ '.' +result.type+ ' handler; callback is not a Function', fn);\n                }\n\n                // assign\n                this.handlers.insert(path, fn);\n            });\n\n            return this;\n        },\n\n        off: function (id, fn)\n        {\n            let result = parse(this, id);\n            result.paths.map( path =>\n            {\n                this.handlers.remove(path, fn)\n            });\n        },\n\n        dispatch: function(path, event)\n        {\n            this.config.debug && console.info('StateMachine: dispatch \"%s\"', path);\n            let handlers = this.handlers.get(path);\n            if(handlers)\n            {\n                handlers.map(fn => fn(event, this) );\n            }\n        }\n\n};\n\n/**\n * Parses config and adds unique state names to states array\n *\n * @param {StateMachine}    fsm\n * @param {string}          key\n * @param {Object[]}        transitions\n */\nfunction addStates(fsm, key, transitions)\n{\n    if(transitions)\n    {\n        transitions.map( event => addState(fsm, event[key]) );\n    }\n}\n\nfunction addState (fsm, state)\n{\n    if (isString(state) && fsm.states.indexOf(state) === -1)\n    {\n        fsm.states.push(state);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/StateMachine.js\n **/","import {isObject, isArray, isDefined, isUndefined} from './utils';\n\n/**\n * Utility class to create, modify and delete nested hashes and values\n *\n * @constructor\n */\nexport default function ValueMap (data)\n{\n    this.data = data || {};\n}\n\nValueMap.prototype =\n{\n    data: null,\n\n    set: function (path, value)\n    {\n        set(this.data, path, value);\n        return this;\n    },\n\n    add:function(path, value)\n    {\n        add(this.data, path, value);\n        return this;\n    },\n\n    insert:function(path, value)\n    {\n        insert(this.data, path, value);\n        return this;\n    },\n\n    get:function(path)\n    {\n        return get(this.data, path);\n    },\n\n    has: function (path, value = undefined)\n    {\n        return has(this.data, path, value)\n    },\n\n    indexOf: function (path, value)\n    {\n        return indexOf(this.data, path, value)\n    },\n\n    remove: function (path, value = undefined)\n    {\n        remove(this.data, path, value);\n        return this;\n    },\n\n    keys:function(path)\n    {\n        return Object.keys(get(this.data, path));\n    },\n\n    values:function(path)\n    {\n        return values(this.data, path);\n    }\n\n};\n\nfunction create(obj, keys)\n{\n    let key;\n    while(keys.length)\n    {\n        key = keys.shift();\n        if( ! isObject(obj[key]) )\n        {\n            obj[key] = {};\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n\nexport function set(obj, path, value, index = -1)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    obj[key] = value;\n}\n\nfunction add(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    obj[key].push(value);\n}\n\nfunction insert(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    let parent = obj[key],\n        index = parent.indexOf(value);\n    if(index === -1)\n    {\n        parent.push(value);\n    }\n    else\n    {\n        parent[index] = value;\n    }\n}\n\nexport function get(obj, path)\n{\n    if(isUndefined(path) || path == '')\n    {\n        return obj;\n    }\n\n    let key,\n        keys = String(path).split('.');\n    while(keys.length > 1)\n    {\n        key = keys.shift();\n        if( ! obj.hasOwnProperty(key) )\n        {\n            return;\n        }\n        obj = obj[key];\n    }\n    key = keys.shift();\n    return obj[key];\n}\n\nexport function has(obj, path, value)\n{\n    let parent = get(obj, path);\n    return !! (isArray(parent) && isDefined(value)\n        ? parent.indexOf(value) !== -1\n        : isUndefined(value)\n            ? isDefined(parent)\n            : parent === value);\n}\n\nexport function indexOf (obj, path, value)\n{\n    let arr = get(obj, path);\n    if(isArray(arr))\n    {\n        return arr.indexOf(value);\n    }\n    return -1;\n}\n\nexport function remove(obj, path, value)\n{\n    let parent = obj,\n        keys = String(path || '').split('.'),\n        key = keys.pop();\n\n    if(keys.length)\n    {\n        parent = get(obj, keys.join('.'))\n    }\n    if(isDefined(value) && isArray(parent[key]))\n    {\n        let target = parent[key];\n        var index = target.indexOf(value);\n        if(index > -1)\n        {\n            target.splice(index, 1);\n            if(target.length === 0)\n            {\n                delete parent[key];\n            }\n            return true;\n        }\n        return false;\n    }\n    else\n    {\n        if(isObject(parent) && obj.hasOwnProperty(key))\n        {\n            delete parent[key];\n            return true;\n        }\n    }\n    return false\n}\n\nexport function values(obj, path)\n{\n    var values = [];\n    var target = get(obj, path);\n    if(isObject(target))\n    {\n        for(var name in target)\n        {\n            if(target.hasOwnProperty(name))\n            {\n                values.push(target[name]);\n            }\n        }\n    }\n    return values;\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/ValueMap.js\n **/","export function isObject (value)\n{\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport function isArray (value)\n{\n    return value instanceof Array;\n}\n\nexport function isString (value)\n{\n    return typeof value === 'string';\n}\n\nexport function isFunction(value)\n{\n    return value instanceof Function;\n}\n\nexport function isDefined (value)\n{\n    return typeof value !== 'undefined';\n}\n\nexport function isUndefined (value)\n{\n    return typeof value === 'undefined';\n}\n\nexport function trim (value)\n{\n    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/utils.js\n **/","import { StateEvent, ActionEvent } from './Events';\nimport { isFunction } from './utils/utils';\n\n/**\n * Transition class\n *\n * Responsible for managing events in the flow from state to state.\n *\n * This adds all handlers for the current action start/end and state from/to to an array:\n *\n * - <namespace>.<target>.<type>[]\n *\n * So going from state \"a\" to state \"b\" with action \"next\" should build:\n *\n * - action.*.start[]\n * - action.next.start[]\n * - state.a.leave[]\n * - state.*.leave[]\n * - state.*.enter[]\n * - state.b.enter[]\n * - action.next.end[]\n * - action.*.end[]\n *\n * This can be changed by passing in an order array in fsm.config\n *\n * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n *\n * From a callback, you can:\n *\n * - return false to cancel the transition\n * - return true to pause the transition\n * - not return a value (the transition continues)\n *\n * Transitions can also be paused, resumed, or cancelled by calling\n * the appropriate method on, or from:\n *\n * - the event\n * - the transition\n * - the state machine\n *\n * Cancelled transitions will reset the FSM to the previous \"from\" state\n *\n * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n *\n * @param {StateMachine}    fsm\n * @param {string}          action\n * @param {string}          from\n * @param {string}          to\n */\nfunction Transition (fsm, action, from, to)\n{\n    this.fsm        = fsm;\n    this.action     = action;\n    this.from       = from;\n    this.to         = to;\n    this.clear();\n}\n\n/**\n * @prop {StateMachine}    fsm\n * @prop {string}          action\n * @prop {string}          from\n * @prop {string}          to\n * @prop {Function[]}      handlers\n */\nTransition.prototype =\n{\n    fsm         : null,\n    action      : '',\n    from        : '',\n    to          : '',\n    paused      : false,\n    handlers    : null,\n\n    clear: function ()\n    {\n        this.paused = false;\n        this.handlers = [];\n    },\n\n    /**\n     * Execute the next event's callbacks\n     * @returns {*}\n     */\n\texec: function ()\n\t{\n\t    if( ! this.paused )\n        {\n            if(this.handlers.length)\n            {\n                var handler = this.handlers.shift();\n                var state = handler();\n                if(state === false)\n                {\n                    return this.fsm.cancel();\n                }\n                if(state === true)\n                {\n                    return this.fsm.pause();\n                }\n                this.exec();\n            }\n            else\n            {\n                this.fsm.end();\n            }\n        }\n        return this;\n\t},\n\n    pause: function ()\n    {\n        this.paused = true;\n        return this;\n    },\n\n    resume: function ()\n    {\n        this.paused = false;\n        return this.exec();\n    }\n};\n\nexport default\n{\n    /**\n     * Create the Transition object\n     *\n     * - Set up variables, and queue\n     * - Determine paths to relevant handlers\n     * - Build State and Action Event objects\n     * - Pre-bind all handlers\n     * - Append to queue\n     *\n     * @param {StateMachine}    fsm\n     * @param {string}          action\n     * @param {Array}           params\n     * @returns {Transition}\n     */\n    create:function (fsm, action, params)\n    {\n        // transition properties\n        let scope   = fsm.scope;\n        let from    = fsm.state;\n        let to      = fsm.actions.get(action)[from];\n        let vars    = {action, to, from};\n\n        // handle \"to\" being a function\n        if(isFunction(to))\n        {\n            to = to.apply(scope, params);\n            if(fsm.states.indexOf(to) === -1)\n            {\n                throw new Error('Invalid \"to\" state \"' +to+ '\"');\n            }\n        }\n\n        // transition\n        let queue       = [];\n        let transition  = new Transition(fsm, action, from, to);\n\n        // build handlers array\n        fsm.config.order.map( path =>\n        {\n            // replace path tokens\n            path = path.replace(/{(\\w+)}/g, (all, token) => vars[token]);\n            let handlers = fsm.handlers.get(path);\n\n            // do it!\n            if(handlers)\n            {\n                let [namespace, target, type] = path.split('.');\n                handlers = handlers.map( handler =>\n                {\n                    // build event object\n                    let Event = namespace === 'state' ? StateEvent : ActionEvent;\n                    let event = new Event(type, target, transition);\n\n                    // pre-bind handlers, scopes and params\n                    // this way scope and params don't need to be passed around\n                    // and the call from Transition is always just `value = handler()`\n                    return function()\n                    {\n                        return handler.apply(scope, [event, fsm].concat(params));\n                    }\n                });\n\n                // add to queue\n                queue = queue.concat(handlers);\n            }\n        });\n\n        // return\n        transition.handlers = queue;\n        return transition;\n    },\n\n    force: function(fsm, state)\n    {\n        let transition = new Transition(fsm, '', fsm.state, state);\n        transition.paused = fsm.transition ? fsm.transition.paused : false;\n        return transition;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/Transition.js\n **/","// ------------------------------------------------------------------------------------------------\n// setup\n\n    /**\n     * @prop {string}       namespace   The Event namespace; i.e. state or action\n     * @prop {string}       type        The Event type;      i.e. leave/enter (state) or start/end (action)\n     * @prop {string}       target      The Event target;    i.e. intro (state), next (action), or * (all states or types)\n     * @prop {Transition}   transition  The transition which generated the event\n     */\n    let event =\n    {\n        // properties\n        namespace   : null,\n        type        : null,\n        target      : null,\n        transition          : null\n    };\n\n    function initialize (event, namespace, type, target, transition)\n    {\n        event.namespace     = namespace;\n        event.type          = type;\n        event.target        = target;\n        event.transition    = transition;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// ActionEvent\n\n    export function ActionEvent (type, target, transition)\n    {\n        initialize(this, 'action' ,type, target, transition);\n    }\n    ActionEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// StateEvent\n\n    export function StateEvent (type, target, transition)\n    {\n        initialize(this, 'state' ,type, target, transition);\n    }\n    StateEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// SystemEvent\n\n    export function SystemEvent (type, key, value)\n    {\n        this.type   = type;\n        this.key    = key;\n        this.value  = value;\n    }\n\n    SystemEvent.prototype =\n    {\n        namespace   : 'system',\n        type        : '',\n        key         : '',\n        value       : null\n    };\n\n\n// ------------------------------------------------------------------------------------------------\n// TransitionEvent\n\n    export function TransitionEvent (type)\n    {\n        this.type = type;\n    }\n\n    TransitionEvent.prototype =\n    {\n        namespace   : 'transition',\n        type        : ''\n    };\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/Events.js\n **/","let lookup =\n{\n    namespaces:\n    {\n        start   :'system',\n        change  :'system',\n        update  :'system',\n        complete:'system',\n        reset   :'system',\n        add     :'system',\n        remove  :'system',\n\n        pause   :'transition',\n        resume  :'transition',\n        cancel  :'transition'\n    },\n\n    events:\n    {\n        start   :'action',\n        end     :'action',\n        enter   :'state',\n        leave   :'state'\n    }\n};\n\n/**\n * Parses an event handler id into namespace, type, and target variables\n *\n * @param {StateMachine}    fsm\n * @param {string}          id\n * @return {ParseResult}\n */\nexport function parse(fsm, id)\n{\n    // variables\n    let defaults = fsm.config.defaults,\n        segments,\n        namespace,\n        type,\n        targets;\n\n    // utility functions\n    function isState(value) {\n        return fsm.states.indexOf(value) !== -1;\n    }\n\n    function isAction(value) {\n        return fsm.actions.has(value);\n    }\n\n    function getTargets(value) {\n        return value ? value.match(/\\w[-\\w]*/g) : ['*'];\n    }\n\n    function determineValue(value) {\n\n        // is namespace, i.e. system, transition, state, action\n        if(/^(system|transition|state|action)$/.test(value))\n        {\n            namespace = value;\n        }\n\n        // is shortcut, i.e. update, change, pause, cancel\n        else if(value in lookup.namespaces)\n        {\n            namespace = lookup.namespaces[value];\n            type = value;\n        }\n\n        // is state or action, i.e. a, next\n        else if (isState(value) || isAction(value))\n        {\n            if(!namespace)\n            {\n                namespace = isState(value)\n                    ? 'state'\n                    : 'action';\n            }\n\n            // special case for state with action\n            if(namespace === 'state' && isAction(value))\n            {\n                type = value;\n            }\n\n            if(!targets)\n            {\n                targets = getTargets(value);\n            }\n        }\n\n        // action event, i.e. :event\n        else if(/^(enter|leave)$/.test(value))\n        {\n            type = value;\n        }\n    }\n\n    // process\n    segments    = id.match(/:\\w+|@\\w+|\\(.+?\\)|\\.\\w+|\\w+/g);\n\n    // return an empty result if no matches\n    if(!segments)\n    {\n        return new ParseResult();\n    }\n\n    /**\n     * This is the engine of the parse process\n     *\n     * The regex above matches the grammar of the expression into an array:\n     *\n     * - transition.pause   => [\"transition\", \".pause\"]\n     * - (a|b)@next         => [\"(a|b)\", \"@next\"]\n     * - a@next             => [\"a\", \"@next\"]\n     *\n     * Each segment is then analysed for its type and content, either directly\n     * or via the utility functions above which update the local variables.\n     */\n    segments.forEach(function (segment, i, segments)\n    {\n        // variables\n        let char    = segment[0];\n        let values  = segment.match(/\\w+/g);\n        let value   = values[0];\n        switch(char)\n        {\n            // event\n            case ':':\n                namespace   = lookup.events[value];\n                type        = value;\n                break;\n\n            // action\n            case '@':\n                namespace   = 'state';\n                type        = value;\n                break;\n\n            // targets\n            case '(':\n                targets = values;\n                namespace = isState(values[0]) ? 'state' : 'action';\n                break;\n\n            // property\n            case '.':\n                determineValue(value);\n                break;\n\n            // single word\n            default:\n                determineValue(segment);\n        }\n    });\n\n    // final determination\n    if(!targets)\n    {\n        targets = getTargets();\n    }\n\n    if(!namespace)\n    {\n        namespace = isState(targets[0]) ? 'state' : 'action';\n    }\n\n    if(!type)\n    {\n        type = defaults[namespace];\n    }\n\n    // return result\n    return new ParseResult(namespace, type, targets);\n}\n\nfunction ParseResult (namespace, type, targets)\n{\n    if(namespace)\n    {\n        this.namespace  = namespace;\n        this.type       = type;\n        this.targets    = targets;\n        this.paths      = targets.map( target => {\n            return namespace === 'action' || namespace === 'state'\n                ? [namespace, target, type].join('.')\n                : namespace + '.' + type;\n        });\n    }\n}\n\nParseResult.prototype =\n{\n    namespace   :'',\n    type        :'',\n    targets     :[],\n    paths       :[]\n};\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/handlers.js\n **/"],"sourceRoot":""}