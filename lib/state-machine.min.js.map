{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///state-machine.min.js","webpack:///webpack/bootstrap 1c27578faa328d1d41b0","webpack:///./src/StateMachine.js","webpack:///./src/utils/ValueMap.js","webpack:///./src/utils/utils.js","webpack:///./src/Transition.js","webpack:///./src/Events.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","StateMachine","target","config","state","states","transitions","_ValueMap2","actions","handlers","initialize","update","console","log","addStates","fsm","key","map","event","addState","_utils","isString","indexOf","push","addHandler","type","verb","_len2","arguments","length","rest","Array","_key2","_rest","_rest2","_slicedToArray","param","fn","isArray","match","subject","debug","warn","has","isFunction","Error","insert","join","Object","defineProperty","value","_typeof","Symbol","iterator","constructor","prototype","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","next","done","err","TypeError","_ValueMap","_Transition","_Transition2","_Events","transition","_this","events","initial","matches","_matches2","name","from","op","to","add","_ref","hasOwnProperty","handler","_matches3","onStart","onEnd","onLeave","onEnter","defer","info","data","change","ChangeEvent","do","action","can","_len","_key","create","exec","go","getActionForState","cannot","is","getStatesFor","getActionsFor","keys","_this2","asMap","get","_ret2","v","isStarted","isFinished","isTransitioning","isPaused","paused","pause","resume","cancel","clear","complete","reset","set","remove","onChange","off","ValueMap","shift","isObject","path","String","split","pop","parent","index","isUndefined","isDefined","splice","values","_set","_get","_has","_indexOf","_remove","_values","toString","Function","trim","replace","Transition","callbacks","_Events2","defaultOrder","order","params","apply","concat","bind","queue","token","_token$split","_token$split2","test","setOrder","getOrder","noop","ActionEvent","StateEvent"],"mappings":"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","file":"state-machine.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StateMachine\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StateMachine\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.default = StateMachine;\n\t\n\tvar _ValueMap = __webpack_require__(1);\n\t\n\tvar _ValueMap2 = _interopRequireDefault(_ValueMap);\n\t\n\tvar _Transition = __webpack_require__(3);\n\t\n\tvar _Transition2 = _interopRequireDefault(_Transition);\n\t\n\tvar _Events = __webpack_require__(4);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction StateMachine(target, config) {\n\t    this.target = target;\n\t    this.state = '';\n\t    this.states = [];\n\t    this.transitions = new _ValueMap2.default();\n\t    this.actions = new _ValueMap2.default();\n\t    this.handlers = new _ValueMap2.default();\n\t    if (config) {\n\t        this.initialize(config);\n\t        this.update('started');\n\t    }\n\t    console.log('hello there');\n\t}\n\t\n\t/**\n\t * StateMachine prototype\n\t *\n\t * The property examples below illustrate a 4-state machine, with states:\n\t *\n\t * - intro > settings > summary > end\n\t *\n\t * And actions:\n\t *\n\t * - back | next | restart | finish\n\t */\n\tStateMachine.prototype = {\n\t    // ------------------------------------------------------------------------------------------------\n\t    // properties\n\t\n\t    /**\n\t     * Available state names\n\t     *\n\t     * - [\n\t     *     intro,\n\t     *     settings,\n\t     *     summary,\n\t     *     final\n\t     *   ]\n\t     *\n\t     * @var {string[]}\n\t     */\n\t    states: null,\n\t\n\t    /**\n\t     * Available transitions for each action\n\t     *\n\t     * action.from => to\n\t     *\n\t     * - next: {\n\t     *     intro: settings,\n\t     *     settings: summary\n\t     *   },\n\t     * - back: {\n\t     *     settings: intro\n\t     *   },\n\t     * - restart: {\n\t     *     summary:intro\n\t     *   },\n\t     * - finish: {\n\t     *     summary:final\n\t     *   },\n\t     *\n\t     * Transitions can also be functions\n\t     *\n\t     * - next: {\n\t     *     intro: function() { return '<random state>' } // jump to a random state\n\t     *   }\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    transitions: null,\n\t\n\t    /**\n\t     * Actions that are available to be called from each state\n\t     *\n\t     * state => [ action, action, ... ]\n\t     *\n\t     * - intro: [\n\t     *     'next'\n\t     *   ],\n\t     * - settings: [\n\t     *     'next',\n\t     *     'back'\n\t     *   ],\n\t     * - summary: [\n\t     *     'restart'\n\t     *     'finish',\n\t     *   ]\n\t     *\n\t     * Actions can also be expressed as wildcards\n\t     *\n\t     * - intro: [\n\t     *     '*' // any action is allowed from intro\n\t     *   ]\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    actions: null,\n\t\n\t    /**\n\t     * Handler functions that should be called on each action event / state change\n\t     *\n\t     * name.type => [ handler, handler, ... ]\n\t     *\n\t     * - next: {\n\t     *   - start: [\n\t     *       hideModal\n\t     *     ],\n\t     *   - end: [\n\t     *       showModal\n\t     *     ]\n\t     *   },\n\t     * - summary: {\n\t     *   - enter: [\n\t     *       resetForm\n\t     *     ],\n\t     *   - leave: [\n\t     *       validateForm,\n\t     *       postData,\n\t     *     ]\n\t     *   },\n\t     *   ...\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    handlers: null,\n\t\n\t    /**\n\t     * The current state\n\t     *\n\t     * @var {string}\n\t     */\n\t    state: '',\n\t\n\t    /**\n\t     * Any active Transition object that is driving the state change\n\t     *\n\t     * @var {Transition}\n\t     */\n\t    transition: null,\n\t\n\t    /**\n\t     * The target context in which to call all handlers\n\t     *\n\t     * @var {*}\n\t     */\n\t    target: null,\n\t\n\t    /**\n\t     * The original config object\n\t     *\n\t     * @var {Object}\n\t     */\n\t    config: null,\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // private methods\n\t\n\t    /**\n\t     * Initialize the FSM with a config object\n\t     *\n\t     * @private\n\t     * @param config\n\t     */\n\t    initialize: function initialize(config) {\n\t        var _this = this;\n\t\n\t        // assign config\n\t        this.config = config;\n\t\n\t        // parse all states\n\t        addStates(this, 'from', config.events);\n\t        addStates(this, 'to', config.events);\n\t\n\t        // initial state\n\t        if (!config.initial) {\n\t            config.initial = this.states[0];\n\t        }\n\t\n\t        // add transitions\n\t        config.events.map(function (event) {\n\t            // shorthand\n\t            if ((0, _utils.isString)(event)) {\n\t                var _matches = event.match(/(\\w+)\\s*[\\|:=]\\s*(\\w+)\\s*([<>-])\\s*(\\w.*)/);\n\t\n\t                var _matches2 = _slicedToArray(_matches, 5);\n\t\n\t                var name = _matches2[1];\n\t                var from = _matches2[2];\n\t                var op = _matches2[3];\n\t                var to = _matches2[4];\n\t\n\t                if (op === '-') {\n\t                    _this.add(name, from, to);\n\t                    _this.add(name, to, from);\n\t                    return;\n\t                }\n\t                if (op === '<') {\n\t                    var _ref = [to, from];\n\t                    from = _ref[0];\n\t                    to = _ref[1];\n\t                }\n\t                _this.add(name, from, to);\n\t            }\n\t\n\t            // keys\n\t            else {\n\t                    _this.add(event.name, event.from, event.to);\n\t                }\n\t        });\n\t\n\t        // add handlers\n\t        for (var name in config.handlers) {\n\t            if (config.handlers.hasOwnProperty(name)) {\n\t                var handler = config.handlers[name];\n\t                var matches = name.match(/(\\w+)\\s*(.*)/);\n\t                if (matches) {\n\t                    var _matches3 = _slicedToArray(matches, 3);\n\t\n\t                    var type = _matches3[1];\n\t                    var param = _matches3[2];\n\t\n\t                    switch (type) {\n\t                        case 'start':\n\t                            this.onStart(param, handler);break;\n\t                        case 'end':\n\t                            this.onEnd(param, handler);break;\n\t                        case 'leave':\n\t                            this.onLeave(param, handler);break;\n\t                        case 'enter':\n\t                            this.onEnter(param, handler);break;\n\t                        default:\n\t                            this.config.debug && console.warn('Warning processing handlers config: unknown action type \"' + type + '\"');\n\t                    }\n\t                } else {\n\t                    this.config.debug && console.warn('Warning processing handlers config: unable to parse action key \"' + name + '\"');\n\t                }\n\t            }\n\t        }\n\t\n\t        // state\n\t        if (!config.defer) {\n\t            this.state = config.initial;\n\t        }\n\t    },\n\t\n\t    /**\n\t     * Dispatch an update event\n\t     *\n\t     * @param type\n\t     */\n\t    update: function update(type) {\n\t        this.config.debug && console.info('StateMachine update \"%s\"', type);\n\t        var handlers = this.handlers.data.change;\n\t        if (handlers) {\n\t            (function () {\n\t                var event = new _Events.ChangeEvent(type);\n\t                handlers.map(function (fn) {\n\t                    return fn(event);\n\t                });\n\t            })();\n\t        }\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // api\n\t\n\t    /**\n\t     * Attempt to run an action, resulting in a transition to a state\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {*[]}       rest\n\t     * @returns {boolean}\n\t     */\n\t    do: function _do(action) {\n\t        if (this.can(action)) {\n\t            this.config.debug && console.info('Doing action \"%s\"', action);\n\t\n\t            for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                rest[_key - 1] = arguments[_key];\n\t            }\n\t\n\t            this.transition = _Transition2.default.create(this, action, rest);\n\t            this.update('transitioning');\n\t            this.transition.exec();\n\t            return true;\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Attempt to go to a state\n\t     *\n\t     * Finds if an appropriate transition exists, then calls the related action if it does\n\t     *\n\t     * @param   {string}    state\n\t     * @returns {boolean}\n\t     */\n\t    go: function go(state) {\n\t        if (this.has(state)) {\n\t            var action = this.getActionForState(state);\n\t            if (action) {\n\t                return this.do(action);\n\t            }\n\t            this.config.debug && console.info('No transition exists from \"%s\" to \"%s\"', this.state, state);\n\t        } else {\n\t            this.config.debug && console.warn('No such state \"%s\"', state);\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Query a transition to see if a named action is available\n\t     *\n\t     * @param   {string}    action\n\t     * @returns {boolean}\n\t     */\n\t    can: function can(action) {\n\t        if (!this.actions.has(action)) {\n\t            this.config.debug && console.warn('No such action \"%s\"', action);\n\t        }\n\t        return !!this.transitions.has(this.state, action);\n\t    },\n\t\n\t    /**\n\t     * Query a transition to see if a named action is unavailable\n\t     *\n\t     * @param   {string}    action\n\t     * @returns {boolean}\n\t     */\n\t    cannot: function cannot(action) {\n\t        return !this.can(action);\n\t    },\n\t\n\t    /**\n\t     * Test if the current state is the same as the supplied one\n\t     *\n\t     * @param   {string}    state       A state name to compare against the current state\n\t     * @returns {boolean}\n\t     */\n\t    is: function is(state) {\n\t        if (this.states.indexOf(state) === -1) {\n\t            this.config.debug && console.warn('No such state \"%s\"', state);\n\t        }\n\t        return state === this.state;\n\t    },\n\t\n\t    /**\n\t     * Test if a state exists\n\t     *\n\t     * @param   {string}    state\n\t     * @return  {boolean}\n\t     */\n\t    has: function has(state) {\n\t        return this.states.indexOf(state) !== -1;\n\t    },\n\t\n\t    /**\n\t     * Get the available \"to\" states for the current or supplied state\n\t     *\n\t     * @param   {string}    [state]     Optional name of a state to get states for. Defaults to the current state\n\t     * @returns {string[]}              An array of string states\n\t     */\n\t    getStatesFor: function getStatesFor() {\n\t        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\n\t        state = state || this.state;\n\t        var actions = this.getActionsFor(state, true);\n\t        return Object.keys(actions).map(function (name) {\n\t            return actions[name];\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Get the available actions (or actions and states) for the current or supplied state\n\t     *\n\t     * @param   {string}    [state]     Optional name of a state to get actions for. Defaults to the current state\n\t     * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n\t     * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n\t     */\n\t    getActionsFor: function getActionsFor() {\n\t        var _this2 = this;\n\t\n\t        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t        var asMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        state = state || this.state;\n\t        var actions = this.transitions.get(state || this.state);\n\t        if (asMap) {\n\t            var _ret2 = function () {\n\t                var states = {};\n\t                actions.map(function (action) {\n\t                    states[action] = _this2.actions.get(action + '.' + state);\n\t                });\n\t                return {\n\t                    v: states\n\t                };\n\t            }();\n\t\n\t            if ((typeof _ret2 === 'undefined' ? 'undefined' : _typeof(_ret2)) === \"object\") return _ret2.v;\n\t        } else {\n\t            return actions;\n\t        }\n\t    },\n\t\n\t    getActionForState: function getActionForState(state) {\n\t        if (this.has(state)) {\n\t            var actions = this.getActionsFor(null, true);\n\t            for (var action in actions) {\n\t                if (actions[action] === state) {\n\t                    return action;\n\t                }\n\t            }\n\t        }\n\t        return null;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // flags\n\t\n\t    /**\n\t     * Test if the FSM has started\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isStarted: function isStarted() {\n\t        return this.state !== '';\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is on the \"final\" state\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isFinished: function isFinished() {\n\t        return this.state === this.config.final;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is transitioning\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isTransitioning: function isTransitioning() {\n\t        return !!this.transition;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is paused (whilst transitioning)\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isPaused: function isPaused() {\n\t        return this.transition ? this.transition.paused : false;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // transitions\n\t\n\t    /**\n\t     * Pause any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    pause: function pause() {\n\t        if (this.transition) {\n\t            this.transition.pause();\n\t            this.update('paused');\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Resume any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    resume: function resume() {\n\t        if (this.transition) {\n\t            this.update('resumed');\n\t            this.transition.resume();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Cancel any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    cancel: function cancel() {\n\t        if (this.transition) {\n\t            this.state = this.transition.from;\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('cancelled');\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Complete any current transition, skipping remaining handlers\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    complete: function complete() {\n\t        if (this.transition) {\n\t            this.state = this.transition.to;\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('transitioned');\n\t            if (this.isFinished()) {\n\t                this.update('finished');\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Reset the FSM to the initial, or supplied, state\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    reset: function reset(initial) {\n\t        this.state = initial || this.config.initial;\n\t        if (this.transition) {\n\t            this.transition.clear();\n\t            delete this.transition;\n\t        }\n\t        this.update('reset');\n\t        return this;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // actions\n\t\n\t    /**\n\t     * Add a transition event\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @return  {StateMachine}\n\t     */\n\t    add: function add(action, from, to) {\n\t        this.actions.set(action + '.' + from, to);\n\t        this.transitions.add(from, action);\n\t        return this;\n\t    },\n\t\n\t    remove: function remove(action, from, to) {\n\t        this.states.remove(action, from);\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // handlers\n\t\n\t    onChange: function onChange(fn) {\n\t        this.handlers.add('change', fn);\n\t        return this;\n\t    },\n\t\n\t    onStart: function onStart(action, fn) {\n\t        addHandler(this, 'action', 'start', action, fn);\n\t        return this;\n\t    },\n\t\n\t    onEnd: function onEnd(action, fn) {\n\t        addHandler(this, 'action', 'end', action, fn);\n\t        return this;\n\t    },\n\t\n\t    onEnter: function onEnter(state, fn) {\n\t        addHandler(this, 'state', 'enter', state, fn);\n\t        return this;\n\t    },\n\t\n\t    onLeave: function onLeave(state, fn) {\n\t        addHandler(this, 'state', 'leave', state, fn);\n\t        return this;\n\t    },\n\t\n\t    off: function off(type, target, fn) {\n\t        return this;\n\t    }\n\t\n\t};\n\t\n\t/**\n\t * Parses config and adds unique state names to states array\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          key\n\t * @param {Object[]}        transitions\n\t */\n\tfunction addStates(fsm, key, transitions) {\n\t    transitions.map(function (event) {\n\t        return addState(fsm, event[key]);\n\t    });\n\t}\n\t\n\tfunction addState(fsm, state) {\n\t    if ((0, _utils.isString)(state) && fsm.states.indexOf(state) === -1) {\n\t        fsm.states.push(state);\n\t    }\n\t}\n\t\n\t/**\n\t * Generic function to parse action and add callback\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          type\n\t * @param {string}          verb\n\t * @param {string|Function} rest\n\t */\n\tfunction addHandler(fsm, type, verb) {\n\t    for (var _len2 = arguments.length, rest = Array(_len2 > 3 ? _len2 - 3 : 0), _key2 = 3; _key2 < _len2; _key2++) {\n\t        rest[_key2 - 3] = arguments[_key2];\n\t    }\n\t\n\t    // params\n\t    if (rest.length === 1) {\n\t        rest = ['*', rest[0]];\n\t    }\n\t    var _rest = rest;\n\t\n\t    var _rest2 = _slicedToArray(_rest, 2);\n\t\n\t    var param = _rest2[0];\n\t    var fn = _rest2[1];\n\t\n\t    // parse states\n\t\n\t    var states = (0, _utils.isArray)(param) ? param : param == '' ? ['*'] : param.match(/\\*|\\w+[-\\w]+/g);\n\t\n\t    // assign handlers\n\t    states.map(function (subject) {\n\t        // warn for invalid actions / states\n\t        if (subject !== '*') {\n\t            if (type === 'state' && fsm.states.indexOf(subject) === -1) {\n\t                fsm.config.debug && console.warn('Warning assigning state.%s handler: no such state \"%s\"', verb, subject);\n\t            } else if (type === 'action' && !fsm.transitions.has(subject)) {\n\t                fsm.config.debug && console.warn('Warning assigning action.%s handler: no such action \"%s\"', verb, subject);\n\t            }\n\t        }\n\t\n\t        // check handler is a function\n\t        if (!(0, _utils.isFunction)(fn)) {\n\t            throw new Error('Error assigning ' + verb + '.' + subject + ' handler; callback is not a Function', fn);\n\t        }\n\t\n\t        // assign\n\t        fsm.handlers.insert([type, subject, verb].join('.'), fn);\n\t    });\n\t}\n\t\n\t/*\n\t// event libs\n\thttps://www.npmjs.com/package/event-box\n\thttps://www.npmjs.com/package/dispatchy\n\t*/\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.values = exports.remove = exports.indexOf = exports.has = exports.get = exports.set = undefined;\n\texports.default = ValueMap;\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\t/**\n\t * Utility class to create, modify and delete nested hashes and values\n\t *\n\t * @constructor\n\t */\n\tfunction ValueMap(data) {\n\t    this.data = data || {};\n\t}\n\t\n\tValueMap.prototype = {\n\t    data: null,\n\t\n\t    set: function set(path, value) {\n\t        _set(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    add: function add(path, value) {\n\t        _add(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    insert: function insert(path, value) {\n\t        _insert(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    get: function get(path) {\n\t        return _get(this.data, path);\n\t    },\n\t\n\t    has: function has(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        return _has(this.data, path, value);\n\t    },\n\t\n\t    indexOf: function indexOf(path, value) {\n\t        return _indexOf(this.data, path, value);\n\t    },\n\t\n\t    remove: function remove(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        _remove(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    keys: function keys(path) {\n\t        return Object.keys(_get(this.data, path));\n\t    },\n\t\n\t    values: function values(path) {\n\t        return _values(this.data, path);\n\t    }\n\t\n\t};\n\t\n\tfunction create(obj, keys) {\n\t    var key = void 0;\n\t    while (keys.length) {\n\t        key = keys.shift();\n\t        if (!(0, _utils.isObject)(obj[key])) {\n\t            obj[key] = {};\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    return obj;\n\t}\n\t\n\tfunction _set(obj, path, value) {\n\t    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n\t\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    obj[key] = value;\n\t}\n\t\n\texports.set = _set;\n\tfunction _add(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    obj[key].push(value);\n\t}\n\t\n\tfunction _insert(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    var parent = obj[key],\n\t        index = parent.indexOf(value);\n\t    if (index === -1) {\n\t        parent.push(value);\n\t    } else {\n\t        parent[index] = value;\n\t    }\n\t}\n\t\n\tfunction _get(obj, path) {\n\t    if ((0, _utils.isUndefined)(path) || path == '') {\n\t        return obj;\n\t    }\n\t\n\t    var key = void 0,\n\t        keys = String(path).split('.');\n\t    while (keys.length > 1) {\n\t        key = keys.shift();\n\t        if (!obj.hasOwnProperty(key)) {\n\t            return;\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    key = keys.shift();\n\t    return obj[key];\n\t}\n\t\n\texports.get = _get;\n\tfunction _has(obj, path, value) {\n\t    var parent = _get(obj, path);\n\t    return !!((0, _utils.isArray)(parent) && (0, _utils.isDefined)(value) ? parent.indexOf(value) !== -1 : (0, _utils.isUndefined)(value) ? (0, _utils.isDefined)(parent) : parent === value);\n\t}\n\t\n\texports.has = _has;\n\tfunction _indexOf(obj, path, value) {\n\t    var arr = _get(obj, path);\n\t    if ((0, _utils.isArray)(arr)) {\n\t        return arr.indexOf(value);\n\t    }\n\t    return -1;\n\t}\n\t\n\texports.indexOf = _indexOf;\n\tfunction _remove(obj, path, value) {\n\t    var parent = obj,\n\t        keys = String(path || '').split('.'),\n\t        key = keys.pop();\n\t\n\t    if (keys.length) {\n\t        parent = _get(obj, keys.join('.'));\n\t    }\n\t    if ((0, _utils.isDefined)(value) && (0, _utils.isArray)(parent[key])) {\n\t        parent = parent[key];\n\t        var index = parent.indexOf(value);\n\t        if (index > -1) {\n\t            parent.splice(index, 1);\n\t            return true;\n\t        }\n\t        return false;\n\t    } else {\n\t        if ((0, _utils.isObject)(parent) && obj.hasOwnProperty(key)) {\n\t            delete parent[key];\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\t\n\texports.remove = _remove;\n\tfunction _values(obj, path) {\n\t    var values = [];\n\t    var target = _get(obj, path);\n\t    if ((0, _utils.isObject)(target)) {\n\t        for (var name in target) {\n\t            if (target.hasOwnProperty(name)) {\n\t                values.push(target[name]);\n\t            }\n\t        }\n\t    }\n\t    return values;\n\t}\n\texports.values = _values;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.isObject = isObject;\n\texports.isArray = isArray;\n\texports.isString = isString;\n\texports.isFunction = isFunction;\n\texports.isDefined = isDefined;\n\texports.isUndefined = isUndefined;\n\texports.trim = trim;\n\tfunction isObject(value) {\n\t    return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\t\n\tfunction isArray(value) {\n\t    return value instanceof Array;\n\t}\n\t\n\tfunction isString(value) {\n\t    return typeof value === 'string';\n\t}\n\t\n\tfunction isFunction(value) {\n\t    return value instanceof Function;\n\t}\n\t\n\tfunction isDefined(value) {\n\t    return typeof value !== 'undefined';\n\t}\n\t\n\tfunction isUndefined(value) {\n\t    return typeof value === 'undefined';\n\t}\n\t\n\tfunction trim(value) {\n\t    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _Events = __webpack_require__(4);\n\t\n\tvar _Events2 = _interopRequireDefault(_Events);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Transition class\n\t *\n\t * Responsible for managing events in the flow from state to state.\n\t *\n\t * The default dispatch order for all transitions is:\n\t *\n\t * - '*.start'\n\t * - ':action.start'\n\t * - ':state.leave'\n\t * - '*.leave'\n\t * - '*.enter'\n\t * - ':state.enter'\n\t * - ':action.end'\n\t * - '*.end'\n\t *\n\t * This can be changed by calling Transition.setOrder( ... )\n\t *\n\t * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n\t *\n\t * From a callback, you can:\n\t *\n\t * - return false to cancel the transition\n\t * - return true to pause the transition\n\t * - not return a value (the transition continues)\n\t *\n\t * All transitions can be paused, resumed, cancelled or completed by calling\n\t * the appropriate method on, or from:\n\t *\n\t * - the event\n\t * - the transition\n\t * - the state machine\n\t *\n\t * Cancelled transitions will reset teh FSM to the previous \"from\" state, and completed transitions will advance\n\t * the FSM to the passed \"to\" state.\n\t *\n\t * When the last callback has fired, the main FSM's complete() handler will be called and the state will update\n\t *\n\t * @param {string}          action\n\t * @param {string}          from\n\t * @param {string}          to\n\t * @param {Function[]}      handlers\n\t * @param {Object}          callbacks\n\t * @constructor\n\t */\n\tfunction Transition(action, from, to, handlers, callbacks) {\n\t    this.action = action;\n\t    this.from = from;\n\t    this.to = to;\n\t    this.handlers = handlers;\n\t    this.callbacks = callbacks;\n\t}\n\t\n\tTransition.prototype = {\n\t    action: '',\n\t    from: '',\n\t    to: '',\n\t    handlers: null,\n\t    callbacks: null,\n\t    paused: false,\n\t\n\t    clear: function clear() {\n\t        this.paused = false;\n\t        this.handlers = [];\n\t    },\n\t\n\t    /**\n\t     * Execute the next event's callbacks\n\t     * @returns {*}\n\t     */\n\t    exec: function exec() {\n\t        if (!this.paused) {\n\t            if (this.handlers.length) {\n\t                var handler = this.handlers.shift();\n\t                var state = handler();\n\t                if (state === false) {\n\t                    return this.callbacks.cancel();\n\t                }\n\t                if (state === true) {\n\t                    return this.callbacks.pause();\n\t                }\n\t                this.exec();\n\t            } else {\n\t                this.callbacks.complete();\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t\n\t    pause: function pause() {\n\t        this.paused = true;\n\t        return this;\n\t    },\n\t\n\t    resume: function resume() {\n\t        this.paused = false;\n\t        return this.exec();\n\t    }\n\t};\n\t\n\t/**\n\t *\n\t * @type {string[]} subject.verb\n\t */\n\tvar defaultOrder = ['*.start', 'action.start', 'from.leave', '*.leave', '*.enter', 'to.enter', 'action.end', '*.end'];\n\t\n\tTransition.order = defaultOrder;\n\t\n\texports.default = {\n\t    /**\n\t     * Create the Transition object\n\t     *\n\t     * - Set up variables, callbacks and queue\n\t     * - Determine paths to relevant callbacks\n\t     * - Build State and Action Event objects\n\t     * - Pre-bind all handlers\n\t     * - Append to queue\n\t     *\n\t     * @param {StateMachine}    fsm\n\t     * @param {string}          action\n\t     * @param {Array}           params\n\t     * @returns {Transition}\n\t     */\n\t    create: function create(fsm, action, params) {\n\t        // transition\n\t        var from = fsm.state;\n\t        var to = fsm.actions.get(action)[from];\n\t        var target = fsm.target;\n\t\n\t        // handle to being a function\n\t        if ((0, _utils.isFunction)(to)) {\n\t            var actions = fsm.getActionsFor();\n\t            var state = to.apply(target, [actions].concat(params));\n\t            var _action = fsm.getActionsFor(state);\n\t            // TODO debug this! It's wrong\n\t            if (!_action) {\n\t                throw new Error('Cannot go to state \"' + state + '\" from current state \"' + from + '\"');\n\t            }\n\t        }\n\t\n\t        // callbacks\n\t        var callbacks = {\n\t            cancel: fsm.cancel.bind(fsm),\n\t            pause: fsm.pause.bind(fsm),\n\t            resume: fsm.resume.bind(fsm),\n\t            complete: fsm.complete.bind(fsm)\n\t        };\n\t\n\t        // build handlers array\n\t        var queue = [];\n\t        Transition.order.map(function (token) {\n\t            // determine path variables\n\t            var _token$split = token.split('.');\n\t\n\t            var _token$split2 = _slicedToArray(_token$split, 2);\n\t\n\t            var subject = _token$split2[0];\n\t            var verb = _token$split2[1]; // i.e. *.start, to.enter, action.end\n\t\n\t            var type = /^(start|end)$/.test(verb) ? 'action' : 'state';\n\t            var name = void 0;\n\t            if (subject === '*') {\n\t                name = '*';\n\t            } else if (type == 'action') {\n\t                name = action;\n\t            } else {\n\t                name = verb === 'leave' ? from : to;\n\t            }\n\t\n\t            // get handlers\n\t            var path = [type, name, verb].join('.');\n\t            var handlers = fsm.handlers.get(path);\n\t            if (handlers) {\n\t                // bind handlers, targets and params ready for dispatch\n\t                handlers = handlers.map(function (handler) {\n\t                    return function () {\n\t                        var event = _Events2.default.create(type, callbacks, name, verb, from, to);\n\t                        handler.apply(target, [event].concat(params));\n\t                    };\n\t                });\n\t\n\t                // add to queue\n\t                queue = queue.concat(handlers);\n\t            }\n\t        });\n\t\n\t        // create\n\t        return new Transition(action, from, to, queue, callbacks);\n\t    },\n\t\n\t    /**\n\t     * Set the default sort order for transitions\n\t     *\n\t     * @param {Array} order\n\t     */\n\t    setOrder: function setOrder(order) {\n\t        Transition.order = order || defaultOrder;\n\t    },\n\t\n\t    /**\n\t     * Get the current sot order for the transitions\n\t     *\n\t     * @returns {string[]}\n\t     */\n\t    getOrder: function getOrder() {\n\t        return Transition.order;\n\t    }\n\t\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ActionEvent = ActionEvent;\n\texports.StateEvent = StateEvent;\n\texports.ChangeEvent = ChangeEvent;\n\tfunction noop() {}\n\t\n\t/**\n\t * @prop {string}  type     The Event type; i.e. state or action\n\t * @prop {string}  name     The Event subject/name; i.e. intro (state) or next (action)\n\t * @prop {string}  verb     The Event verb; i.e. leave/enter (state) or start/end (action)\n\t * @prop {string}  from     The from state\n\t * @prop {string}  to       The to state\n\t */\n\tvar event = {\n\t    type: null,\n\t    name: null,\n\t    verb: null,\n\t    from: null,\n\t    to: null,\n\t\n\t    pause: noop,\n\t    resume: noop,\n\t    cancel: noop\n\t};\n\t\n\tfunction initialize(event, callbacks, type, name, verb, from, to) {\n\t    event.type = type;\n\t    event.name = name;\n\t    event.verb = verb;\n\t    event.from = from;\n\t    event.to = to;\n\t\n\t    event.pause = callbacks.pause;\n\t    event.resume = callbacks.resume;\n\t    event.cancel = callbacks.cancel;\n\t    event.complete = callbacks.complete;\n\t}\n\t\n\tfunction ActionEvent(callbacks, name, verb, from, to) {\n\t    initialize(this, callbacks, 'action', name, verb, from, to);\n\t}\n\tActionEvent.prototype = event;\n\t\n\tfunction StateEvent(callbacks, name, verb, from, to) {\n\t    initialize(this, callbacks, 'state', name, verb, from, to);\n\t}\n\tStateEvent.prototype = event;\n\t\n\tfunction ChangeEvent(type) {\n\t    this.type = type;\n\t}\n\t\n\tChangeEvent.prototype = {\n\t    type: ''\n\t};\n\t\n\texports.default = {\n\t    create: function create(type, callbacks, name, verb, from, to) {\n\t        var fn = type == 'state' ? StateEvent : ActionEvent;\n\t        return new fn(callbacks, name, verb, from, to);\n\t    }\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** state-machine.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 1c27578faa328d1d41b0\n **/","import ValueMap from './utils/ValueMap';\nimport Transition from './Transition';\nimport { ChangeEvent } from './Events';\nimport { isString, isArray, isFunction } from './utils/utils';\n\nexport default function StateMachine (target, config)\n{\n    this.target         = target;\n    this.state          = '';\n    this.states         = [];\n    this.transitions    = new ValueMap();\n    this.actions        = new ValueMap();\n    this.handlers       = new ValueMap();\n    if(config)\n    {\n        this.initialize(config);\n        this.update('started');\n    }\n    console.log('hello there');\n}\n\n/**\n * StateMachine prototype\n *\n * The property examples below illustrate a 4-state machine, with states:\n *\n * - intro > settings > summary > end\n *\n * And actions:\n *\n * - back | next | restart | finish\n */\nStateMachine.prototype =\n{\n    // ------------------------------------------------------------------------------------------------\n    // properties\n\n        /**\n         * Available state names\n         *\n         * - [\n         *     intro,\n         *     settings,\n         *     summary,\n         *     final\n         *   ]\n         *\n         * @var {string[]}\n         */\n        states      : null,\n\n        /**\n         * Available transitions for each action\n         *\n         * action.from => to\n         *\n         * - next: {\n         *     intro: settings,\n         *     settings: summary\n         *   },\n         * - back: {\n         *     settings: intro\n         *   },\n         * - restart: {\n         *     summary:intro\n         *   },\n         * - finish: {\n         *     summary:final\n         *   },\n         *\n         * Transitions can also be functions\n         *\n         * - next: {\n         *     intro: function() { return '<random state>' } // jump to a random state\n         *   }\n         *\n         * @var {ValueMap}\n         */\n        transitions : null,\n\n        /**\n         * Actions that are available to be called from each state\n         *\n         * state => [ action, action, ... ]\n         *\n         * - intro: [\n         *     'next'\n         *   ],\n         * - settings: [\n         *     'next',\n         *     'back'\n         *   ],\n         * - summary: [\n         *     'restart'\n         *     'finish',\n         *   ]\n         *\n         * Actions can also be expressed as wildcards\n         *\n         * - intro: [\n         *     '*' // any action is allowed from intro\n         *   ]\n         *\n         * @var {ValueMap}\n         */\n        actions     : null,\n\n        /**\n         * Handler functions that should be called on each action event / state change\n         *\n         * name.type => [ handler, handler, ... ]\n         *\n         * - next: {\n         *   - start: [\n         *       hideModal\n         *     ],\n         *   - end: [\n         *       showModal\n         *     ]\n         *   },\n         * - summary: {\n         *   - enter: [\n         *       resetForm\n         *     ],\n         *   - leave: [\n         *       validateForm,\n         *       postData,\n         *     ]\n         *   },\n         *   ...\n         *\n         * @var {ValueMap}\n         */\n        handlers   : null,\n\n        /**\n         * The current state\n         *\n         * @var {string}\n         */\n        state       : '',\n\n        /**\n         * Any active Transition object that is driving the state change\n         *\n         * @var {Transition}\n         */\n        transition  : null,\n\n        /**\n         * The target context in which to call all handlers\n         *\n         * @var {*}\n         */\n        target      : null,\n\n        /**\n         * The original config object\n         *\n         * @var {Object}\n         */\n        config      : null,\n\n\n    // ------------------------------------------------------------------------------------------------\n    // private methods\n\n        /**\n         * Initialize the FSM with a config object\n         *\n         * @private\n         * @param config\n         */\n        initialize:function (config)\n        {\n            // assign config\n            this.config     = config;\n\n            // parse all states\n            addStates(this, 'from', config.events);\n            addStates(this, 'to', config.events);\n\n            // initial state\n            if( ! config.initial )\n            {\n                config.initial = this.states[0];\n            }\n\n            // add transitions\n            config.events.map( event =>\n            {\n                // shorthand\n                if(isString(event))\n                {\n                    let matches = event.match(/(\\w+)\\s*[\\|:=]\\s*(\\w+)\\s*([<>-])\\s*(\\w.*)/);\n                    let [,name, from, op, to] = matches;\n                    if(op === '-')\n                    {\n                        this.add(name, from, to);\n                        this.add(name, to, from);\n                        return;\n                    }\n                    if(op === '<')\n                    {\n                        [from, to] = [to, from];\n                    }\n                    this.add(name, from, to);\n                }\n\n                // keys\n                else\n                {\n                    this.add(event.name, event.from, event.to);\n                }\n            });\n\n            // add handlers\n            for(let name in config.handlers)\n            {\n                if(config.handlers.hasOwnProperty(name))\n                {\n                    var handler    = config.handlers[name];\n                    var matches     = name.match(/(\\w+)\\s*(.*)/);\n                    if(matches)\n                    {\n                        let [, type, param] = matches;\n                        switch(type)\n                        {\n                            case 'start'    :this.onStart(param, handler); break;\n                            case 'end'      :this.onEnd(param,   handler); break;\n                            case 'leave'    :this.onLeave(param, handler); break;\n                            case 'enter'    :this.onEnter(param, handler); break;\n                            default:\n                                this.config.debug && console.warn('Warning processing handlers config: unknown action type \"' +type+ '\"');\n                        }\n                    }\n                    else\n                    {\n                        this.config.debug && console.warn('Warning processing handlers config: unable to parse action key \"' +name+ '\"');\n                    }\n                }\n            }\n\n            // state\n            if( ! config.defer )\n            {\n                this.state = config.initial;\n            }\n\n        },\n\n        /**\n         * Dispatch an update event\n         *\n         * @param type\n         */\n        update: function (type)\n        {\n            this.config.debug && console.info('StateMachine update \"%s\"', type);\n            let handlers = this.handlers.data.change;\n            if(handlers)\n            {\n                let event = new ChangeEvent(type);\n                handlers.map(fn => fn(event) );\n            }\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // api\n\n        /**\n         * Attempt to run an action, resulting in a transition to a state\n         *\n         * @param   {string}    action\n         * @param   {*[]}       rest\n         * @returns {boolean}\n         */\n        do: function (action, ...rest)\n        {\n            if(this.can(action))\n            {\n                this.config.debug && console.info('Doing action \"%s\"', action);\n                this.transition = Transition.create(this, action, rest);\n                this.update('transitioning');\n                this.transition.exec();\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Attempt to go to a state\n         *\n         * Finds if an appropriate transition exists, then calls the related action if it does\n         *\n         * @param   {string}    state\n         * @returns {boolean}\n         */\n        go: function (state)\n        {\n            if(this.has(state))\n            {\n                var action = this.getActionForState(state);\n                if(action)\n                {\n                    return this.do(action);\n                }\n                this.config.debug && console.info('No transition exists from \"%s\" to \"%s\"', this.state, state);\n            }\n            else\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n            }\n            return false;\n        },\n\n        /**\n         * Query a transition to see if a named action is available\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        can: function (action)\n        {\n            if( ! this.actions.has(action) )\n            {\n                this.config.debug && console.warn('No such action \"%s\"', action);\n            }\n            return !! this.transitions.has(this.state, action);\n        },\n\n        /**\n         * Query a transition to see if a named action is unavailable\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        cannot: function (action)\n        {\n            return ! this.can(action);\n        },\n\n        /**\n         * Test if the current state is the same as the supplied one\n         *\n         * @param   {string}    state       A state name to compare against the current state\n         * @returns {boolean}\n         */\n        is: function (state)\n        {\n            if(this.states.indexOf(state) === -1)\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n            }\n            return state === this.state;\n        },\n\n        /**\n         * Test if a state exists\n         *\n         * @param   {string}    state\n         * @return  {boolean}\n         */\n        has: function(state)\n        {\n            return this.states.indexOf(state) !== -1;\n        },\n\n        /**\n         * Get the available \"to\" states for the current or supplied state\n         *\n         * @param   {string}    [state]     Optional name of a state to get states for. Defaults to the current state\n         * @returns {string[]}              An array of string states\n         */\n        getStatesFor: function (state = null)\n        {\n            state       = state || this.state;\n            let actions = this.getActionsFor(state, true);\n            return Object.keys(actions).map( name => actions[name] );\n        },\n\n        /**\n         * Get the available actions (or actions and states) for the current or supplied state\n         *\n         * @param   {string}    [state]     Optional name of a state to get actions for. Defaults to the current state\n         * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n         * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n         */\n        getActionsFor: function (state = null, asMap = false)\n        {\n            state       = state || this.state;\n            let actions = this.transitions.get(state || this.state);\n            if(asMap)\n            {\n                let states  = {};\n                actions.map( action =>\n                {\n                    states[action] = this.actions.get(action + '.' + state);\n                });\n                return states;\n            }\n            else\n            {\n                return actions;\n            }\n        },\n\n        getActionForState: function (state)\n        {\n            if(this.has(state))\n            {\n                let actions = this.getActionsFor(null, true);\n                for(let action in actions)\n                {\n                    if(actions[action] === state)\n                    {\n                        return action;\n                    }\n                }\n            }\n            return null\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // flags\n\n        /**\n         * Test if the FSM has started\n         *\n         * @returns {boolean}\n         */\n        isStarted: function ()\n        {\n            return this.state !== '';\n        },\n\n        /**\n         * Test if the FSM is on the \"final\" state\n         *\n         * @returns {boolean}\n         */\n        isFinished: function ()\n        {\n            return this.state === this.config.final;\n        },\n\n        /**\n         * Test if the FSM is transitioning\n         *\n         * @returns {boolean}\n         */\n        isTransitioning: function ()\n        {\n            return !! this.transition;\n        },\n\n        /**\n         * Test if the FSM is paused (whilst transitioning)\n         *\n         * @returns {boolean}\n         */\n        isPaused: function ()\n        {\n            return this.transition\n                ? this.transition.paused\n                : false;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // transitions\n\n        /**\n         * Pause any current transition\n         *\n         * @returns {StateMachine}\n         */\n        pause: function ()\n        {\n            if(this.transition)\n            {\n                this.transition.pause();\n                this.update('paused');\n            }\n            return this;\n        },\n\n        /**\n         * Resume any current transition\n         *\n         * @returns {StateMachine}\n         */\n        resume: function ()\n        {\n            if(this.transition)\n            {\n                this.update('resumed');\n                this.transition.resume();\n            }\n            return this;\n        },\n\n        /**\n         * Cancel any current transition\n         *\n         * @returns {StateMachine}\n         */\n        cancel: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.from;\n                this.transition.clear();\n                delete this.transition;\n                this.update('cancelled');\n            }\n            return this;\n        },\n\n        /**\n         * Complete any current transition, skipping remaining handlers\n         *\n         * @returns {StateMachine}\n         */\n        complete: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.to;\n                this.transition.clear();\n                delete this.transition;\n                this.update('transitioned');\n                if(this.isFinished())\n                {\n                    this.update('finished');\n                }\n            }\n            return this;\n        },\n\n        /**\n         * Reset the FSM to the initial, or supplied, state\n         *\n         * @returns {StateMachine}\n         */\n        reset:function(initial)\n        {\n            this.state = initial || this.config.initial;\n            if(this.transition)\n            {\n                this.transition.clear();\n                delete this.transition;\n            }\n            this.update('reset');\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // actions\n\n        /**\n         * Add a transition event\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        add: function (action, from, to)\n        {\n            this.actions.set(action + '.' + from, to);\n            this.transitions.add(from, action);\n            return this;\n        },\n\n        remove: function (action, from, to)\n        {\n            this.states.remove(action, from);\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // handlers\n\n        onChange: function (fn)\n        {\n            this.handlers.add('change', fn);\n            return this;\n        },\n\n        onStart: function (action, fn)\n        {\n            addHandler(this, 'action', 'start', action, fn);\n            return this;\n        },\n\n        onEnd: function (action, fn)\n        {\n            addHandler(this, 'action', 'end', action, fn);\n            return this;\n        },\n\n        onEnter: function (state, fn)\n        {\n            addHandler(this, 'state', 'enter', state, fn);\n            return this;\n        },\n\n        onLeave: function (state, fn)\n        {\n            addHandler(this, 'state', 'leave', state, fn);\n            return this;\n        },\n\n        off: function (type, target, fn)\n        {\n            return this;\n        }\n\n}\n\n/**\n * Parses config and adds unique state names to states array\n *\n * @param {StateMachine}    fsm\n * @param {string}          key\n * @param {Object[]}        transitions\n */\nfunction addStates(fsm, key, transitions)\n{\n    transitions.map( event => addState(fsm, event[key]) );\n}\n\nfunction addState (fsm, state)\n{\n    if (isString(state) && fsm.states.indexOf(state) === -1)\n    {\n        fsm.states.push(state);\n    }\n}\n\n/**\n * Generic function to parse action and add callback\n *\n * @param {StateMachine}    fsm\n * @param {string}          type\n * @param {string}          verb\n * @param {string|Function} rest\n */\nfunction addHandler(fsm, type, verb, ...rest)\n{\n    // params\n    if(rest.length === 1)\n    {\n        rest = ['*', rest[0]];\n    }\n    let [param, fn] = rest;\n\n    // parse states\n    let states = isArray(param)\n        ? param\n        : param == ''\n            ? ['*']\n            : param.match(/\\*|\\w+[-\\w]+/g);\n\n    // assign handlers\n    states.map( subject =>\n    {\n        // warn for invalid actions / states\n        if(subject !== '*')\n        {\n            if(type === 'state' && fsm.states.indexOf(subject) === -1)\n            {\n                fsm.config.debug && console.warn('Warning assigning state.%s handler: no such state \"%s\"', verb, subject);\n            }\n            else if(type === 'action' && ! fsm.transitions.has(subject))\n            {\n                fsm.config.debug && console.warn('Warning assigning action.%s handler: no such action \"%s\"', verb, subject);\n            }\n        }\n\n        // check handler is a function\n        if( ! isFunction(fn) )\n        {\n            throw new Error('Error assigning ' +verb+ '.' +subject+ ' handler; callback is not a Function', fn);\n        }\n\n        // assign\n        fsm.handlers.insert([type, subject, verb].join('.'), fn);\n    });\n}\n\n/*\n// event libs\nhttps://www.npmjs.com/package/event-box\nhttps://www.npmjs.com/package/dispatchy\n*/\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/StateMachine.js\n **/","import {isObject, isArray, isDefined, isUndefined} from './utils';\n\n/**\n * Utility class to create, modify and delete nested hashes and values\n *\n * @constructor\n */\nexport default function ValueMap (data)\n{\n    this.data = data || {};\n}\n\nValueMap.prototype =\n{\n    data: null,\n\n    set: function (path, value)\n    {\n        set(this.data, path, value);\n        return this;\n    },\n\n    add:function(path, value)\n    {\n        add(this.data, path, value);\n        return this;\n    },\n\n    insert:function(path, value)\n    {\n        insert(this.data, path, value);\n        return this;\n    },\n\n    get:function(path)\n    {\n        return get(this.data, path);\n    },\n\n    has: function (path, value = undefined)\n    {\n        return has(this.data, path, value)\n    },\n\n    indexOf: function (path, value)\n    {\n        return indexOf(this.data, path, value)\n    },\n\n    remove: function (path, value = undefined)\n    {\n        remove(this.data, path, value);\n        return this;\n    },\n\n    keys:function(path)\n    {\n        return Object.keys(get(this.data, path));\n    },\n\n    values:function(path)\n    {\n        return values(this.data, path);\n    }\n\n};\n\nfunction create(obj, keys)\n{\n    let key;\n    while(keys.length)\n    {\n        key = keys.shift();\n        if( ! isObject(obj[key]) )\n        {\n            obj[key] = {};\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n\nexport function set(obj, path, value, index = -1)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    obj[key] = value;\n}\n\nfunction add(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    obj[key].push(value);\n}\n\nfunction insert(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    let parent = obj[key],\n        index = parent.indexOf(value);\n    if(index === -1)\n    {\n        parent.push(value);\n    }\n    else\n    {\n        parent[index] = value;\n    }\n}\n\nexport function get(obj, path)\n{\n    if(isUndefined(path) || path == '')\n    {\n        return obj;\n    }\n\n    let key,\n        keys = String(path).split('.');\n    while(keys.length > 1)\n    {\n        key = keys.shift();\n        if( ! obj.hasOwnProperty(key) )\n        {\n            return;\n        }\n        obj = obj[key];\n    }\n    key = keys.shift();\n    return obj[key];\n}\n\nexport function has(obj, path, value)\n{\n    let parent = get(obj, path);\n    return !! (isArray(parent) && isDefined(value)\n        ? parent.indexOf(value) !== -1\n        : isUndefined(value)\n            ? isDefined(parent)\n            : parent === value);\n}\n\nexport function indexOf (obj, path, value)\n{\n    let arr = get(obj, path);\n    if(isArray(arr))\n    {\n        return arr.indexOf(value);\n    }\n    return -1;\n}\n\nexport function remove(obj, path, value)\n{\n    let parent = obj,\n        keys = String(path || '').split('.'),\n        key = keys.pop();\n\n    if(keys.length)\n    {\n        parent = get(obj, keys.join('.'))\n    }\n    if(isDefined(value) && isArray(parent[key]))\n    {\n        parent = parent[key];\n        var index = parent.indexOf(value);\n        if(index > -1)\n        {\n            parent.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n    else\n    {\n        if(isObject(parent) && obj.hasOwnProperty(key))\n        {\n            delete parent[key];\n            return true;\n        }\n    }\n    return false\n}\n\nexport function values(obj, path)\n{\n    var values = [];\n    var target = get(obj, path);\n    if(isObject(target))\n    {\n        for(var name in target)\n        {\n            if(target.hasOwnProperty(name))\n            {\n                values.push(target[name]);\n            }\n        }\n    }\n    return values;\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/ValueMap.js\n **/","export function isObject (value)\n{\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport function isArray (value)\n{\n    return value instanceof Array;\n}\n\nexport function isString (value)\n{\n    return typeof value === 'string';\n}\n\nexport function isFunction(value)\n{\n    return value instanceof Function;\n}\n\nexport function isDefined (value)\n{\n    return typeof value !== 'undefined';\n}\n\nexport function isUndefined (value)\n{\n    return typeof value === 'undefined';\n}\n\nexport function trim (value)\n{\n    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/utils.js\n **/","import Events from './Events';\nimport { isFunction } from './utils/utils';\n\n/**\n * Transition class\n *\n * Responsible for managing events in the flow from state to state.\n *\n * The default dispatch order for all transitions is:\n *\n * - '*.start'\n * - ':action.start'\n * - ':state.leave'\n * - '*.leave'\n * - '*.enter'\n * - ':state.enter'\n * - ':action.end'\n * - '*.end'\n *\n * This can be changed by calling Transition.setOrder( ... )\n *\n * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n *\n * From a callback, you can:\n *\n * - return false to cancel the transition\n * - return true to pause the transition\n * - not return a value (the transition continues)\n *\n * All transitions can be paused, resumed, cancelled or completed by calling\n * the appropriate method on, or from:\n *\n * - the event\n * - the transition\n * - the state machine\n *\n * Cancelled transitions will reset teh FSM to the previous \"from\" state, and completed transitions will advance\n * the FSM to the passed \"to\" state.\n *\n * When the last callback has fired, the main FSM's complete() handler will be called and the state will update\n *\n * @param {string}          action\n * @param {string}          from\n * @param {string}          to\n * @param {Function[]}      handlers\n * @param {Object}          callbacks\n * @constructor\n */\nfunction Transition (action, from, to, handlers, callbacks)\n{\n    this.action     = action;\n    this.from       = from;\n    this.to         = to;\n    this.handlers   = handlers;\n    this.callbacks  = callbacks;\n}\n\nTransition.prototype =\n{\n    action      : '',\n    from        : '',\n    to          : '',\n    handlers    : null,\n    callbacks   : null,\n    paused      : false,\n\n    clear: function ()\n    {\n        this.paused = false;\n        this.handlers = [];\n    },\n\n    /**\n     * Execute the next event's callbacks\n     * @returns {*}\n     */\n\texec: function ()\n\t{\n\t    if( ! this.paused )\n        {\n            if(this.handlers.length)\n            {\n                var handler = this.handlers.shift();\n                var state = handler();\n                if(state === false)\n                {\n                    return this.callbacks.cancel();\n                }\n                if(state === true)\n                {\n                    return this.callbacks.pause();\n                }\n                this.exec();\n            }\n            else\n            {\n                this.callbacks.complete();\n            }\n        }\n        return this;\n\t},\n\n    pause: function ()\n    {\n        this.paused = true;\n        return this;\n    },\n\n    resume: function ()\n    {\n        this.paused = false;\n        return this.exec();\n    }\n};\n\n/**\n *\n * @type {string[]} subject.verb\n */\nlet defaultOrder = [\n    '*.start',\n    'action.start',\n    'from.leave',\n    '*.leave',\n    '*.enter',\n    'to.enter',\n    'action.end',\n    '*.end'\n]\n\nTransition.order = defaultOrder;\n\nexport default\n{\n    /**\n     * Create the Transition object\n     *\n     * - Set up variables, callbacks and queue\n     * - Determine paths to relevant callbacks\n     * - Build State and Action Event objects\n     * - Pre-bind all handlers\n     * - Append to queue\n     *\n     * @param {StateMachine}    fsm\n     * @param {string}          action\n     * @param {Array}           params\n     * @returns {Transition}\n     */\n    create:function (fsm, action, params)\n    {\n        // transition\n        var from    = fsm.state;\n        var to      = fsm.actions.get(action)[from];\n        var target  = fsm.target;\n\n        // handle to being a function\n        if(isFunction(to))\n        {\n            let actions = fsm.getActionsFor();\n            let state   = to.apply(target, [actions].concat(params));\n            let action  = fsm.getActionsFor(state);\n            // TODO debug this! It's wrong\n            if( ! action )\n            {\n                throw new Error('Cannot go to state \"' +state+ '\" from current state \"' +from+ '\"');\n            }\n        }\n\n        // callbacks\n        var callbacks =\n        {\n            cancel   :fsm.cancel.bind(fsm),\n            pause    :fsm.pause.bind(fsm),\n            resume   :fsm.resume.bind(fsm),\n            complete :fsm.complete.bind(fsm)\n        }\n\n        // build handlers array\n        var queue   = [];\n        Transition.order.map( token =>\n        {\n            // determine path variables\n            let [subject, verb]     = token.split('.'); // i.e. *.start, to.enter, action.end\n            let type                = /^(start|end)$/.test(verb) ? 'action' : 'state';\n            let name;\n            if(subject === '*')\n            {\n                name = '*';\n            }\n            else if(type == 'action')\n            {\n                name = action;\n            }\n            else\n            {\n                name = verb === 'leave'\n                    ? from\n                    : to;\n            }\n\n            // get handlers\n            let path = [type, name, verb].join('.');\n            let handlers = fsm.handlers.get(path);\n            if(handlers)\n            {\n                // bind handlers, targets and params ready for dispatch\n                handlers = handlers.map( handler =>\n                {\n                    return function()\n                    {\n                        let event = Events.create(type, callbacks, name, verb, from, to);\n                        handler.apply(target, [event].concat(params));\n                    }\n                });\n\n                // add to queue\n                queue = queue.concat(handlers);\n            }\n\n        });\n\n        // create\n        return new Transition(action, from, to, queue, callbacks);\n    },\n\n    /**\n     * Set the default sort order for transitions\n     *\n     * @param {Array} order\n     */\n    setOrder:function(order)\n    {\n        Transition.order = order || defaultOrder;\n    },\n\n    /**\n     * Get the current sot order for the transitions\n     *\n     * @returns {string[]}\n     */\n    getOrder:function()\n    {\n        return Transition.order;\n    }\n\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/Transition.js\n **/","function noop () { }\n\n/**\n * @prop {string}  type     The Event type; i.e. state or action\n * @prop {string}  name     The Event subject/name; i.e. intro (state) or next (action)\n * @prop {string}  verb     The Event verb; i.e. leave/enter (state) or start/end (action)\n * @prop {string}  from     The from state\n * @prop {string}  to       The to state\n */\nlet event =\n{\n    type    : null,\n    name    : null,\n    verb    : null,\n    from    : null,\n    to      : null,\n\n    pause   : noop,\n    resume  : noop,\n    cancel  : noop\n};\n\nfunction initialize (event, callbacks, type, name, verb, from, to)\n{\n    event.type      = type;\n    event.name      = name;\n    event.verb      = verb;\n    event.from      = from;\n    event.to        = to;\n\n    event.pause     = callbacks.pause;\n    event.resume    = callbacks.resume;\n    event.cancel    = callbacks.cancel;\n    event.complete  = callbacks.complete;\n}\n\nexport function ActionEvent (callbacks, name, verb, from, to)\n{\n    initialize(this, callbacks, 'action' ,name, verb, from, to);\n}\nActionEvent.prototype = event;\n\nexport function StateEvent (callbacks, name, verb, from, to)\n{\n    initialize(this, callbacks, 'state' ,name, verb, from, to);\n}\nStateEvent.prototype = event;\n\nexport function ChangeEvent (type)\n{\n    this.type = type;\n}\n\nChangeEvent.prototype =\n{\n    type: ''\n}\n\nexport default\n{\n    create: function(type, callbacks, name, verb, from, to)\n    {\n        var fn = type == 'state'\n            ? StateEvent\n            : ActionEvent;\n        return new fn(callbacks, name, verb, from, to);\n    }\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/Events.js\n **/"],"sourceRoot":""}