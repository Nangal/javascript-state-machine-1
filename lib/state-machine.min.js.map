{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///state-machine.min.js","webpack:///webpack/bootstrap d538063be882fab1e13c","webpack:///./src/StateMachine.js","webpack:///./src/utils/ValueMap.js","webpack:///./src/utils/utils.js","webpack:///./src/Transition.js","webpack:///./src/Events.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","StateMachine","scope","config","state","states","transitions","_ValueMap2","actions","handlers","initialize","update","addStates","fsm","key","map","event","addState","_utils","isString","indexOf","push","addHandler","namespace","type","target","fn","debug","console","warn","has","isFunction","Error","path","join","insert","parseHandler","matches","match","_matches2","_slicedToArray","eventNamespaces","targets","Object","defineProperty","value","_typeof","Symbol","iterator","constructor","prototype","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","next","done","length","err","Array","isArray","TypeError","_ValueMap","_Transition","_Transition2","_Events","transition","_this","events","initial","_matches","name","from","op","to","add","_ref","hasOwnProperty","on","defer","order","SystemEvent","TransitionEvent","dispatch","do","action","can","info","_len","arguments","rest","_key","create","exec","go","getActionForState","cannot","is","getStatesFor","getActionsFor","keys","_this2","asMap","get","_ret","v","isStarted","isTransitioning","isPaused","paused","isComplete","pause","resume","cancel","clear","end","reset","set","remove","_this3","_parseHandler","_parseHandler2","off","_parseHandler3","_parseHandler4","change","complete","leave","enter","start","ValueMap","data","shift","isObject","String","split","pop","parent","index","isUndefined","isDefined","splice","values","_set","_get","_has","_indexOf","_remove","_values","toString","Function","trim","replace","Transition","callbacks","_Events2","handler","params","queue","bind","apply","concat","token","_token$split","_token$split2","source","test","noop","ActionEvent","StateEvent"],"mappings":"CAAA,SAAAA,EAAAC,GACA,gBAAAC,UAAA,gBAAAC,QACAA,OAAAD,QAAAD,IACA,kBAAAG,gBAAAC,IACAD,OAAA,kBAAAH,GACA,gBAAAC,SACAA,QAAA,aAAAD,IAEAD,EAAA,aAAAC,KACCK,KAAA,WACD,MCAgB,UAAUC,GCN1B,QAAAC,GAAAC,GAGA,GAAAC,EAAAD,GACA,MAAAC,GAAAD,GAAAP,OAGA,IAAAC,GAAAO,EAAAD,IACAP,WACAS,GAAAF,EACAG,QAAA,EAUA,OANAL,GAAAE,GAAAI,KAAAV,EAAAD,QAAAC,IAAAD,QAAAM,GAGAL,EAAAS,QAAA,EAGAT,EAAAD,QAvBA,GAAAQ,KAqCA,OATAF,GAAAM,EAAAP,EAGAC,EAAAO,EAAAL,EAGAF,EAAAQ,EAAA,GAGAR,EAAA,KDgBM,SAASL,EAAQD,EAASM,GAE/B,YAwBA,SAASS,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GE3EzE,QAASG,GAAcC,EAAOC,GAEzCjB,KAAKgB,MAAiBA,EACtBhB,KAAKkB,MAAiB,GACtBlB,KAAKmB,UACLnB,KAAKoB,YAAiB,GAAAC,cACtBrB,KAAKsB,QAAiB,GAAAD,cACtBrB,KAAKuB,SAAiB,GAAAF,cACnBJ,IAECjB,KAAKwB,WAAWP,GAChBjB,KAAKyB,OAAO,SAAU,eAooB9B,QAASC,GAAUC,EAAKC,EAAKR,GAEzBA,EAAYS,IAAK,SAAAC,GAAA,MAASC,GAASJ,EAAKG,EAAMF,MAGlD,QAASG,GAAUJ,EAAKT,IAEhB,EAAAc,EAAAC,UAASf,IAAUS,EAAIR,OAAOe,QAAQhB,SAEtCS,EAAIR,OAAOgB,KAAKjB,GAaxB,QAASkB,GAAWT,EAAKU,EAAWC,EAAMC,EAAQC,GAgB9C,GAbc,MAAXD,IAEkB,UAAdF,GAAyBV,EAAIR,OAAOe,QAAQK,QAE3CZ,EAAIV,OAAOwB,OAASC,QAAQC,KAAK,yDAA0DL,EAAMC,GAE/E,WAAdF,GAA4BV,EAAIL,QAAQsB,IAAIL,IAEhDZ,EAAIV,OAAOwB,OAASC,QAAQC,KAAK,2DAA4DL,EAAMC,MAKrG,EAAAP,EAAAa,YAAWL,GAEb,KAAM,IAAIM,OAAM,mBAAoBT,EAAW,IAAKC,EAAM,uCAAwCE,EAItG,IAAIO,GAAqB,WAAdV,GAAwC,UAAdA,GAC9BA,EAAWE,EAAQD,GAAMU,KAAK,KAC/BX,EAAY,IAAMC,CACxBX,GAAIJ,SAAS0B,OAAOF,EAAMP,GAG9B,QAASU,GAAavB,EAAKtB,GAGvB,GAAI8C,GAAU9C,EAAG+C,MAAM,sCACvB,KAAID,EAEA,KAAM,IAAIL,OAAM,wDAAyDzC,EALjF,IAAAgD,GAAAC,EAOqCH,EAPrC,GAOUd,EAPVgB,EAAA,GAOqBf,EAPrBe,EAAA,GAO2Bd,EAP3Bc,EAAA,EAUQhB,KAGAA,EAAYkB,EAAgBjB,GAGxBD,IAEGV,EAAIR,OAAOe,QAAQI,SAElBC,EAAcD,EACdD,EAAc,QACdC,EAAc,SAGVX,EAAIL,QAAQsB,IAAIN,IAEpBC,EAAcD,EACdD,EAAc,SACdC,EAAc,SAIdX,EAAIV,OAAOwB,OAASC,QAAQC,KAAK,wFAAyFtC,IAMtI,IAAImD,GAAUjB,EACRA,EAAOa,MAAM,YACZ,IAEP,QAAQf,EAAWC,EAAMkB,GFxrB5BC,OAAOC,eAAe9D,EAAS,cAC3B+D,OAAO,GAGX,IAAIC,GAA4B,kBAAXC,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUlD,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXiD,SAAyBjD,EAAImD,cAAgBF,QAAUjD,IAAQiD,OAAOG,UAAY,eAAkBpD,IAElQ0C,EAAiB,WAAc,QAASW,GAAcC,EAAKC,GAAK,GAAIC,MAAeC,GAAK,EAAUC,GAAK,EAAWC,EAAKC,MAAW,KAAM,IAAK,GAAiCC,GAA7BC,EAAKR,EAAIL,OAAOC,cAAmBO,GAAMI,EAAKC,EAAGC,QAAQC,QAAoBR,EAAKjC,KAAKsC,EAAGd,QAAYQ,GAAKC,EAAKS,SAAWV,GAA3DE,GAAK,IAAoE,MAAOS,GAAOR,GAAK,EAAMC,EAAKO,EAAO,QAAU,KAAWT,GAAMK,EAAG,WAAWA,EAAG,YAAe,QAAU,GAAIJ,EAAI,KAAMC,IAAQ,MAAOH,GAAQ,MAAO,UAAUF,EAAKC,GAAK,GAAIY,MAAMC,QAAQd,GAAQ,MAAOA,EAAY,IAAIL,OAAOC,WAAYL,QAAOS,GAAQ,MAAOD,GAAcC,EAAKC,EAAa,MAAM,IAAIc,WAAU,2DAEtlBrF,cE7DuBmB,CALxB,IAAAmE,GAAAhF,EAAA,GFsEKmB,EAAaV,EAAuBuE,GErEzCC,EAAAjF,EAAA,GFyEKkF,EAAezE,EAAuBwE,GExE3CE,EAAAnF,EAAA,GACA8B,EAAA9B,EAAA,EA4BAa,GAAaiD,WAiBL7C,OAAc,KA6BdC,YAAc,KA2BdE,QAAc,KA4BdC,SAAa,KAObL,MAAc,GAOdoE,WAAc,KAOdtE,MAAa,KAObC,OAAc,KAYdO,WAAW,SAAUP,GACrB,GAAAsE,GAAAvF,IAEIA,MAAKiB,OAAaA,EAGlBS,EAAU1B,KAAM,OAAQiB,EAAOuE,QAC/B9D,EAAU1B,KAAM,KAAMiB,EAAOuE,QAGvBvE,EAAOwE,UAETxE,EAAOwE,QAAUzF,KAAKmB,OAAO,IAIjCF,EAAOuE,OAAO3D,IAAK,SAAAC,GAGf,IAAG,EAAAE,EAAAC,UAASH,GACZ,CACI,GAAIqB,GAAUrB,EAAMsB,MAAM,6CAD9BsC,EAAApC,EAEgCH,EAFhC,GAEUwC,EAFVD,EAAA,GAEgBE,EAFhBF,EAAA,GAEsBG,EAFtBH,EAAA,GAE0BI,EAF1BJ,EAAA,EAGI,IAAU,MAAPG,EAIC,MAFAN,GAAKQ,IAAIJ,EAAMC,EAAME,OACrBP,GAAKQ,IAAIJ,EAAMG,EAAIF,EAGvB,IAAU,MAAPC,EACH,IAAAG,IACkBF,EAAIF,EAAjBA,GADLI,EAAA,GACWF,EADXE,EAAA,GAGAT,EAAKQ,IAAIJ,EAAMC,EAAME,OAMrBP,GAAKQ,IAAIjE,EAAM6D,KAAM7D,EAAM8D,KAAM9D,EAAMgE,KAK/C,KAAI,GAAIH,KAAQ1E,GAAOM,SAEhBN,EAAOM,SAAS0E,eAAeN,IAE9B3F,KAAKkG,GAAGP,EAAM1E,EAAOM,SAASoE,GAKhC1E,GAAOkF,QAETnG,KAAKkB,MAAQD,EAAOwE,SAYxBxE,EAAOmF,MAAQnF,EAAOmF,QAClB,UACA,eACA,aACA,UACA,UACA,WACA,aACA,UAUR3E,OAAQ,SAAUY,EAAWC,GAEzB,GAAIR,GAAsB,WAAdO,EAAAgD,EAAAgB,YAAAhB,EAAAiB,eAIZ,OADAtG,MAAKuG,SAASlE,EAAY,IAAMC,EAAM,GAAIR,GAAMQ,IACzCtC,MAcXwG,KAAI,SAAUC,GAEV,GAAGzG,KAAK0G,IAAID,GACZ,CACIzG,KAAKiB,OAAOwB,OAASC,QAAQiE,KAAK,oBAAqBF,EAD3D,QAAAG,GAAAC,UAAAhC,OAHqBiC,EAGrB/B,MAAA6B,EAAA,EAAAA,EAAA,KAAAG,EAAA,EAAAA,EAAAH,EAAAG,IAHqBD,EAGrBC,EAAA,GAAAF,UAAAE,EAMI,OAJA/G,MAAKsF,WAAaF,aAAW4B,OAAOhH,KAAMyG,EAAQK,GAClD9G,KAAKyB,OAAO,aAAc,SAC1BzB,KAAKyB,OAAO,SAAU,UACtBzB,KAAKsF,WAAW2B,QACT,EAEX,OAAO,GAWXC,GAAI,SAAUhG,GAEV,GAAGlB,KAAK4C,IAAI1B,GACZ,CACI,GAAIuF,GAASzG,KAAKmH,kBAAkBjG,EACpC,IAAGuF,EAEC,MAAOzG,YAAQyG,EAEnBzG,MAAKiB,OAAOwB,OAASC,QAAQiE,KAAK,yCAA0C3G,KAAKkB,MAAOA,OAIxFlB,MAAKiB,OAAOwB,OAASC,QAAQC,KAAK,qBAAsBzB,EAE5D,QAAO,GASXwF,IAAK,SAAUD,GAMX,MAJMzG,MAAKsB,QAAQsB,IAAI6D,IAEnBzG,KAAKiB,OAAOwB,OAASC,QAAQC,KAAK,sBAAuB8D,KAEnDzG,KAAKoB,YAAYwB,IAAI5C,KAAKkB,MAAOuF,IAS/CW,OAAQ,SAAUX,GAEd,OAASzG,KAAK0G,IAAID,IAStBY,GAAI,SAAUnG,GAMV,MAJGlB,MAAKmB,OAAOe,QAAQhB,SAEnBlB,KAAKiB,OAAOwB,OAASC,QAAQC,KAAK,qBAAsBzB,GAErDA,IAAUlB,KAAKkB,OAS1B0B,IAAK,SAAS1B,GAEV,MAAOlB,MAAKmB,OAAOe,QAAQhB,SAS/BoG,aAAc,WACd,GADwBpG,GACxB2F,UAAAhC,OAAA,GAAAL,SAAAqC,UAAA,GAAAA,UAAA,GADgC,IAE5B3F,GAAcA,GAASlB,KAAKkB,KAC5B,IAAII,GAAUtB,KAAKuH,cAAcrG,GAAO,EACxC,OAAOuC,QAAO+D,KAAKlG,GAASO,IAAK,SAAA8D,GAAA,MAAQrE,GAAQqE,MAUrD4B,cAAe,WACf,GAAAE,GAAAzH,KADyBkB,EACzB2F,UAAAhC,OAAA,GAAAL,SAAAqC,UAAA,GAAAA,UAAA,GADiC,KAAMa,EACvCb,UAAAhC,OAAA,GAAAL,SAAAqC,UAAA,IAAAA,UAAA,EACI3F,GAAcA,GAASlB,KAAKkB,KAC5B,IAAII,GAAUtB,KAAKoB,YAAYuG,IAAIzG,GAASlB,KAAKkB,MACjD,KAAGwG,EAWC,MAAOpG,EAVX,IAAAsG,GAAA,WACI,GAAIzG,KAKJ,OAJAG,GAAQO,IAAK,SAAA4E,GAETtF,EAAOsF,GAAUgB,EAAKnG,QAAQqG,IAAIlB,EAAS,IAAMvF,MAErD2G,EAAO1G,KANX,sCAAAyG,GAAA,YAAAhE,EAAAgE,MAAAC,EAAA,QAcJV,kBAAmB,SAAUjG,GAEzB,GAAGlB,KAAK4C,IAAI1B,GACZ,CACI,GAAII,GAAUtB,KAAKuH,cAAc,MAAM,EACvC,KAAI,GAAId,KAAUnF,GAEd,GAAGA,EAAQmF,KAAYvF,EAEnB,MAAOuF,GAInB,MAAO,OAYXqB,UAAW,WAEP,MAAsB,KAAf9H,KAAKkB,OAQhB6G,gBAAiB,WAEb,QAAU/H,KAAKsF,YAQnB0C,SAAU,WAEN,QAAOhI,KAAKsF,YACNtF,KAAKsF,WAAW2C,QAS1BC,WAAY,WAER,MAAOlI,MAAKkB,QAAUlB,KAAKiB,OAALjB,UAY1BmI,MAAO,WAQH,MANGnI,MAAKsF,aAEJtF,KAAKsF,WAAW6C,QAChBnI,KAAKyB,OAAO,aAAc,SAC1BzB,KAAKyB,OAAO,SAAU,WAEnBzB,MAQXoI,OAAQ,WAQJ,MANGpI,MAAKsF,aAEJtF,KAAKyB,OAAO,aAAc,UAC1BzB,KAAKyB,OAAO,SAAU,UACtBzB,KAAKsF,WAAW8C,UAEbpI,MAQXqI,OAAQ,WAUJ,MARGrI,MAAKsF,aAEJtF,KAAKkB,MAAQlB,KAAKsF,WAAWM,KAC7B5F,KAAKsF,WAAWgD,cACTtI,MAAKsF,WACZtF,KAAKyB,OAAO,aAAc,UAC1BzB,KAAKyB,OAAO,SAAU,WAEnBzB,MAQXuI,IAAK,WAeD,MAbGvI,MAAKsF,aAEJtF,KAAKkB,MAAQlB,KAAKsF,WAAWQ,GAC7B9F,KAAKsF,WAAWgD,cACTtI,MAAKsF,WACZtF,KAAKyB,OAAO,SAAU,UACtBzB,KAAKyB,OAAO,SAAU,UACnBzB,KAAKkI,cAEJlI,KAAKyB,OAAO,SAAU,YAE1BzB,KAAKyB,OAAO,aAAc,QAEvBzB,MAQXwI,MAAM,SAAS/C,GASX,MAPAzF,MAAKkB,MAAQuE,GAAWzF,KAAKiB,OAAOwE,QACjCzF,KAAKsF,aAEJtF,KAAKsF,WAAWgD,cACTtI,MAAKsF,YAEhBtF,KAAKyB,OAAO,SAAU,SACfzB,MAeX+F,IAAK,SAAUU,EAAQb,EAAME,GAIzB,MAFA9F,MAAKsB,QAAQmH,IAAIhC,EAAS,IAAMb,EAAME,GACtC9F,KAAKoB,YAAY2E,IAAIH,EAAMa,GACpBzG,MAGX0I,OAAQ,SAAUjC,EAAQb,EAAME,GAE5B9F,KAAKmB,OAAOuH,OAAOjC,EAAQb,IAyC/BM,GAAI,SAAU7F,EAAImC,GAClB,GAAAmG,GAAA3I,KAAA4I,EACqC1F,EAAalD,KAAMK,GADxDwI,EAAAvF,EAAAsF,EAAA,GACSvG,EADTwG,EAAA,GACoBvG,EADpBuG,EAAA,GAC0BrF,EAD1BqF,EAAA,EAGI,OADArF,GAAQ3B,IAAK,SAAAU,GAAA,MAAUH,KAAiBC,EAAWC,EAAMC,EAAQC,KAC1DxC,MAGX8I,IAAK,SAAUzI,EAAImC,GACnB,GAAAuG,GACqC7F,EAAalD,KAAMK,GADxD2I,EAAA1F,EAAAyF,EAAA,EAAAC,GAAA,GAAAA,EAAA,GAAAA,EAAA,EAEIhJ,MAAKuB,SAASmH,OAAO3F,KAAMP,IAG/B+D,SAAU,SAASxD,EAAMjB,GAErB9B,KAAKiB,OAAOwB,OAASC,QAAQiE,KAAK,2BAA4B5D,EAC9D,IAAIxB,GAAWvB,KAAKuB,SAASoG,IAAI5E,EAC9BxB,IAGCA,EAASM,IAAI,SAAAW,GAAA,MAAMA,GAAGV,MA+GtC,IAAIyB,IAEA0F,OAAQ,SACRxH,OAAQ,SACRyH,SAAS,SACTV,MAAO,SAEPzC,IAAS,QACT2C,OAAQ,QACRS,MAAO,QACPC,MAAO,QAEPC,MAAO,SACPd,IAAS,SAETJ,MAAO,aACPC,OAAQ,aACRC,OAAQ,eFuCN,SAASxI,EAAQD,EAASM,GAE/B,YGxyBc,SAASoJ,GAAUC,GAE9BvJ,KAAKuJ,KAAOA,MA0DhB,QAASvC,GAAOpG,EAAK4G,GAGjB,IADA,GAAI5F,UACE4F,EAAK3C,QAEPjD,EAAM4F,EAAKgC,SACL,EAAAxH,EAAAyH,UAAS7I,EAAIgB,MAEfhB,EAAIgB,OAERhB,EAAMA,EAAIgB,EAEd,OAAOhB,GAGJ,QAAS6H,GAAI7H,EAAKmC,EAAMY,GAC/B,GACQ6D,IADRX,UAAAhC,OAAA,GAAAL,SAAAqC,UAAA,GAAAA,UAAA,MACe6C,OAAO3G,GAAM4G,MAAM,MAC1B/H,EAAO4F,EAAKoC,KAChBhJ,GAAMoG,EAAOpG,EAAK4G,GAClB5G,EAAIgB,GAAO+B,EAGf,QAASoC,GAAInF,EAAKmC,EAAMY,GAEpB,GAAI6D,GAAOkC,OAAO3G,GAAM4G,MAAM,KAC1B/H,EAAO4F,EAAKoC,KAChBhJ,GAAMoG,EAAOpG,EAAK4G,IACZ,EAAAxF,EAAAgD,SAAQpE,EAAIgB,MAEdhB,EAAIgB,OAERhB,EAAIgB,GAAKO,KAAKwB,GAGlB,QAASV,GAAOrC,EAAKmC,EAAMY,GAEvB,GAAI6D,GAAOkC,OAAO3G,GAAM4G,MAAM,KAC1B/H,EAAO4F,EAAKoC,KAChBhJ,GAAMoG,EAAOpG,EAAK4G,IACZ,EAAAxF,EAAAgD,SAAQpE,EAAIgB,MAEdhB,EAAIgB,MAER,IAAIiI,GAASjJ,EAAIgB,GACbkI,EAAQD,EAAO3H,QAAQyB,EACxBmG,QAECD,EAAO1H,KAAKwB,GAIZkG,EAAOC,GAASnG,EAIjB,QAASgE,GAAI/G,EAAKmC,GAErB,IAAG,EAAAf,EAAA+H,aAAYhH,IAAiB,IAARA,EAEpB,MAAOnC,EAKX,KAFA,GAAIgB,UACA4F,EAAOkC,OAAO3G,GAAM4G,MAAM,KACxBnC,EAAK3C,OAAS,GACpB,CAEI,GADAjD,EAAM4F,EAAKgC,SACL5I,EAAIqF,eAAerE,GAErB,MAEJhB,GAAMA,EAAIgB,GAGd,MADAA,GAAM4F,EAAKgC,QACJ5I,EAAIgB,GAGR,QAASgB,GAAIhC,EAAKmC,EAAMY,GAE3B,GAAIkG,GAASlC,EAAI/G,EAAKmC,EACtB,WAAW,EAAAf,EAAAgD,SAAQ6E,KAAW,EAAA7H,EAAAgI,WAAUrG,GAClCkG,EAAO3H,QAAQyB,SACf,EAAA3B,EAAA+H,aAAYpG,IACR,EAAA3B,EAAAgI,WAAUH,GACVA,IAAWlG,GAGlB,QAASzB,GAAStB,EAAKmC,EAAMY,GAEhC,GAAIO,GAAMyD,EAAI/G,EAAKmC,EACnB,QAAG,EAAAf,EAAAgD,SAAQd,GAEAA,EAAIhC,QAAQyB,MAKpB,QAAS+E,GAAO9H,EAAKmC,EAAMY,GAE9B,GAAIkG,GAASjJ,EACT4G,EAAOkC,OAAO3G,GAAQ,IAAI4G,MAAM,KAChC/H,EAAM4F,EAAKoC,KAMf,IAJGpC,EAAK3C,SAEJgF,EAASlC,EAAI/G,EAAK4G,EAAKxE,KAAK,QAE7B,EAAAhB,EAAAgI,WAAUrG,KAAU,EAAA3B,EAAAgD,SAAQ6E,EAAOjI,IACtC,CACIiI,EAASA,EAAOjI,EAChB,IAAIkI,GAAQD,EAAO3H,QAAQyB,EAC3B,OAAGmG,QAECD,EAAOI,OAAOH,EAAO,IACd,GAMX,UAAG,EAAA9H,EAAAyH,UAASI,KAAWjJ,EAAIqF,eAAerE,YAE/BiI,GAAOjI,IACP,GAMZ,QAASsI,GAAOtJ,EAAKmC,GAExB,GAAImH,MACA3H,EAASoF,EAAI/G,EAAKmC,EACtB,KAAG,EAAAf,EAAAyH,UAASlH,GAER,IAAI,GAAIoD,KAAQpD,GAETA,EAAO0D,eAAeN,IAErBuE,EAAO/H,KAAKI,EAAOoD,GAI/B,OAAOuE,GH8lBVzG,OAAOC,eAAe9D,EAAS,cAC3B+D,OAAO,IAEX/D,EAAQsK,OAAStK,EAAQ8I,OAAS9I,EAAQsC,QAAUtC,EAAQgD,IAAMhD,EAAQ+H,IAAM/H,EAAQ6I,IAAMjE,OAC9F5E,aG9yBuB0J,CAPxB,IAAAtH,GAAA9B,EAAA,EAYAoJ,GAAStF,WAELuF,KAAM,KAENd,IAAK,SAAU1F,EAAMY,GAGjB,MADA8E,GAAIzI,KAAKuJ,KAAMxG,EAAMY,GACd3D,MAGX+F,IAAI,SAAShD,EAAMY,GAGf,MADAoC,GAAI/F,KAAKuJ,KAAMxG,EAAMY,GACd3D,MAGXiD,OAAO,SAASF,EAAMY,GAGlB,MADAV,GAAOjD,KAAKuJ,KAAMxG,EAAMY,GACjB3D,MAGX2H,IAAI,SAAS5E,GAET,MAAO4E,GAAI3H,KAAKuJ,KAAMxG,IAG1BH,IAAK,SAAUG,GACf,GADqBY,GACrBkD,UAAAhC,OAAA,GAAAL,SAAAqC,UAAA,GAAAA,UAAA,GAD6BrC,MAEzB,OAAO5B,GAAI5C,KAAKuJ,KAAMxG,EAAMY,IAGhCzB,QAAS,SAAUa,EAAMY,GAErB,MAAOzB,GAAQlC,KAAKuJ,KAAMxG,EAAMY,IAGpC+E,OAAQ,SAAU3F,GAClB,GADwBY,GACxBkD,UAAAhC,OAAA,GAAAL,SAAAqC,UAAA,GAAAA,UAAA,GADgCrC,MAG5B,OADAkE,GAAO1I,KAAKuJ,KAAMxG,EAAMY,GACjB3D,MAGXwH,KAAK,SAASzE,GAEV,MAAOU,QAAO+D,KAAKG,EAAI3H,KAAKuJ,KAAMxG,KAGtCmH,OAAO,SAASnH,GAEZ,MAAOmH,GAAOlK,KAAKuJ,KAAMxG,KH00BhCnD,EAAQ6I,IAAM0B,EA6CdvK,EAAQ+H,IAAMyC,EAMdxK,EAAQgD,IAAMyH,EASdzK,EAAQsC,QAAUoI,EA0BlB1K,EAAQ8I,OAAS6B,EAajB3K,EAAQsK,OAASM,GAIZ,SAAS3K,EAAQD,GAEtB,YIj/BM,SAAS6J,GAAU9F,GAEtB,MAAiD,oBAA1CF,OAAOO,UAAUyG,SAASlK,KAAKoD,GAGnC,QAASqB,GAASrB,GAErB,MAAOA,aAAiBoB,OAGrB,QAAS9C,GAAU0B,GAEtB,MAAwB,gBAAVA,GAGX,QAASd,GAAWc,GAEvB,MAAOA,aAAiB+G,UAGrB,QAASV,GAAWrG,GAEvB,MAAwB,mBAAVA,GAGX,QAASoG,GAAapG,GAEzB,MAAwB,mBAAVA,GAGX,QAASgH,GAAMhH,GAElB,MAAO+F,QAAO/F,GAAS,IAAIiH,QAAQ,aAAc,IJm9BpDnH,OAAOC,eAAe9D,EAAS,cAC3B+D,OAAO,IAEX/D,EIt/Be6J,WJu/Bf7J,EIl/BeoF,UJm/BfpF,EI9+BeqC,WJ++BfrC,EI1+BeiD,aJ2+BfjD,EIt+BeoK,YJu+BfpK,EIl+BemK,cJm+BfnK,EI99Be+K,QJ6/BV,SAAS9K,EAAQD,EAASM,GAE/B,YAcA,SAASS,GAAuBC,GAAO,MAAOA,IAAOA,EAAIC,WAAaD,GAAQE,UAASF,GKz/BxF,QAASiK,GAAYpE,EAAQb,EAAME,EAAIvE,EAAUuJ,GAE7C9K,KAAKyG,OAAaA,EAClBzG,KAAK4F,KAAaA,EAClB5F,KAAK8F,GAAaA,EAClB9F,KAAKuB,SAAaA,EAClBvB,KAAK8K,UAAaA,ELu+BrBrH,OAAOC,eAAe9D,EAAS,cAC3B+D,OAAO,GAGX,IAAIL,GAAiB,WAAc,QAASW,GAAcC,EAAKC,GAAK,GAAIC,MAAeC,GAAK,EAAUC,GAAK,EAAWC,EAAKC,MAAW,KAAM,IAAK,GAAiCC,GAA7BC,EAAKR,EAAIL,OAAOC,cAAmBO,GAAMI,EAAKC,EAAGC,QAAQC,QAAoBR,EAAKjC,KAAKsC,EAAGd,QAAYQ,GAAKC,EAAKS,SAAWV,GAA3DE,GAAK,IAAoE,MAAOS,GAAOR,GAAK,EAAMC,EAAKO,EAAO,QAAU,KAAWT,GAAMK,EAAG,WAAWA,EAAG,YAAe,QAAU,GAAIJ,EAAI,KAAMC,IAAQ,MAAOH,GAAQ,MAAO,UAAUF,EAAKC,GAAK,GAAIY,MAAMC,QAAQd,GAAQ,MAAOA,EAAY,IAAIL,OAAOC,WAAYL,QAAOS,GAAQ,MAAOD,GAAcC,EAAKC,EAAa,MAAM,IAAIc,WAAU,4DKniCvlBI,EAAAnF,EAAA,GLuiCK6K,EAAWpK,EAAuB0E,GKtiCvCrD,EAAA9B,EAAA,EA0DA2K,GAAW7G,WAEPyC,OAAc,GACdb,KAAc,GACdE,GAAc,GACdvE,SAAc,KACduJ,UAAc,KACd7C,QAAc,EAEdK,MAAO,WAEHtI,KAAKiI,QAAS,EACdjI,KAAKuB,aAOZ0F,KAAM,WAEF,IAAMjH,KAAKiI,OAEJ,GAAGjI,KAAKuB,SAASsD,OACjB,CACI,GAAImG,GAAUhL,KAAKuB,SAASiI,QACxBtI,EAAQ8J,GACZ,IAAG9J,KAAU,EAET,MAAOlB,MAAK8K,UAAUzC,QAE1B,IAAGnH,KAAU,EAET,MAAOlB,MAAK8K,UAAU3C,OAE1BnI,MAAKiH,WAILjH,MAAK8K,UAAUvC,KAGvB,OAAOvI,OAGXmI,MAAO,WAGH,MADAnI,MAAKiI,QAAS,EACPjI,MAGXoI,OAAQ,WAGJ,MADApI,MAAKiI,QAAS,EACPjI,KAAKiH,SLkiCnBrH,cK7gCGoH,OAAO,SAAUrF,EAAK8E,EAAQwE,GAG1B,GAAIC,MACAlK,EAAUW,EAAIX,MACd4E,EAAUjE,EAAIT,MACd4E,EAAUnE,EAAIL,QAAQqG,IAAIlB,GAAQb,GAClCkF,GAEAzC,OAAU1G,EAAI0G,OAAO8C,KAAKxJ,GAC1BwG,MAAUxG,EAAIwG,MAAMgD,KAAKxJ,GACzByG,OAAUzG,EAAIyG,OAAO+C,KAAKxJ,GAC1B4G,IAAU5G,EAAI4G,IAAI4C,KAAKxJ,GAI3B,KAAG,EAAAK,EAAAa,YAAWiD,GACd,CACI,GAAIxE,GAAUK,EAAI4F,gBACdrG,EAAU4E,EAAGsF,MAAMpK,GAAQM,GAAS+J,OAAOJ,IAC3CxE,EAAU9E,EAAI4F,cAAcrG,EAEhC,KAAMuF,EAEF,KAAM,IAAI3D,OAAM,uBAAwB5B,EAAO,yBAA0B0E,EAAM,KAoDvF,MA/CAjE,GAAIV,OAAOmF,MAAMvE,IAAK,SAAAyJ,GACtB,GAAAC,GAE8BD,EAAM3B,MAAM,KAF1C6B,EAAAlI,EAAAiI,EAAA,GAESjJ,EAFTkJ,EAAA,GAEeC,EAFfD,EAAA,GAGQnJ,EAAsB,gBAAgBqJ,KAAKpJ,GACjB,SACA,QAC1BC,QAGAA,GAFU,MAAXkJ,EAEU,IAEQ,UAAbpJ,EAEKoE,EAIS,UAATnE,EACHsD,EACAE,CAIV,IAAI/C,IAAQV,EAAWE,EAAQD,GAAMU,KAAK,KAEtCzB,EAAWI,EAAIJ,SAASoG,IAAI5E,EAC7BxB,KAICA,EAAWA,EAASM,IAAK,SAAAmJ,GAErB,MAAO,YAEH,GAAIlJ,GAAQiJ,aAAO/D,OAAO3E,EAAWC,EAAMC,EAAQqD,EAAME,EAAIgF,EAC7DE,GAAQI,MAAMpK,GAAQc,GAAOuJ,OAAOJ,OAK5CC,EAAQA,EAAMG,OAAO9J,MAMtB,GAAIsJ,GAAWpE,EAAQb,EAAME,EAAIoF,EAAOJ,MLuhCjD,SAASjL,EAAQD,GAEtB,YMxuCG,SAAS+L,MAyBT,QAASnK,GAAYM,EAAOO,EAAWC,EAAMC,EAAQqD,EAAME,EAAIgF,GAE3DhJ,EAAMO,UAAYA,EAClBP,EAAMQ,KAAYA,EAClBR,EAAMS,OAAYA,EAClBT,EAAM8D,KAAYA,EAClB9D,EAAMgE,GAAYA,EAElBhE,EAAMqG,MAAY2C,EAAU3C,MAC5BrG,EAAMsG,OAAY0C,EAAU1C,OAC5BtG,EAAMuG,OAAYyC,EAAUzC,OAC5BvG,EAAMoH,SAAY4B,EAAU5B,SAkBzB,QAAS0C,GAAatJ,EAAMC,EAAQqD,EAAME,EAAIgF,GAEjDtJ,EAAWxB,KAAM,SAAUsC,EAAMC,EAAQqD,EAAME,EAAIgF,GAQhD,QAASe,GAAYvJ,EAAMC,EAAQqD,EAAME,EAAIgF,GAEhDtJ,EAAWxB,KAAM,QAASsC,EAAMC,EAAQqD,EAAME,EAAIgF,GAQ/C,QAASzE,GAAa/D,GAEzBtC,KAAKsC,KAAOA,EAaT,QAASgE,GAAiBhE,GAE7BtC,KAAKsC,KAAOA,EN+oCnBmB,OAAOC,eAAe9D,EAAS,cAC3B+D,OAAO,IAEX/D,EMvrCmBgM,cNwrCnBhM,EM9qCmBiM,aN+qCnBjM,EMrqCmByG,cNsqCnBzG,EMvpCmB0G,iBAhFhB,IAAIxE,IAGAO,UAAc,KACdC,KAAc,KACdC,OAAc,KACdqD,KAAc,KACdE,GAAc,KAGdqC,MAAcwD,EACdvD,OAAcuD,EACdtD,OAAcsD,EACdzC,SAAcyC,ENmwCrB/L,eMhvCOoH,OAAQ,SAAS3E,EAAWC,EAAMC,EAAQqD,EAAME,EAAIgF,GAEhD,GAAItI,GAAkB,SAAbH,EACHwJ,EACAD,CACN,OAAO,IAAIpJ,GAAGF,EAAMC,EAAQqD,EAAME,EAAIgF,KAY9Cc,EAAY5H,UAAYlC,EAUxB+J,EAAW7H,UAAYlC,EAWvBuE,EAAYrC,WAER3B,UAAW,SACXC,KAAM,IAYVgE,EAAgBtC,WAEZ3B,UAAW,aACXC,KAAM","file":"state-machine.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StateMachine\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"StateMachine\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.default = StateMachine;\n\t\n\tvar _ValueMap = __webpack_require__(1);\n\t\n\tvar _ValueMap2 = _interopRequireDefault(_ValueMap);\n\t\n\tvar _Transition = __webpack_require__(3);\n\t\n\tvar _Transition2 = _interopRequireDefault(_Transition);\n\t\n\tvar _Events = __webpack_require__(4);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction StateMachine(scope, config) {\n\t    this.scope = scope;\n\t    this.state = '';\n\t    this.states = [];\n\t    this.transitions = new _ValueMap2.default();\n\t    this.actions = new _ValueMap2.default();\n\t    this.handlers = new _ValueMap2.default();\n\t    if (config) {\n\t        this.initialize(config);\n\t        this.update('system', 'initialize');\n\t    }\n\t}\n\t\n\t/**\n\t * StateMachine prototype\n\t *\n\t * The property examples below illustrate a 4-state machine, with states:\n\t *\n\t * - intro > settings > summary > end\n\t *\n\t * And actions:\n\t *\n\t * - back | next | restart | finish\n\t */\n\tStateMachine.prototype = {\n\t    // ------------------------------------------------------------------------------------------------\n\t    // properties\n\t\n\t    /**\n\t     * Available state names\n\t     *\n\t     * - [\n\t     *     intro,\n\t     *     settings,\n\t     *     summary,\n\t     *     final\n\t     *   ]\n\t     *\n\t     * @var {string[]}\n\t     */\n\t    states: null,\n\t\n\t    /**\n\t     * Available transitions for each action\n\t     *\n\t     * action.from => to\n\t     *\n\t     * - next: {\n\t     *     intro: settings,\n\t     *     settings: summary\n\t     *   },\n\t     * - back: {\n\t     *     settings: intro\n\t     *   },\n\t     * - restart: {\n\t     *     summary:intro\n\t     *   },\n\t     * - finish: {\n\t     *     summary:final\n\t     *   },\n\t     *\n\t     * Transitions can also be functions\n\t     *\n\t     * - next: {\n\t     *     intro: function() { return '<random state>' } // jump to a random state\n\t     *   }\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    transitions: null,\n\t\n\t    /**\n\t     * Actions that are available to be called from each state\n\t     *\n\t     * state => [ action, action, ... ]\n\t     *\n\t     * - intro: [\n\t     *     'next'\n\t     *   ],\n\t     * - settings: [\n\t     *     'next',\n\t     *     'back'\n\t     *   ],\n\t     * - summary: [\n\t     *     'restart'\n\t     *     'finish',\n\t     *   ]\n\t     *\n\t     * Actions can also be expressed as wildcards\n\t     *\n\t     * - intro: [\n\t     *     '*' // any action is allowed from intro\n\t     *   ]\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    actions: null,\n\t\n\t    /**\n\t     * Handler functions that should be called on each action event / state change\n\t     *\n\t     * name.type => [ handler, handler, ... ]\n\t     *\n\t     * - next: {\n\t     *   - start: [\n\t     *       hideModal\n\t     *     ],\n\t     *   - end: [\n\t     *       showModal\n\t     *     ]\n\t     *   },\n\t     * - summary: {\n\t     *   - enter: [\n\t     *       resetForm\n\t     *     ],\n\t     *   - leave: [\n\t     *       validateForm,\n\t     *       postData,\n\t     *     ]\n\t     *   },\n\t     *   ...\n\t     *\n\t     * @var {ValueMap}\n\t     */\n\t    handlers: null,\n\t\n\t    /**\n\t     * The current state\n\t     *\n\t     * @var {string}\n\t     */\n\t    state: '',\n\t\n\t    /**\n\t     * Any active Transition object that is driving the state change\n\t     *\n\t     * @var {Transition}\n\t     */\n\t    transition: null,\n\t\n\t    /**\n\t     * The scope in which to call all handlers\n\t     *\n\t     * @var {*}\n\t     */\n\t    scope: null,\n\t\n\t    /**\n\t     * The original config object\n\t     *\n\t     * @var {Object}\n\t     */\n\t    config: null,\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // private methods\n\t\n\t    /**\n\t     * Initialize the FSM with a config object\n\t     *\n\t     * @private\n\t     * @param config\n\t     */\n\t    initialize: function initialize(config) {\n\t        var _this = this;\n\t\n\t        // assign config\n\t        this.config = config;\n\t\n\t        // pre-collate all states\n\t        addStates(this, 'from', config.events);\n\t        addStates(this, 'to', config.events);\n\t\n\t        // initial state\n\t        if (!config.initial) {\n\t            config.initial = this.states[0];\n\t        }\n\t\n\t        // add transitions\n\t        config.events.map(function (event) {\n\t            // shorthand\n\t            if ((0, _utils.isString)(event)) {\n\t                var matches = event.match(/(\\w+)\\s*[\\|:=]\\s*(\\w+)\\s*([<>-])\\s*(\\w.*)/);\n\t\n\t                var _matches = _slicedToArray(matches, 5);\n\t\n\t                var name = _matches[1];\n\t                var from = _matches[2];\n\t                var op = _matches[3];\n\t                var to = _matches[4];\n\t\n\t                if (op === '-') {\n\t                    _this.add(name, from, to);\n\t                    _this.add(name, to, from);\n\t                    return;\n\t                }\n\t                if (op === '<') {\n\t                    var _ref = [to, from];\n\t                    from = _ref[0];\n\t                    to = _ref[1];\n\t                }\n\t                _this.add(name, from, to);\n\t            }\n\t\n\t            // keys\n\t            else {\n\t                    _this.add(event.name, event.from, event.to);\n\t                }\n\t        });\n\t\n\t        // add handlers\n\t        for (var name in config.handlers) {\n\t            if (config.handlers.hasOwnProperty(name)) {\n\t                this.on(name, config.handlers[name]);\n\t            }\n\t        }\n\t\n\t        // state\n\t        if (!config.defer) {\n\t            this.state = config.initial;\n\t        }\n\t\n\t        /**\n\t         * Sets the default order to run transition callbacks in\n\t         *\n\t         * start/leave/enter/end  -> event types\n\t         * to/action              -> targeted handlers (leave:red)\n\t         * *                      -> global handlers   (leave, or leave:*)\n\t         *\n\t         * @type {string[]} type.target\n\t         */\n\t        config.order = config.order || ['start:*', 'start:action', 'leave:from', 'leave:*', 'enter:*', 'enter:to', 'end:action', 'end:*'];\n\t    },\n\t\n\t    /**\n\t     * Dispatch an event\n\t     *\n\t     * @param namespace\n\t     * @param type\n\t     */\n\t    update: function update(namespace, type) {\n\t        var event = namespace === 'system' ? _Events.SystemEvent : _Events.TransitionEvent;\n\t        this.dispatch(namespace + '.' + type, new event(type));\n\t        return this;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // api\n\t\n\t    /**\n\t     * Attempt to run an action, resulting in a transition to a state\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {*[]}       rest\n\t     * @returns {boolean}\n\t     */\n\t    do: function _do(action) {\n\t        if (this.can(action)) {\n\t            this.config.debug && console.info('Doing action \"%s\"', action);\n\t\n\t            for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                rest[_key - 1] = arguments[_key];\n\t            }\n\t\n\t            this.transition = _Transition2.default.create(this, action, rest);\n\t            this.update('transition', 'start');\n\t            this.update('system', 'update');\n\t            this.transition.exec();\n\t            return true;\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Attempt to go to a state\n\t     *\n\t     * Finds if an appropriate transition exists, then calls the related action if it does\n\t     *\n\t     * @param   {string}    state\n\t     * @returns {boolean}\n\t     */\n\t    go: function go(state) {\n\t        if (this.has(state)) {\n\t            var action = this.getActionForState(state);\n\t            if (action) {\n\t                return this.do(action);\n\t            }\n\t            this.config.debug && console.info('No transition exists from \"%s\" to \"%s\"', this.state, state);\n\t        } else {\n\t            this.config.debug && console.warn('No such state \"%s\"', state);\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Query a transition to see if a named action is available\n\t     *\n\t     * @param   {string}    action\n\t     * @returns {boolean}\n\t     */\n\t    can: function can(action) {\n\t        if (!this.actions.has(action)) {\n\t            this.config.debug && console.warn('No such action \"%s\"', action);\n\t        }\n\t        return !!this.transitions.has(this.state, action);\n\t    },\n\t\n\t    /**\n\t     * Query a transition to see if a named action is unavailable\n\t     *\n\t     * @param   {string}    action\n\t     * @returns {boolean}\n\t     */\n\t    cannot: function cannot(action) {\n\t        return !this.can(action);\n\t    },\n\t\n\t    /**\n\t     * Test if the current state is the same as the supplied one\n\t     *\n\t     * @param   {string}    state       A state name to compare against the current state\n\t     * @returns {boolean}\n\t     */\n\t    is: function is(state) {\n\t        if (this.states.indexOf(state) === -1) {\n\t            this.config.debug && console.warn('No such state \"%s\"', state);\n\t        }\n\t        return state === this.state;\n\t    },\n\t\n\t    /**\n\t     * Test if a state exists\n\t     *\n\t     * @param   {string}    state\n\t     * @return  {boolean}\n\t     */\n\t    has: function has(state) {\n\t        return this.states.indexOf(state) !== -1;\n\t    },\n\t\n\t    /**\n\t     * Get the available \"to\" states for the current or supplied state\n\t     *\n\t     * @param   {string}    [state]     Optional name of a state to get states for. Defaults to the current state\n\t     * @returns {string[]}              An array of string states\n\t     */\n\t    getStatesFor: function getStatesFor() {\n\t        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t\n\t        state = state || this.state;\n\t        var actions = this.getActionsFor(state, true);\n\t        return Object.keys(actions).map(function (name) {\n\t            return actions[name];\n\t        });\n\t    },\n\t\n\t    /**\n\t     * Get the available actions (or actions and states) for the current or supplied state\n\t     *\n\t     * @param   {string}    [state]     Optional name of a state to get actions for. Defaults to the current state\n\t     * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n\t     * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n\t     */\n\t    getActionsFor: function getActionsFor() {\n\t        var _this2 = this;\n\t\n\t        var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n\t        var asMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        state = state || this.state;\n\t        var actions = this.transitions.get(state || this.state);\n\t        if (asMap) {\n\t            var _ret = function () {\n\t                var states = {};\n\t                actions.map(function (action) {\n\t                    states[action] = _this2.actions.get(action + '.' + state);\n\t                });\n\t                return {\n\t                    v: states\n\t                };\n\t            }();\n\t\n\t            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t        } else {\n\t            return actions;\n\t        }\n\t    },\n\t\n\t    getActionForState: function getActionForState(state) {\n\t        if (this.has(state)) {\n\t            var actions = this.getActionsFor(null, true);\n\t            for (var action in actions) {\n\t                if (actions[action] === state) {\n\t                    return action;\n\t                }\n\t            }\n\t        }\n\t        return null;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // flags\n\t\n\t    /**\n\t     * Test if the FSM has started\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isStarted: function isStarted() {\n\t        return this.state !== '';\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is transitioning\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isTransitioning: function isTransitioning() {\n\t        return !!this.transition;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is paused (whilst transitioning)\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isPaused: function isPaused() {\n\t        return this.transition ? this.transition.paused : false;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is on the \"final\" state\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isComplete: function isComplete() {\n\t        return this.state === this.config.final;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // transitions\n\t\n\t    /**\n\t     * Pause any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    pause: function pause() {\n\t        if (this.transition) {\n\t            this.transition.pause();\n\t            this.update('transition', 'pause');\n\t            this.update('system', 'update');\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Resume any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    resume: function resume() {\n\t        if (this.transition) {\n\t            this.update('transition', 'resume');\n\t            this.update('system', 'update');\n\t            this.transition.resume();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Cancel any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    cancel: function cancel() {\n\t        if (this.transition) {\n\t            this.state = this.transition.from;\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('transition', 'cancel');\n\t            this.update('system', 'update');\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * End any current transition, skipping remaining handlers\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    end: function end() {\n\t        if (this.transition) {\n\t            this.state = this.transition.to;\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.update('system', 'change');\n\t            this.update('system', 'update');\n\t            if (this.isComplete()) {\n\t                this.update('system', 'complete');\n\t            }\n\t            this.update('transition', 'end');\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Reset the FSM to the initial, or supplied, state\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    reset: function reset(initial) {\n\t        this.state = initial || this.config.initial;\n\t        if (this.transition) {\n\t            this.transition.clear();\n\t            delete this.transition;\n\t        }\n\t        this.update('system', 'reset');\n\t        return this;\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // actions\n\t\n\t    /**\n\t     * Add a transition event\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @return  {StateMachine}\n\t     */\n\t    add: function add(action, from, to) {\n\t        this.actions.set(action + '.' + from, to);\n\t        this.transitions.add(from, action);\n\t        return this;\n\t    },\n\t\n\t    remove: function remove(action, from, to) {\n\t        this.states.remove(action, from);\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // handlers\n\t\n\t    /**\n\t     * Add an event handler\n\t     *\n\t     * Event handler signature:\n\t     *\n\t     * - namespace.type:target1 target2 target3 ...\n\t     *\n\t     * Valid event signatures:\n\t     *\n\t     * - system:(change|update|complete|reset)\n\t     * - action:(start|end)\n\t     * - state:(add|remove|leave|enter)\n\t     * - transition:(pause|resume|cancel)\n\t     *\n\t     * As event types are unique, they can be used without the namespace:\n\t     *\n\t     * - change\n\t     * - pause\n\t     * - start\n\t     * - end\n\t     * - leave:red\n\t     * - enter:blue green\n\t     * - start:next\n\t     * - end:back\n\t     *\n\t     * You can also just pass action or names to target individual state.leave / action.end events:\n\t     *\n\t     * - next\n\t     * - intro\n\t     *\n\t     * @param id\n\t     * @param fn\n\t     * @return {StateMachine}\n\t     */\n\t    on: function on(id, fn) {\n\t        var _this3 = this;\n\t\n\t        var _parseHandler = parseHandler(this, id);\n\t\n\t        var _parseHandler2 = _slicedToArray(_parseHandler, 3);\n\t\n\t        var namespace = _parseHandler2[0];\n\t        var type = _parseHandler2[1];\n\t        var targets = _parseHandler2[2];\n\t\n\t        targets.map(function (target) {\n\t            return addHandler(_this3, namespace, type, target, fn);\n\t        });\n\t        return this;\n\t    },\n\t\n\t    off: function off(id, fn) {\n\t        var _parseHandler3 = parseHandler(this, id);\n\t\n\t        var _parseHandler4 = _slicedToArray(_parseHandler3, 3);\n\t\n\t        var namespace = _parseHandler4[0];\n\t        var type = _parseHandler4[1];\n\t        var targets = _parseHandler4[2];\n\t\n\t        this.handlers.remove(path, fn);\n\t    },\n\t\n\t    dispatch: function dispatch(path, event) {\n\t        this.config.debug && console.info('StateMachine update \"%s\"', path);\n\t        var handlers = this.handlers.get(path);\n\t        if (handlers) {\n\t            // do we need to pass additional arguments?\n\t            handlers.map(function (fn) {\n\t                return fn(event);\n\t            });\n\t        }\n\t    }\n\t\n\t};\n\t\n\t/**\n\t * Parses config and adds unique state names to states array\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          key\n\t * @param {Object[]}        transitions\n\t */\n\tfunction addStates(fsm, key, transitions) {\n\t    transitions.map(function (event) {\n\t        return addState(fsm, event[key]);\n\t    });\n\t}\n\t\n\tfunction addState(fsm, state) {\n\t    if ((0, _utils.isString)(state) && fsm.states.indexOf(state) === -1) {\n\t        fsm.states.push(state);\n\t    }\n\t}\n\t\n\t/**\n\t * Generic function to parse action and add callback\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          namespace\n\t * @param {string}          type\n\t * @param {string}          target\n\t * @param {Function}        fn\n\t */\n\tfunction addHandler(fsm, namespace, type, target, fn) {\n\t    // warn for invalid actions / states\n\t    if (target !== '*') {\n\t        if (namespace === 'state' && fsm.states.indexOf(target) === -1) {\n\t            fsm.config.debug && console.warn('Warning assigning state.%s handler: no such state \"%s\"', type, target);\n\t        } else if (namespace === 'action' && !fsm.actions.has(target)) {\n\t            fsm.config.debug && console.warn('Warning assigning action.%s handler: no such action \"%s\"', type, target);\n\t        }\n\t    }\n\t\n\t    // check handler is a function\n\t    if (!(0, _utils.isFunction)(fn)) {\n\t        throw new Error('Error assigning ' + namespace + '.' + type + ' handler; callback is not a Function', fn);\n\t    }\n\t\n\t    // assign\n\t    var path = namespace === 'action' || namespace === 'state' ? [namespace, target, type].join('.') : namespace + '.' + type;\n\t    fsm.handlers.insert(path, fn);\n\t}\n\t\n\tfunction parseHandler(fsm, id) {\n\t    // get initial matches\n\t    var matches = id.match(/^(?:(\\w+)\\.)?(\\w+[-.\\w]*)(?::(.*))?/);\n\t    if (!matches) {\n\t        throw new Error('Warning parsing event handler: invalid signature \"%s\"', id);\n\t    }\n\t\n\t    var _matches2 = _slicedToArray(matches, 4);\n\t\n\t    var namespace = _matches2[1];\n\t    var type = _matches2[2];\n\t    var target = _matches2[3];\n\t\n\t    // determine event if not found\n\t\n\t    if (!namespace) {\n\t        // check if shorthand global was passed\n\t        namespace = eventNamespaces[type];\n\t\n\t        // if event is still null, attempt to determine type from existing states or actions\n\t        if (!namespace) {\n\t            if (fsm.states.indexOf(type) !== -1) {\n\t                target = type;\n\t                namespace = 'state';\n\t                type = 'enter';\n\t            } else if (fsm.actions.has(type)) {\n\t                target = type;\n\t                namespace = 'action';\n\t                type = 'start';\n\t            } else {\n\t                fsm.config.debug && console.warn('Warning parsing event handler: unable to map \"%s\" to a valid event or existing entity', id);\n\t            }\n\t        }\n\t    }\n\t\n\t    // assign\n\t    var targets = target ? target.match(/[*\\w]+/g) : ['*'];\n\t\n\t    return [namespace, type, targets];\n\t}\n\t\n\tvar eventNamespaces = {\n\t    change: 'system',\n\t    update: 'system',\n\t    complete: 'system',\n\t    reset: 'system',\n\t\n\t    add: 'state',\n\t    remove: 'state',\n\t    leave: 'state',\n\t    enter: 'state',\n\t\n\t    start: 'action',\n\t    end: 'action',\n\t\n\t    pause: 'transition',\n\t    resume: 'transition',\n\t    cancel: 'transition'\n\t};\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.values = exports.remove = exports.indexOf = exports.has = exports.get = exports.set = undefined;\n\texports.default = ValueMap;\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\t/**\n\t * Utility class to create, modify and delete nested hashes and values\n\t *\n\t * @constructor\n\t */\n\tfunction ValueMap(data) {\n\t    this.data = data || {};\n\t}\n\t\n\tValueMap.prototype = {\n\t    data: null,\n\t\n\t    set: function set(path, value) {\n\t        _set(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    add: function add(path, value) {\n\t        _add(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    insert: function insert(path, value) {\n\t        _insert(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    get: function get(path) {\n\t        return _get(this.data, path);\n\t    },\n\t\n\t    has: function has(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        return _has(this.data, path, value);\n\t    },\n\t\n\t    indexOf: function indexOf(path, value) {\n\t        return _indexOf(this.data, path, value);\n\t    },\n\t\n\t    remove: function remove(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        _remove(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    keys: function keys(path) {\n\t        return Object.keys(_get(this.data, path));\n\t    },\n\t\n\t    values: function values(path) {\n\t        return _values(this.data, path);\n\t    }\n\t\n\t};\n\t\n\tfunction create(obj, keys) {\n\t    var key = void 0;\n\t    while (keys.length) {\n\t        key = keys.shift();\n\t        if (!(0, _utils.isObject)(obj[key])) {\n\t            obj[key] = {};\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    return obj;\n\t}\n\t\n\tfunction _set(obj, path, value) {\n\t    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n\t\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    obj[key] = value;\n\t}\n\t\n\texports.set = _set;\n\tfunction _add(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    obj[key].push(value);\n\t}\n\t\n\tfunction _insert(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    var parent = obj[key],\n\t        index = parent.indexOf(value);\n\t    if (index === -1) {\n\t        parent.push(value);\n\t    } else {\n\t        parent[index] = value;\n\t    }\n\t}\n\t\n\tfunction _get(obj, path) {\n\t    if ((0, _utils.isUndefined)(path) || path == '') {\n\t        return obj;\n\t    }\n\t\n\t    var key = void 0,\n\t        keys = String(path).split('.');\n\t    while (keys.length > 1) {\n\t        key = keys.shift();\n\t        if (!obj.hasOwnProperty(key)) {\n\t            return;\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    key = keys.shift();\n\t    return obj[key];\n\t}\n\t\n\texports.get = _get;\n\tfunction _has(obj, path, value) {\n\t    var parent = _get(obj, path);\n\t    return !!((0, _utils.isArray)(parent) && (0, _utils.isDefined)(value) ? parent.indexOf(value) !== -1 : (0, _utils.isUndefined)(value) ? (0, _utils.isDefined)(parent) : parent === value);\n\t}\n\t\n\texports.has = _has;\n\tfunction _indexOf(obj, path, value) {\n\t    var arr = _get(obj, path);\n\t    if ((0, _utils.isArray)(arr)) {\n\t        return arr.indexOf(value);\n\t    }\n\t    return -1;\n\t}\n\t\n\texports.indexOf = _indexOf;\n\tfunction _remove(obj, path, value) {\n\t    var parent = obj,\n\t        keys = String(path || '').split('.'),\n\t        key = keys.pop();\n\t\n\t    if (keys.length) {\n\t        parent = _get(obj, keys.join('.'));\n\t    }\n\t    if ((0, _utils.isDefined)(value) && (0, _utils.isArray)(parent[key])) {\n\t        parent = parent[key];\n\t        var index = parent.indexOf(value);\n\t        if (index > -1) {\n\t            parent.splice(index, 1);\n\t            return true;\n\t        }\n\t        return false;\n\t    } else {\n\t        if ((0, _utils.isObject)(parent) && obj.hasOwnProperty(key)) {\n\t            delete parent[key];\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\t\n\texports.remove = _remove;\n\tfunction _values(obj, path) {\n\t    var values = [];\n\t    var target = _get(obj, path);\n\t    if ((0, _utils.isObject)(target)) {\n\t        for (var name in target) {\n\t            if (target.hasOwnProperty(name)) {\n\t                values.push(target[name]);\n\t            }\n\t        }\n\t    }\n\t    return values;\n\t}\n\texports.values = _values;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.isObject = isObject;\n\texports.isArray = isArray;\n\texports.isString = isString;\n\texports.isFunction = isFunction;\n\texports.isDefined = isDefined;\n\texports.isUndefined = isUndefined;\n\texports.trim = trim;\n\tfunction isObject(value) {\n\t    return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\t\n\tfunction isArray(value) {\n\t    return value instanceof Array;\n\t}\n\t\n\tfunction isString(value) {\n\t    return typeof value === 'string';\n\t}\n\t\n\tfunction isFunction(value) {\n\t    return value instanceof Function;\n\t}\n\t\n\tfunction isDefined(value) {\n\t    return typeof value !== 'undefined';\n\t}\n\t\n\tfunction isUndefined(value) {\n\t    return typeof value === 'undefined';\n\t}\n\t\n\tfunction trim(value) {\n\t    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n\t}\n\n/***/ },\n/* 3 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _Events = __webpack_require__(4);\n\t\n\tvar _Events2 = _interopRequireDefault(_Events);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Transition class\n\t *\n\t * Responsible for managing events in the flow from state to state.\n\t *\n\t * This adds all handlers for the current action start/end and state from/to to an array:\n\t *\n\t * - <namespace>.<target>.<type>[]\n\t *\n\t * So going from state \"a\" to state \"b\" with action \"next\" should build:\n\t *\n\t * - action.*.start[]\n\t * - action.next.start[]\n\t * - state.a.leave[]\n\t * - state.*.leave[]\n\t * - state.*.enter[]\n\t * - state.b.enter[]\n\t * - action.next.end[]\n\t * - action.*.end[]\n\t *\n\t * This can be changed by passing in an order array in fsm.config\n\t *\n\t * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n\t *\n\t * From a callback, you can:\n\t *\n\t * - return false to cancel the transition\n\t * - return true to pause the transition\n\t * - not return a value (the transition continues)\n\t *\n\t * Transitions can also be paused, resumed, or cancelled by calling\n\t * the appropriate method on, or from:\n\t *\n\t * - the event\n\t * - the transition\n\t * - the state machine\n\t *\n\t * Cancelled transitions will reset the FSM to the previous \"from\" state\n\t *\n\t * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n\t *\n\t * @param {string}          action\n\t * @param {string}          from\n\t * @param {string}          to\n\t * @param {Function[]}      handlers\n\t * @param {Object}          callbacks\n\t */\n\tfunction Transition(action, from, to, handlers, callbacks) {\n\t    this.action = action;\n\t    this.from = from;\n\t    this.to = to;\n\t    this.handlers = handlers;\n\t    this.callbacks = callbacks;\n\t}\n\t\n\tTransition.prototype = {\n\t    action: '',\n\t    from: '',\n\t    to: '',\n\t    handlers: null,\n\t    callbacks: null,\n\t    paused: false,\n\t\n\t    clear: function clear() {\n\t        this.paused = false;\n\t        this.handlers = [];\n\t    },\n\t\n\t    /**\n\t     * Execute the next event's callbacks\n\t     * @returns {*}\n\t     */\n\t    exec: function exec() {\n\t        if (!this.paused) {\n\t            if (this.handlers.length) {\n\t                var handler = this.handlers.shift();\n\t                var state = handler();\n\t                if (state === false) {\n\t                    return this.callbacks.cancel();\n\t                }\n\t                if (state === true) {\n\t                    return this.callbacks.pause();\n\t                }\n\t                this.exec();\n\t            } else {\n\t                this.callbacks.end();\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t\n\t    pause: function pause() {\n\t        this.paused = true;\n\t        return this;\n\t    },\n\t\n\t    resume: function resume() {\n\t        this.paused = false;\n\t        return this.exec();\n\t    }\n\t};\n\t\n\texports.default = {\n\t    /**\n\t     * Create the Transition object\n\t     *\n\t     * - Set up variables, callbacks and queue\n\t     * - Determine paths to relevant callbacks\n\t     * - Build State and Action Event objects\n\t     * - Pre-bind all handlers\n\t     * - Append to queue\n\t     *\n\t     * @param {StateMachine}    fsm\n\t     * @param {string}          action\n\t     * @param {Array}           params\n\t     * @returns {Transition}\n\t     */\n\t    create: function create(fsm, action, params) {\n\t        // transition\n\t        var queue = [];\n\t        var scope = fsm.scope;\n\t        var from = fsm.state;\n\t        var to = fsm.actions.get(action)[from];\n\t        var callbacks = {\n\t            cancel: fsm.cancel.bind(fsm),\n\t            pause: fsm.pause.bind(fsm),\n\t            resume: fsm.resume.bind(fsm),\n\t            end: fsm.end.bind(fsm)\n\t        };\n\t\n\t        // handle \"to\" being a function\n\t        if ((0, _utils.isFunction)(to)) {\n\t            var actions = fsm.getActionsFor();\n\t            var state = to.apply(scope, [actions].concat(params));\n\t            var _action = fsm.getActionsFor(state);\n\t            // TODO debug this! It's wrong\n\t            if (!_action) {\n\t                throw new Error('Cannot go to state \"' + state + '\" from current state \"' + from + '\"');\n\t            }\n\t        }\n\t\n\t        // build handlers array\n\t        fsm.config.order.map(function (token) {\n\t            // determine path variables\n\t            var _token$split = token.split(':');\n\t\n\t            var _token$split2 = _slicedToArray(_token$split, 2);\n\t\n\t            var type = _token$split2[0];\n\t            var source = _token$split2[1]; // i.e. start.*, enter:to, end:action\n\t\n\t            var namespace = /^(start|end)$/.test(type) ? 'action' : 'state';\n\t            var target = void 0;\n\t            if (source === '*') {\n\t                target = '*';\n\t            } else if (namespace == 'action') {\n\t                target = action;\n\t            } else {\n\t                target = type === 'leave' ? from : to;\n\t            }\n\t\n\t            // get handlers\n\t            var path = [namespace, target, type].join('.');\n\t\n\t            var handlers = fsm.handlers.get(path);\n\t            if (handlers) {\n\t                // pre-bind handlers, scopes and params\n\t                // this way scope and params don't need to be passed around\n\t                handlers = handlers.map(function (handler) {\n\t                    return function () {\n\t                        var event = _Events2.default.create(namespace, type, target, from, to, callbacks);\n\t                        handler.apply(scope, [event].concat(params));\n\t                    };\n\t                });\n\t\n\t                // add to queue\n\t                queue = queue.concat(handlers);\n\t            }\n\t        });\n\t\n\t        // create\n\t        return new Transition(action, from, to, queue, callbacks);\n\t    }\n\t\n\t};\n\n/***/ },\n/* 4 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ActionEvent = ActionEvent;\n\texports.StateEvent = StateEvent;\n\texports.SystemEvent = SystemEvent;\n\texports.TransitionEvent = TransitionEvent;\n\t// ------------------------------------------------------------------------------------------------\n\t// setup\n\t\n\tfunction noop() {}\n\t\n\t/**\n\t * @prop {string}  namespace  The Event namespace; i.e. state or action\n\t * @prop {string}  type       The Event type;      i.e. leave/enter (state) or start/end (action)\n\t * @prop {string}  target     The Event target;    i.e. intro (state) or next (action)\n\t * @prop {string}  from       The from state\n\t * @prop {string}  to         The to state\n\t */\n\tvar event = {\n\t    // properties\n\t    namespace: null,\n\t    type: null,\n\t    target: null,\n\t    from: null,\n\t    to: null,\n\t\n\t    // transition callbacks\n\t    pause: noop,\n\t    resume: noop,\n\t    cancel: noop,\n\t    complete: noop\n\t};\n\t\n\tfunction initialize(event, namespace, type, target, from, to, callbacks) {\n\t    event.namespace = namespace;\n\t    event.type = type;\n\t    event.target = target;\n\t    event.from = from;\n\t    event.to = to;\n\t\n\t    event.pause = callbacks.pause;\n\t    event.resume = callbacks.resume;\n\t    event.cancel = callbacks.cancel;\n\t    event.complete = callbacks.complete;\n\t}\n\t\n\texports.default = {\n\t    create: function create(namespace, type, target, from, to, callbacks) {\n\t        var fn = namespace == 'state' ? StateEvent : ActionEvent;\n\t        return new fn(type, target, from, to, callbacks);\n\t    }\n\t};\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// ActionEvent\n\t\n\tfunction ActionEvent(type, target, from, to, callbacks) {\n\t    initialize(this, 'action', type, target, from, to, callbacks);\n\t}\n\tActionEvent.prototype = event;\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// StateEvent\n\t\n\tfunction StateEvent(type, target, from, to, callbacks) {\n\t    initialize(this, 'state', type, target, from, to, callbacks);\n\t}\n\tStateEvent.prototype = event;\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// SystemEvent\n\t\n\tfunction SystemEvent(type) {\n\t    this.type = type;\n\t}\n\t\n\tSystemEvent.prototype = {\n\t    namespace: 'system',\n\t    type: ''\n\t};\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// TransitionEvent\n\t\n\tfunction TransitionEvent(type) {\n\t    this.type = type;\n\t}\n\t\n\tTransitionEvent.prototype = {\n\t    namespace: 'transition',\n\t    type: ''\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** state-machine.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap d538063be882fab1e13c\n **/","import ValueMap from './utils/ValueMap';\nimport Transition from './Transition';\nimport { SystemEvent, TransitionEvent } from './Events';\nimport { isString, isFunction } from './utils/utils';\n\nexport default function StateMachine (scope, config)\n{\n    this.scope          = scope;\n    this.state          = '';\n    this.states         = [];\n    this.transitions    = new ValueMap();\n    this.actions        = new ValueMap();\n    this.handlers       = new ValueMap();\n    if(config)\n    {\n        this.initialize(config);\n        this.update('system', 'initialize');\n    }\n}\n\n/**\n * StateMachine prototype\n *\n * The property examples below illustrate a 4-state machine, with states:\n *\n * - intro > settings > summary > end\n *\n * And actions:\n *\n * - back | next | restart | finish\n */\nStateMachine.prototype =\n{\n    // ------------------------------------------------------------------------------------------------\n    // properties\n\n        /**\n         * Available state names\n         *\n         * - [\n         *     intro,\n         *     settings,\n         *     summary,\n         *     final\n         *   ]\n         *\n         * @var {string[]}\n         */\n        states      : null,\n\n        /**\n         * Available transitions for each action\n         *\n         * action.from => to\n         *\n         * - next: {\n         *     intro: settings,\n         *     settings: summary\n         *   },\n         * - back: {\n         *     settings: intro\n         *   },\n         * - restart: {\n         *     summary:intro\n         *   },\n         * - finish: {\n         *     summary:final\n         *   },\n         *\n         * Transitions can also be functions\n         *\n         * - next: {\n         *     intro: function() { return '<random state>' } // jump to a random state\n         *   }\n         *\n         * @var {ValueMap}\n         */\n        transitions : null,\n\n        /**\n         * Actions that are available to be called from each state\n         *\n         * state => [ action, action, ... ]\n         *\n         * - intro: [\n         *     'next'\n         *   ],\n         * - settings: [\n         *     'next',\n         *     'back'\n         *   ],\n         * - summary: [\n         *     'restart'\n         *     'finish',\n         *   ]\n         *\n         * Actions can also be expressed as wildcards\n         *\n         * - intro: [\n         *     '*' // any action is allowed from intro\n         *   ]\n         *\n         * @var {ValueMap}\n         */\n        actions     : null,\n\n        /**\n         * Handler functions that should be called on each action event / state change\n         *\n         * name.type => [ handler, handler, ... ]\n         *\n         * - next: {\n         *   - start: [\n         *       hideModal\n         *     ],\n         *   - end: [\n         *       showModal\n         *     ]\n         *   },\n         * - summary: {\n         *   - enter: [\n         *       resetForm\n         *     ],\n         *   - leave: [\n         *       validateForm,\n         *       postData,\n         *     ]\n         *   },\n         *   ...\n         *\n         * @var {ValueMap}\n         */\n        handlers   : null,\n\n        /**\n         * The current state\n         *\n         * @var {string}\n         */\n        state       : '',\n\n        /**\n         * Any active Transition object that is driving the state change\n         *\n         * @var {Transition}\n         */\n        transition  : null,\n\n        /**\n         * The scope in which to call all handlers\n         *\n         * @var {*}\n         */\n        scope      : null,\n\n        /**\n         * The original config object\n         *\n         * @var {Object}\n         */\n        config      : null,\n\n\n    // ------------------------------------------------------------------------------------------------\n    // private methods\n\n        /**\n         * Initialize the FSM with a config object\n         *\n         * @private\n         * @param config\n         */\n        initialize:function (config)\n        {\n            // assign config\n            this.config     = config;\n\n            // pre-collate all states\n            addStates(this, 'from', config.events);\n            addStates(this, 'to', config.events);\n\n            // initial state\n            if( ! config.initial )\n            {\n                config.initial = this.states[0];\n            }\n\n            // add transitions\n            config.events.map( event =>\n            {\n                // shorthand\n                if(isString(event))\n                {\n                    let matches = event.match(/(\\w+)\\s*[\\|:=]\\s*(\\w+)\\s*([<>-])\\s*(\\w.*)/);\n                    let [,name, from, op, to] = matches;\n                    if(op === '-')\n                    {\n                        this.add(name, from, to);\n                        this.add(name, to, from);\n                        return;\n                    }\n                    if(op === '<')\n                    {\n                        [from, to] = [to, from];\n                    }\n                    this.add(name, from, to);\n                }\n\n                // keys\n                else\n                {\n                    this.add(event.name, event.from, event.to);\n                }\n            });\n\n            // add handlers\n            for(let name in config.handlers)\n            {\n                if(config.handlers.hasOwnProperty(name))\n                {\n                    this.on(name, config.handlers[name]);\n                }\n            }\n\n            // state\n            if( ! config.defer )\n            {\n                this.state = config.initial;\n            }\n\n            /**\n             * Sets the default order to run transition callbacks in\n             *\n             * start/leave/enter/end  -> event types\n             * to/action              -> targeted handlers (leave:red)\n             * *                      -> global handlers   (leave, or leave:*)\n             *\n             * @type {string[]} type.target\n             */\n            config.order = config.order || [\n                'start:*',\n                'start:action',\n                'leave:from',\n                'leave:*',\n                'enter:*',\n                'enter:to',\n                'end:action',\n                'end:*'\n            ];\n        },\n\n        /**\n         * Dispatch an event\n         *\n         * @param namespace\n         * @param type\n         */\n        update: function (namespace, type)\n        {\n            let event = namespace === 'system'\n                ? SystemEvent\n                : TransitionEvent;\n            this.dispatch(namespace + '.' + type, new event(type));\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // api\n\n        /**\n         * Attempt to run an action, resulting in a transition to a state\n         *\n         * @param   {string}    action\n         * @param   {*[]}       rest\n         * @returns {boolean}\n         */\n        do: function (action, ...rest)\n        {\n            if(this.can(action))\n            {\n                this.config.debug && console.info('Doing action \"%s\"', action);\n                this.transition = Transition.create(this, action, rest);\n                this.update('transition', 'start');\n                this.update('system', 'update');\n                this.transition.exec();\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Attempt to go to a state\n         *\n         * Finds if an appropriate transition exists, then calls the related action if it does\n         *\n         * @param   {string}    state\n         * @returns {boolean}\n         */\n        go: function (state)\n        {\n            if(this.has(state))\n            {\n                var action = this.getActionForState(state);\n                if(action)\n                {\n                    return this.do(action);\n                }\n                this.config.debug && console.info('No transition exists from \"%s\" to \"%s\"', this.state, state);\n            }\n            else\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n            }\n            return false;\n        },\n\n        /**\n         * Query a transition to see if a named action is available\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        can: function (action)\n        {\n            if( ! this.actions.has(action) )\n            {\n                this.config.debug && console.warn('No such action \"%s\"', action);\n            }\n            return !! this.transitions.has(this.state, action);\n        },\n\n        /**\n         * Query a transition to see if a named action is unavailable\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        cannot: function (action)\n        {\n            return ! this.can(action);\n        },\n\n        /**\n         * Test if the current state is the same as the supplied one\n         *\n         * @param   {string}    state       A state name to compare against the current state\n         * @returns {boolean}\n         */\n        is: function (state)\n        {\n            if(this.states.indexOf(state) === -1)\n            {\n                this.config.debug && console.warn('No such state \"%s\"', state);\n            }\n            return state === this.state;\n        },\n\n        /**\n         * Test if a state exists\n         *\n         * @param   {string}    state\n         * @return  {boolean}\n         */\n        has: function(state)\n        {\n            return this.states.indexOf(state) !== -1;\n        },\n\n        /**\n         * Get the available \"to\" states for the current or supplied state\n         *\n         * @param   {string}    [state]     Optional name of a state to get states for. Defaults to the current state\n         * @returns {string[]}              An array of string states\n         */\n        getStatesFor: function (state = null)\n        {\n            state       = state || this.state;\n            let actions = this.getActionsFor(state, true);\n            return Object.keys(actions).map( name => actions[name] );\n        },\n\n        /**\n         * Get the available actions (or actions and states) for the current or supplied state\n         *\n         * @param   {string}    [state]     Optional name of a state to get actions for. Defaults to the current state\n         * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n         * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n         */\n        getActionsFor: function (state = null, asMap = false)\n        {\n            state       = state || this.state;\n            let actions = this.transitions.get(state || this.state);\n            if(asMap)\n            {\n                let states  = {};\n                actions.map( action =>\n                {\n                    states[action] = this.actions.get(action + '.' + state);\n                });\n                return states;\n            }\n            else\n            {\n                return actions;\n            }\n        },\n\n        getActionForState: function (state)\n        {\n            if(this.has(state))\n            {\n                let actions = this.getActionsFor(null, true);\n                for(let action in actions)\n                {\n                    if(actions[action] === state)\n                    {\n                        return action;\n                    }\n                }\n            }\n            return null;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // flags\n\n        /**\n         * Test if the FSM has started\n         *\n         * @returns {boolean}\n         */\n        isStarted: function ()\n        {\n            return this.state !== '';\n        },\n\n        /**\n         * Test if the FSM is transitioning\n         *\n         * @returns {boolean}\n         */\n        isTransitioning: function ()\n        {\n            return !! this.transition;\n        },\n\n        /**\n         * Test if the FSM is paused (whilst transitioning)\n         *\n         * @returns {boolean}\n         */\n        isPaused: function ()\n        {\n            return this.transition\n                ? this.transition.paused\n                : false;\n        },\n\n        /**\n         * Test if the FSM is on the \"final\" state\n         *\n         * @returns {boolean}\n         */\n        isComplete: function ()\n        {\n            return this.state === this.config.final;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // transitions\n\n        /**\n         * Pause any current transition\n         *\n         * @returns {StateMachine}\n         */\n        pause: function ()\n        {\n            if(this.transition)\n            {\n                this.transition.pause();\n                this.update('transition', 'pause');\n                this.update('system', 'update');\n            }\n            return this;\n        },\n\n        /**\n         * Resume any current transition\n         *\n         * @returns {StateMachine}\n         */\n        resume: function ()\n        {\n            if(this.transition)\n            {\n                this.update('transition', 'resume');\n                this.update('system', 'update');\n                this.transition.resume();\n            }\n            return this;\n        },\n\n        /**\n         * Cancel any current transition\n         *\n         * @returns {StateMachine}\n         */\n        cancel: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.from;\n                this.transition.clear();\n                delete this.transition;\n                this.update('transition', 'cancel');\n                this.update('system', 'update');\n            }\n            return this;\n        },\n\n        /**\n         * End any current transition, skipping remaining handlers\n         *\n         * @returns {StateMachine}\n         */\n        end: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.to;\n                this.transition.clear();\n                delete this.transition;\n                this.update('system', 'change');\n                this.update('system', 'update');\n                if(this.isComplete())\n                {\n                    this.update('system', 'complete');\n                }\n                this.update('transition', 'end');\n            }\n            return this;\n        },\n\n        /**\n         * Reset the FSM to the initial, or supplied, state\n         *\n         * @returns {StateMachine}\n         */\n        reset:function(initial)\n        {\n            this.state = initial || this.config.initial;\n            if(this.transition)\n            {\n                this.transition.clear();\n                delete this.transition;\n            }\n            this.update('system', 'reset');\n            return this;\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // actions\n\n        /**\n         * Add a transition event\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        add: function (action, from, to)\n        {\n            this.actions.set(action + '.' + from, to);\n            this.transitions.add(from, action);\n            return this;\n        },\n\n        remove: function (action, from, to)\n        {\n            this.states.remove(action, from);\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // handlers\n\n        /**\n         * Add an event handler\n         *\n         * Event handler signature:\n         *\n         * - namespace.type:target1 target2 target3 ...\n         *\n         * Valid event signatures:\n         *\n         * - system:(change|update|complete|reset)\n         * - action:(start|end)\n         * - state:(add|remove|leave|enter)\n         * - transition:(pause|resume|cancel)\n         *\n         * As event types are unique, they can be used without the namespace:\n         *\n         * - change\n         * - pause\n         * - start\n         * - end\n         * - leave:red\n         * - enter:blue green\n         * - start:next\n         * - end:back\n         *\n         * You can also just pass action or names to target individual state.leave / action.end events:\n         *\n         * - next\n         * - intro\n         *\n         * @param id\n         * @param fn\n         * @return {StateMachine}\n         */\n        on: function (id, fn)\n        {\n            let [namespace, type, targets] = parseHandler(this, id);\n            targets.map( target => addHandler(this, namespace, type, target, fn) );\n            return this;\n        },\n\n        off: function (id, fn)\n        {\n            let [namespace, type, targets] = parseHandler(this, id);\n            this.handlers.remove(path, fn);\n        },\n\n        dispatch: function(path, event)\n        {\n            this.config.debug && console.info('StateMachine update \"%s\"', path);\n            let handlers = this.handlers.get(path);\n            if(handlers)\n            {\n                // do we need to pass additional arguments?\n                handlers.map(fn => fn(event) );\n            }\n\n        }\n\n};\n\n/**\n * Parses config and adds unique state names to states array\n *\n * @param {StateMachine}    fsm\n * @param {string}          key\n * @param {Object[]}        transitions\n */\nfunction addStates(fsm, key, transitions)\n{\n    transitions.map( event => addState(fsm, event[key]) );\n}\n\nfunction addState (fsm, state)\n{\n    if (isString(state) && fsm.states.indexOf(state) === -1)\n    {\n        fsm.states.push(state);\n    }\n}\n\n/**\n * Generic function to parse action and add callback\n *\n * @param {StateMachine}    fsm\n * @param {string}          namespace\n * @param {string}          type\n * @param {string}          target\n * @param {Function}        fn\n */\nfunction addHandler(fsm, namespace, type, target, fn)\n{\n    // warn for invalid actions / states\n    if(target !== '*')\n    {\n        if(namespace === 'state' && fsm.states.indexOf(target) === -1)\n        {\n            fsm.config.debug && console.warn('Warning assigning state.%s handler: no such state \"%s\"', type, target);\n        }\n        else if(namespace === 'action' && ! fsm.actions.has(target))\n        {\n            fsm.config.debug && console.warn('Warning assigning action.%s handler: no such action \"%s\"', type, target);\n        }\n    }\n\n    // check handler is a function\n    if( ! isFunction(fn) )\n    {\n        throw new Error('Error assigning ' +namespace+ '.' +type+ ' handler; callback is not a Function', fn);\n    }\n\n    // assign\n    let path = namespace === 'action' || namespace === 'state'\n        ? [namespace, target, type].join('.')\n        : namespace + '.' + type;\n    fsm.handlers.insert(path, fn);\n}\n\nfunction parseHandler(fsm, id)\n{\n    // get initial matches\n    let matches = id.match(/^(?:(\\w+)\\.)?(\\w+[-.\\w]*)(?::(.*))?/);\n    if(!matches)\n    {\n        throw new Error('Warning parsing event handler: invalid signature \"%s\"', id);\n    }\n    let [,namespace, type, target] = matches;\n\n    // determine event if not found\n    if(!namespace)\n    {\n        // check if shorthand global was passed\n        namespace = eventNamespaces[type];\n\n        // if event is still null, attempt to determine type from existing states or actions\n        if(!namespace)\n        {\n            if(fsm.states.indexOf(type) !== -1)\n            {\n                target      = type;\n                namespace   = 'state';\n                type        = 'enter';\n\n            }\n            else if(fsm.actions.has(type))\n            {\n                target      = type;\n                namespace   = 'action';\n                type        = 'start';\n            }\n            else\n            {\n                fsm.config.debug && console.warn('Warning parsing event handler: unable to map \"%s\" to a valid event or existing entity', id);\n            }\n        }\n    }\n\n    // assign\n    let targets = target\n        ? target.match(/[*\\w]+/g)\n        : ['*'];\n\n    return [namespace, type, targets]\n}\n\nlet eventNamespaces =\n{\n    change\t:'system',\n    update\t:'system',\n    complete:'system',\n    reset\t:'system',\n\n    add\t    :'state',\n    remove\t:'state',\n    leave\t:'state',\n    enter\t:'state',\n\n    start\t:'action',\n    end\t    :'action',\n\n    pause\t:'transition',\n    resume\t:'transition',\n    cancel\t:'transition'\n};\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/StateMachine.js\n **/","import {isObject, isArray, isDefined, isUndefined} from './utils';\n\n/**\n * Utility class to create, modify and delete nested hashes and values\n *\n * @constructor\n */\nexport default function ValueMap (data)\n{\n    this.data = data || {};\n}\n\nValueMap.prototype =\n{\n    data: null,\n\n    set: function (path, value)\n    {\n        set(this.data, path, value);\n        return this;\n    },\n\n    add:function(path, value)\n    {\n        add(this.data, path, value);\n        return this;\n    },\n\n    insert:function(path, value)\n    {\n        insert(this.data, path, value);\n        return this;\n    },\n\n    get:function(path)\n    {\n        return get(this.data, path);\n    },\n\n    has: function (path, value = undefined)\n    {\n        return has(this.data, path, value)\n    },\n\n    indexOf: function (path, value)\n    {\n        return indexOf(this.data, path, value)\n    },\n\n    remove: function (path, value = undefined)\n    {\n        remove(this.data, path, value);\n        return this;\n    },\n\n    keys:function(path)\n    {\n        return Object.keys(get(this.data, path));\n    },\n\n    values:function(path)\n    {\n        return values(this.data, path);\n    }\n\n};\n\nfunction create(obj, keys)\n{\n    let key;\n    while(keys.length)\n    {\n        key = keys.shift();\n        if( ! isObject(obj[key]) )\n        {\n            obj[key] = {};\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n\nexport function set(obj, path, value, index = -1)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    obj[key] = value;\n}\n\nfunction add(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    obj[key].push(value);\n}\n\nfunction insert(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    let parent = obj[key],\n        index = parent.indexOf(value);\n    if(index === -1)\n    {\n        parent.push(value);\n    }\n    else\n    {\n        parent[index] = value;\n    }\n}\n\nexport function get(obj, path)\n{\n    if(isUndefined(path) || path == '')\n    {\n        return obj;\n    }\n\n    let key,\n        keys = String(path).split('.');\n    while(keys.length > 1)\n    {\n        key = keys.shift();\n        if( ! obj.hasOwnProperty(key) )\n        {\n            return;\n        }\n        obj = obj[key];\n    }\n    key = keys.shift();\n    return obj[key];\n}\n\nexport function has(obj, path, value)\n{\n    let parent = get(obj, path);\n    return !! (isArray(parent) && isDefined(value)\n        ? parent.indexOf(value) !== -1\n        : isUndefined(value)\n            ? isDefined(parent)\n            : parent === value);\n}\n\nexport function indexOf (obj, path, value)\n{\n    let arr = get(obj, path);\n    if(isArray(arr))\n    {\n        return arr.indexOf(value);\n    }\n    return -1;\n}\n\nexport function remove(obj, path, value)\n{\n    let parent = obj,\n        keys = String(path || '').split('.'),\n        key = keys.pop();\n\n    if(keys.length)\n    {\n        parent = get(obj, keys.join('.'))\n    }\n    if(isDefined(value) && isArray(parent[key]))\n    {\n        parent = parent[key];\n        var index = parent.indexOf(value);\n        if(index > -1)\n        {\n            parent.splice(index, 1);\n            return true;\n        }\n        return false;\n    }\n    else\n    {\n        if(isObject(parent) && obj.hasOwnProperty(key))\n        {\n            delete parent[key];\n            return true;\n        }\n    }\n    return false\n}\n\nexport function values(obj, path)\n{\n    var values = [];\n    var target = get(obj, path);\n    if(isObject(target))\n    {\n        for(var name in target)\n        {\n            if(target.hasOwnProperty(name))\n            {\n                values.push(target[name]);\n            }\n        }\n    }\n    return values;\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/ValueMap.js\n **/","export function isObject (value)\n{\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport function isArray (value)\n{\n    return value instanceof Array;\n}\n\nexport function isString (value)\n{\n    return typeof value === 'string';\n}\n\nexport function isFunction(value)\n{\n    return value instanceof Function;\n}\n\nexport function isDefined (value)\n{\n    return typeof value !== 'undefined';\n}\n\nexport function isUndefined (value)\n{\n    return typeof value === 'undefined';\n}\n\nexport function trim (value)\n{\n    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n}\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/utils/utils.js\n **/","import Events from './Events';\nimport { isFunction } from './utils/utils';\n\n/**\n * Transition class\n *\n * Responsible for managing events in the flow from state to state.\n *\n * This adds all handlers for the current action start/end and state from/to to an array:\n *\n * - <namespace>.<target>.<type>[]\n *\n * So going from state \"a\" to state \"b\" with action \"next\" should build:\n *\n * - action.*.start[]\n * - action.next.start[]\n * - state.a.leave[]\n * - state.*.leave[]\n * - state.*.enter[]\n * - state.b.enter[]\n * - action.next.end[]\n * - action.*.end[]\n *\n * This can be changed by passing in an order array in fsm.config\n *\n * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n *\n * From a callback, you can:\n *\n * - return false to cancel the transition\n * - return true to pause the transition\n * - not return a value (the transition continues)\n *\n * Transitions can also be paused, resumed, or cancelled by calling\n * the appropriate method on, or from:\n *\n * - the event\n * - the transition\n * - the state machine\n *\n * Cancelled transitions will reset the FSM to the previous \"from\" state\n *\n * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n *\n * @param {string}          action\n * @param {string}          from\n * @param {string}          to\n * @param {Function[]}      handlers\n * @param {Object}          callbacks\n */\nfunction Transition (action, from, to, handlers, callbacks)\n{\n    this.action     = action;\n    this.from       = from;\n    this.to         = to;\n    this.handlers   = handlers;\n    this.callbacks  = callbacks;\n}\n\nTransition.prototype =\n{\n    action      : '',\n    from        : '',\n    to          : '',\n    handlers    : null,\n    callbacks   : null,\n    paused      : false,\n\n    clear: function ()\n    {\n        this.paused = false;\n        this.handlers = [];\n    },\n\n    /**\n     * Execute the next event's callbacks\n     * @returns {*}\n     */\n\texec: function ()\n\t{\n\t    if( ! this.paused )\n        {\n            if(this.handlers.length)\n            {\n                var handler = this.handlers.shift();\n                var state = handler();\n                if(state === false)\n                {\n                    return this.callbacks.cancel();\n                }\n                if(state === true)\n                {\n                    return this.callbacks.pause();\n                }\n                this.exec();\n            }\n            else\n            {\n                this.callbacks.end();\n            }\n        }\n        return this;\n\t},\n\n    pause: function ()\n    {\n        this.paused = true;\n        return this;\n    },\n\n    resume: function ()\n    {\n        this.paused = false;\n        return this.exec();\n    }\n};\n\n\nexport default\n{\n    /**\n     * Create the Transition object\n     *\n     * - Set up variables, callbacks and queue\n     * - Determine paths to relevant callbacks\n     * - Build State and Action Event objects\n     * - Pre-bind all handlers\n     * - Append to queue\n     *\n     * @param {StateMachine}    fsm\n     * @param {string}          action\n     * @param {Array}           params\n     * @returns {Transition}\n     */\n    create:function (fsm, action, params)\n    {\n        // transition\n        var queue   = [];\n        var scope   = fsm.scope;\n        var from    = fsm.state;\n        var to      = fsm.actions.get(action)[from];\n        var callbacks =\n        {\n            cancel   :fsm.cancel.bind(fsm),\n            pause    :fsm.pause.bind(fsm),\n            resume   :fsm.resume.bind(fsm),\n            end      :fsm.end.bind(fsm)\n        };\n\n        // handle \"to\" being a function\n        if(isFunction(to))\n        {\n            let actions = fsm.getActionsFor();\n            let state   = to.apply(scope, [actions].concat(params));\n            let action  = fsm.getActionsFor(state);\n            // TODO debug this! It's wrong\n            if( ! action )\n            {\n                throw new Error('Cannot go to state \"' +state+ '\" from current state \"' +from+ '\"');\n            }\n        }\n\n        // build handlers array\n        fsm.config.order.map( token =>\n        {\n            // determine path variables\n            let [type, source]      = token.split(':'); // i.e. start.*, enter:to, end:action\n            let namespace           = /^(start|end)$/.test(type)\n                                        ? 'action'\n                                        : 'state';\n            let target;\n            if(source === '*')\n            {\n                target = '*';\n            }\n            else if(namespace == 'action')\n            {\n                target = action;\n            }\n            else\n            {\n                target = type === 'leave'\n                    ? from\n                    : to;\n            }\n\n            // get handlers\n            let path = [namespace, target, type].join('.');\n\n            let handlers = fsm.handlers.get(path);\n            if(handlers)\n            {\n                // pre-bind handlers, scopes and params\n                // this way scope and params don't need to be passed around\n                handlers = handlers.map( handler =>\n                {\n                    return function()\n                    {\n                        let event = Events.create(namespace, type, target, from, to, callbacks);\n                        handler.apply(scope, [event].concat(params));\n                    }\n                });\n\n                // add to queue\n                queue = queue.concat(handlers);\n            }\n\n        });\n\n        // create\n        return new Transition(action, from, to, queue, callbacks);\n    }\n\n}\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/Transition.js\n **/","// ------------------------------------------------------------------------------------------------\n// setup\n\n    function noop () { }\n\n    /**\n     * @prop {string}  namespace  The Event namespace; i.e. state or action\n     * @prop {string}  type       The Event type;      i.e. leave/enter (state) or start/end (action)\n     * @prop {string}  target     The Event target;    i.e. intro (state) or next (action)\n     * @prop {string}  from       The from state\n     * @prop {string}  to         The to state\n     */\n    let event =\n    {\n        // properties\n        namespace   : null,\n        type        : null,\n        target      : null,\n        from        : null,\n        to          : null,\n\n        // transition callbacks\n        pause       : noop,\n        resume      : noop,\n        cancel      : noop,\n        complete    : noop\n    };\n\n    function initialize (event, namespace, type, target, from, to, callbacks)\n    {\n        event.namespace = namespace;\n        event.type      = type;\n        event.target    = target;\n        event.from      = from;\n        event.to        = to;\n\n        event.pause     = callbacks.pause;\n        event.resume    = callbacks.resume;\n        event.cancel    = callbacks.cancel;\n        event.complete  = callbacks.complete;\n    }\n\n    export default\n    {\n        create: function(namespace, type, target, from, to, callbacks)\n        {\n            var fn = namespace == 'state'\n                ? StateEvent\n                : ActionEvent;\n            return new fn(type, target, from, to, callbacks);\n        }\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// ActionEvent\n\n    export function ActionEvent (type, target, from, to, callbacks)\n    {\n        initialize(this, 'action' ,type, target, from, to, callbacks);\n    }\n    ActionEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// StateEvent\n\n    export function StateEvent (type, target, from, to, callbacks)\n    {\n        initialize(this, 'state' ,type, target, from, to, callbacks);\n    }\n    StateEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// SystemEvent\n\n    export function SystemEvent (type)\n    {\n        this.type = type;\n    }\n\n    SystemEvent.prototype =\n    {\n        namespace: 'system',\n        type: ''\n    };\n\n\n// ------------------------------------------------------------------------------------------------\n// TransitionEvent\n\n    export function TransitionEvent (type)\n    {\n        this.type = type;\n    }\n\n    TransitionEvent.prototype =\n    {\n        namespace: 'transition',\n        type: ''\n    };\n\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/Events.js\n **/"],"sourceRoot":""}