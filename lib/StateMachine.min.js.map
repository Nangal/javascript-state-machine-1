{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///StateMachine.min.js","webpack:///webpack/bootstrap 78f0aec4264f3a0fa36c?b39d","webpack:///./src/core/utils/utils.js?57f9","webpack:///./src/StateMachine.js","webpack:///./src/core/classes/Config.js","webpack:///./src/core/maps/HandlerMap.js","webpack:///./src/core/maps/ValueMap.js","webpack:///./src/core/objects/events.js","webpack:///./src/core/parsers/HandlerParser.js","webpack:///./src/core/parsers/HandlerMeta.js","webpack:///./src/core/lexer/Lexer.js","webpack:///./src/core/lexer/Rule.js","webpack:///./src/core/lexer/Token.js","webpack:///./src/core/objects/errors.js","webpack:///./src/core/maps/TransitionMap.js","webpack:///./src/core/parsers/TransitionParser.js","webpack:///./src/core/parsers/TransitionMeta.js","webpack:///./src/core/classes/Transition.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","isObject","value","Object","prototype","toString","isArray","Array","isString","isFunction","Function","isDefined","isUndefined","trim","String","replace","diff","a","b","da","filter","v","indexOf","db","concat","toHash","values","reduce","obj","defineProperty","_interopRequireDefault","__esModule","default","StateMachine","options","transitions","_TransitionMap2","handlers","_HandlerMap2","initialize","updateTransitions","fsm","method","callback","statesBefore","getStates","actionsBefore","getActions","statesAfter","actionsAfter","states","_utils","actions","map","state","trigger","action","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","length","err","TypeError","_Config","_Config2","_HandlerMap","_TransitionMap","_Transition","_Transition2","config","transition","_this","tx","parse","add","from","to","initial","name","hasOwnProperty","on","methods","scope","start","reset","arguments","cancel","do","canDo","isPaused","_len","rest","_key","create","exec","go","force","has","clear","end","getActionFor","errors","console","warn","getActionsFrom","canGo","hasState","is","isStarted","isTransitioning","paused","isComplete","pause","resume","_this2","remove","_this3","fn","_this4","invalid","forEach","meta","path","off","_this5","_this6","result","Error","message","target","error","namespace","hasAction","_result$target$split","split","_result$target$split2","_this7","_len2","_key2","apply","constructor","getDefaultOrder","Config","match","order","_StateMachine2","defaults","assign","_StateMachine","final","HandlerMap","_ValueMap2","_ValueMap","_events","_HandlerParser","_HandlerParser2","insert","get","_path$match","_path$match2","type","event","test","StateEvent","ActionEvent","SystemEvent","TransitionEvent","ValueMap","data","keys","key","shift","set","pop","parent","index","join","splice","_set","_get","_has","_indexOf","_remove","_values","isSystem","token","isTransition","expandGroups","input","rx","matches","group","items","item","output","addPath","results","_HandlerMeta2","_id","addError","_errors","ParseError","_defaults","parser","_HandlerMeta","_Lexer","_Lexer2","patterns","alias","namespaced","oneAction","oneActionEvent","anyActionEvent","oneState","oneStateEvent","anyStateEvent","oneStateAction","lexer","paths","parsePath","tokens","process","HandlerMeta","Lexer","rules","addRule","LexerError","source","_Rule","_Rule2","_Token","_Token2","substr","some","rule","Rule","Token","slice","_toConsumableArray","arr2","TransitionMap","update","_typeof","_TransitionParser","_TransitionParser2","asMap","wildcard","getStatesFrom","_ret","getStateFor","hasTransition","getError","_TransitionMeta2","stack","op","_ref","_ref2","_TransitionMeta","TransitionMeta","Transition","unpause","handler","params","vars","queue","all","_path$split","_path$split2","Event"],"mappings":"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","file":"StateMachine.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(6);\n\n\n/***/ },\n/* 1 */,\n/* 2 */,\n/* 3 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.isObject = isObject;\n\texports.isArray = isArray;\n\texports.isString = isString;\n\texports.isFunction = isFunction;\n\texports.isDefined = isDefined;\n\texports.isUndefined = isUndefined;\n\texports.trim = trim;\n\texports.diff = diff;\n\texports.toHash = toHash;\n\tfunction isObject(value) {\n\t    return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\t\n\tfunction isArray(value) {\n\t    return value instanceof Array;\n\t}\n\t\n\tfunction isString(value) {\n\t    return typeof value === 'string';\n\t}\n\t\n\tfunction isFunction(value) {\n\t    return value instanceof Function;\n\t}\n\t\n\tfunction isDefined(value) {\n\t    return typeof value !== 'undefined';\n\t}\n\t\n\tfunction isUndefined(value) {\n\t    return typeof value === 'undefined';\n\t}\n\t\n\tfunction trim(value) {\n\t    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n\t}\n\t\n\tfunction diff(a, b) {\n\t    var da = b.filter(function (v) {\n\t        return a.indexOf(v) < 0;\n\t    });\n\t    var db = a.filter(function (v) {\n\t        return b.indexOf(v) < 0;\n\t    });\n\t    return db.concat(da);\n\t}\n\t\n\tfunction toHash(values) {\n\t    return values.reduce(function (obj, value) {\n\t        obj[value] = true;\n\t        return obj;\n\t    }, {});\n\t}\n\n/***/ },\n/* 4 */,\n/* 5 */,\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _Config = __webpack_require__(7);\n\t\n\tvar _Config2 = _interopRequireDefault(_Config);\n\t\n\tvar _HandlerMap = __webpack_require__(8);\n\t\n\tvar _HandlerMap2 = _interopRequireDefault(_HandlerMap);\n\t\n\tvar _TransitionMap = __webpack_require__(17);\n\t\n\tvar _TransitionMap2 = _interopRequireDefault(_TransitionMap);\n\t\n\tvar _Transition = __webpack_require__(20);\n\t\n\tvar _Transition2 = _interopRequireDefault(_Transition);\n\t\n\tvar _utils = __webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * StateMachine constructor\n\t *\n\t * @param   {Object|null}    options\n\t * @constructor\n\t */\n\tfunction StateMachine(options) {\n\t    this.transitions = new _TransitionMap2.default();\n\t    this.handlers = new _HandlerMap2.default(this);\n\t    this.initialize(options);\n\t}\n\t\n\t/**\n\t * StateMachine prototype\n\t *\n\t * The property examples below illustrate a 4-state machine, with states:\n\t *\n\t * - intro > settings > summary > end\n\t *\n\t * And actions:\n\t *\n\t * - back | next | restart | finish\n\t */\n\tStateMachine.prototype = {\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // properties\n\t\n\t    /**\n\t     * Configuration object\n\t     *\n\t     * @var {Config}\n\t     */\n\t    config: null,\n\t\n\t    /**\n\t     * Map of all transitions\n\t     *\n\t     * @var {TransitionMap}\n\t     */\n\t    transitions: null,\n\t\n\t    /**\n\t     * Map of all handlers\n\t     *\n\t     * @var {HandlerMap}\n\t     */\n\t    handlers: null,\n\t\n\t    /**\n\t     * Any active Transition object that is driving the state change\n\t     *\n\t     * @var {Transition}\n\t     */\n\t    transition: null,\n\t\n\t    /**\n\t     * The current state\n\t     *\n\t     * @var {string}\n\t     */\n\t    state: '',\n\t\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // private methods\n\t\n\t    /**\n\t     * Initialize the FSM with options\n\t     *\n\t     * @private\n\t     * @param options\n\t     */\n\t    initialize: function initialize(options) {\n\t        var _this = this;\n\t\n\t        // state\n\t        this.state = '';\n\t\n\t        // build config\n\t        var config = new _Config2.default(options);\n\t        this.config = config;\n\t\n\t        // pre-process all transitions\n\t        var transitions = [];\n\t        if (Array.isArray(options.transitions)) {\n\t            options.transitions.map(function (tx) {\n\t                transitions = transitions.concat(_this.transitions.parse(tx));\n\t            });\n\t        }\n\t\n\t        // add transitions\n\t        transitions.map(function (transition) {\n\t            _this.transitions.add(transition.action, transition.from, transition.to);\n\t        });\n\t\n\t        // get initial state (must be done after state collation)\n\t        if (!config.initial) {\n\t            config.initial = this.transitions.getStates()[0];\n\t        }\n\t\n\t        // add handlers\n\t        if (options.handlers) {\n\t            for (var _name in options.handlers) {\n\t                if (options.handlers.hasOwnProperty(_name)) {\n\t                    this.on(_name, options.handlers[_name]);\n\t                }\n\t            }\n\t        }\n\t\n\t        // add methods\n\t        if (options.methods) {\n\t            if (!this.config.scope) {\n\t                this.config.scope = this;\n\t            }\n\t            for (var name in options.methods) {\n\t                if (options.methods.hasOwnProperty(name) && !this.hasOwnProperty(name)) {\n\t                    this[name] = options.methods[name];\n\t                }\n\t            }\n\t        }\n\t\n\t        // start\n\t        if (this.config.start) {\n\t            this.start();\n\t        }\n\t\n\t        // return\n\t        return this;\n\t    },\n\t\n\t    start: function start() {\n\t        this.state = this.config.initial;\n\t        this.handlers.trigger('system.start');\n\t        if (this.state) {\n\t            this.handlers.trigger('system.change', this.state);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Reset the FSM to the initial, or supplied, state\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    reset: function reset() {\n\t        var initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t\n\t        var state = initial || this.config.initial;\n\t        this.handlers.trigger('system.reset');\n\t        if (this.transition) {\n\t            this.transition.cancel();\n\t            delete this.transition;\n\t        }\n\t        if (this.state !== state) {\n\t            this.state = state;\n\t            this.handlers.trigger('system.change', this.state);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // api\n\t\n\t    /**\n\t     * Attempt to run an action, resulting in a transition to a state\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {*[]}       rest\n\t     * @returns {boolean}\n\t     */\n\t    do: function _do(action) {\n\t        if (this.canDo(action) && !this.isPaused()) {\n\t            for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                rest[_key - 1] = arguments[_key];\n\t            }\n\t\n\t            this.transition = _Transition2.default.create(this, action, rest);\n\t            this.transition.exec();\n\t            return true;\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Attempt to go to a state\n\t     *\n\t     * Queries TransitionMap instance to see if a transition exists, then calls the related action if it does\n\t     *\n\t     * @param   {string}    state\n\t     * @param   {boolean}   [force]\n\t     * @returns {boolean}\n\t     */\n\t    go: function go(state) {\n\t        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        if (this.has(state)) {\n\t            if (force) {\n\t                if (this.transition) {\n\t                    this.transition.clear();\n\t                }\n\t                this.transition = _Transition2.default.force(this, state);\n\t                return this.end();\n\t            }\n\t            var action = this.transitions.getActionFor(this.state, state);\n\t            if (action) {\n\t                return this.do(action);\n\t            }\n\t            this.config.errors > 0 && console.warn('No transition exists from \"%s\" to \"%s\"', this.state, state);\n\t            return false;\n\t        }\n\t        this.config.errors > 0 && console.warn('No such state \"%s\"', state);\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Query transition map to see if a named action is available\n\t     *\n\t     * @param   {string}        action\n\t     * @returns {boolean}\n\t     */\n\t    canDo: function canDo(action) {\n\t        return this.transitions.getActionsFrom(this.state).indexOf(action) !== -1;\n\t    },\n\t\n\t    /**\n\t     * Query transition map to see if a state is available to go to\n\t     *\n\t     * @param to\n\t     * @return {boolean}\n\t     */\n\t    canGo: function canGo(to) {\n\t        return this.transitions.getActionFor(this.state, to) !== null;\n\t    },\n\t\n\t    /**\n\t     * Test if a state exists\n\t     *\n\t     * @param   {string}    state\n\t     * @return  {boolean}\n\t     */\n\t    has: function has(state) {\n\t        return this.transitions.hasState(state);\n\t    },\n\t\n\t    /**\n\t     * Test if the current state is the same as the supplied one\n\t     *\n\t     * @param   {string}    state       A state name to compare against the current state\n\t     * @returns {boolean}\n\t     */\n\t    is: function is(state) {\n\t        return state === this.state;\n\t    },\n\t\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // flags\n\t\n\t    /**\n\t     * Test if the FSM has started\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isStarted: function isStarted() {\n\t        return this.state !== '';\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is transitioning\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isTransitioning: function isTransitioning() {\n\t        return !!this.transition;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is paused (whilst transitioning)\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isPaused: function isPaused() {\n\t        return this.transition ? this.transition.paused : false;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is on the \"final\" state\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isComplete: function isComplete() {\n\t        return this.state === this.config.final;\n\t    },\n\t\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // transitions\n\t\n\t    /**\n\t     * Pause any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    pause: function pause() {\n\t        if (this.transition && !this.isPaused()) {\n\t            this.transition.pause();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Resume any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    resume: function resume() {\n\t        if (this.transition && this.isPaused()) {\n\t            this.transition.resume();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Cancel any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    cancel: function cancel() {\n\t        if (this.transition) {\n\t            this.state = this.transition.from;\n\t            this.transition.cancel();\n\t            delete this.transition;\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * End any current transition, skipping remaining handlers\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    end: function end() {\n\t        if (this.transition) {\n\t            this.state = this.transition.to;\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.handlers.trigger('system.change', this.state);\n\t            if (this.isComplete()) {\n\t                this.handlers.trigger('system.complete');\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // actions\n\t\n\t    /**\n\t     * Add a transition\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @return  {StateMachine}\n\t     */\n\t    add: function add(action, from, to) {\n\t        var _this2 = this;\n\t\n\t        // 1 argument: shorthand transition, i.e 'next : a > b'\n\t        if (arguments.length === 1) {\n\t            var transitions = this.transitions.parse(action);\n\t            transitions.map(function (tx) {\n\t                return _this2.add(tx.action, tx.from, tx.to);\n\t            });\n\t            return this;\n\t        }\n\t\n\t        // 3 arguments: longhand transition\n\t        updateTransitions(this, 'add', function () {\n\t            return _this2.transitions.add(action, from, to);\n\t        });\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Remove a state\n\t     *\n\t     * @param   {string}    state\n\t     * @return  {StateMachine}\n\t     */\n\t    remove: function remove(state) {\n\t        var _this3 = this;\n\t\n\t        this.handlers.remove('state.' + state);\n\t        updateTransitions(this, 'remove', function () {\n\t            return _this3.transitions.remove(state);\n\t        });\n\t        return this;\n\t    },\n\t\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // handlers\n\t\n\t    /**\n\t     * Add an event handler\n\t     *\n\t     * Event handler signatures are built from the following grammar:\n\t     *\n\t     * - token      foo\n\t     * - property   .foo\n\t     * - event      :foo\n\t     * - action     @foo\n\t     * - targets    (foo bar baz)\n\t     *\n\t     * For example:\n\t     *\n\t     * - change\n\t     * - transition.pause\n\t     * - next:end\n\t     * - (a b)@next\n\t     * - a@next\n\t     *\n\t     * The main event types are unique, so can be used without the namespace:\n\t     *\n\t     * - change\n\t     * - pause\n\t     * - complete\n\t     * - ...\n\t     *\n\t     * If your states and events are unique, they can also be used without qualification.\n\t     *\n\t     * See docs and demo for more information\n\t     *\n\t     * @param   {string}        id\n\t     * @param   {Function}      fn\n\t     * @return  {StateMachine}\n\t     */\n\t    on: function on(id, fn) {\n\t        var _this4 = this;\n\t\n\t        this.parse(id, this.config.invalid, this.config.errors).forEach(function (meta) {\n\t            return _this4.handlers.add(meta.path, fn);\n\t        });\n\t        return this;\n\t    },\n\t\n\t    off: function off(id, fn) {\n\t        var _this5 = this;\n\t\n\t        this.parse(id, this.config.invalid, this.config.errors).forEach(function (meta) {\n\t            return _this5.handlers.remove(meta.path, fn);\n\t        });\n\t        return this;\n\t    },\n\t\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // utilities\n\t\n\t    /**\n\t     * Parses a handler id string into HandlerMeta objects\n\t     *\n\t     * @param   {string}    id\n\t     * @param   {boolean}   invalid\n\t     * @param   {number}    errors\n\t     * @returns {HandlerMeta[]}\n\t     */\n\t    parse: function parse(id) {\n\t        var _this6 = this;\n\t\n\t        var invalid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t        var errors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t\n\t        return this.handlers.parse(id).filter(function (result) {\n\t            // picks up unrecognised handlers, namespaces, etc\n\t            if (result instanceof Error) {\n\t                if (errors == 2) {\n\t                    throw result;\n\t                }\n\t                errors == 1 && console.warn(result.message);\n\t                return false;\n\t            }\n\t\n\t            // picks up unrecognised states and actions\n\t            if (result.target !== '*') {\n\t                var error = '';\n\t\n\t                if (result.namespace === 'state') {\n\t                    if (!_this6.transitions.hasState(result.target)) {\n\t                        error = 'Unrecognised state \"' + result.target + '\" in handler \"' + result.id + '\"';\n\t                    }\n\t                } else if (result.namespace === 'action') {\n\t                    if (!_this6.transitions.hasAction(result.target)) {\n\t                        error = 'Unrecognised action \"' + result.target + '\" in handler \"' + result.id + '\"';\n\t                    }\n\t                } else if (result.namespace === 'state/action') {\n\t                    // variables\n\t                    var _result$target$split = result.target.split('@');\n\t\n\t                    var _result$target$split2 = _slicedToArray(_result$target$split, 2);\n\t\n\t                    var state = _result$target$split2[0];\n\t                    var action = _result$target$split2[1];\n\t\n\t                    // test for state and action\n\t\n\t                    if (!_this6.transitions.hasState(state)) {\n\t                        error = 'Unrecognised state \"' + state + '\" in handler \"' + result.id + '\"';\n\t                    }\n\t                    if (!_this6.transitions.hasAction(action)) {\n\t                        error = 'Unrecognised action \"' + action + '\" in handler \"' + result.id + '\"';\n\t                    }\n\t                }\n\t\n\t                // if we have an error, the result was not an existing state or action\n\t                if (error) {\n\t                    if (errors == 2) {\n\t                        throw new Error(error);\n\t                    }\n\t                    errors == 1 && console.warn(error);\n\t                    return !!invalid;\n\t                }\n\t            }\n\t\n\t            // must be valid\n\t            return true;\n\t        });\n\t    },\n\t\n\t    trigger: function trigger(id) {\n\t        var _this7 = this;\n\t\n\t        for (var _len2 = arguments.length, rest = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t            rest[_key2 - 1] = arguments[_key2];\n\t        }\n\t\n\t        this.handlers.parse(id).map(function (meta) {\n\t            return _this7.handlers.trigger.apply(_this7.handlers, [meta.path].concat(rest));\n\t        });\n\t        return this;\n\t    }\n\t\n\t};\n\t\n\tStateMachine.prototype.constructor = StateMachine;\n\t\n\texports.default = StateMachine;\n\t\n\t// ---------------------------------------------------------------------------------------------------------------------\n\t// static methods\n\t\n\t/**\n\t * Factory method\n\t *\n\t * @param   options\n\t * @returns {StateMachine}\n\t */\n\t\n\tStateMachine.create = function (options) {\n\t    return new StateMachine(options);\n\t};\n\t\n\t/**\n\t * Gets the default order events should be called in\n\t * @returns {string[]}\n\t */\n\tStateMachine.getDefaultOrder = function () {\n\t    return ['action.*.start', 'action.{action}.start', 'state.*.{action}', 'state.{from}.{action}', 'state.{from}.leave', 'state.*.leave', 'state.*.enter', 'state.{to}.enter', 'action.{action}.end', 'action.*.end'];\n\t};\n\t\n\t// ---------------------------------------------------------------------------------------------------------------------\n\t// helper functions\n\t\n\t/**\n\t * Utility method to update transitions and dispatch events\n\t *\n\t * Saves duplicating the following code in both add() and remove() methods\n\t *\n\t * @param   {StateMachine}  fsm\n\t * @param   {string}        method\n\t * @param   {Function}      callback\n\t */\n\tfunction updateTransitions(fsm, method, callback) {\n\t    var statesBefore = fsm.transitions.getStates();\n\t    var actionsBefore = fsm.transitions.getActions();\n\t    callback();\n\t    var statesAfter = fsm.transitions.getStates();\n\t    var actionsAfter = fsm.transitions.getActions();\n\t\n\t    // calculate differences\n\t    var states = (0, _utils.diff)(statesBefore, statesAfter);\n\t    var actions = (0, _utils.diff)(actionsBefore, actionsAfter);\n\t\n\t    // dispatch events\n\t    states.map(function (state) {\n\t        return fsm.handlers.trigger('system.state.' + method, state);\n\t    });\n\t    actions.map(function (action) {\n\t        return fsm.handlers.trigger('system.action.' + method, action);\n\t    });\n\t}\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = Config;\n\t\n\tvar _StateMachine = __webpack_require__(6);\n\t\n\tvar _StateMachine2 = _interopRequireDefault(_StateMachine);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction Config(options) {\n\t  var _this = this;\n\t\n\t  'scope start initial final invalid errors'.match(/\\w+/g).map(function (name) {\n\t    if (options.hasOwnProperty(name)) {\n\t      _this[name] = options[name];\n\t    }\n\t  });\n\t\n\t  // order\n\t  this.order = options.order || _StateMachine2.default.getDefaultOrder();\n\t\n\t  // defaults\n\t  this.defaults = Object.assign({\n\t\n\t    // allow user to specify alternate triggers for event and action ids\n\t    action: 'start',\n\t    state: 'enter'\n\t\n\t  }, options.defaults);\n\t}\n\t\n\tConfig.prototype = {\n\t  /**\n\t   * An optional scope to run handler functions in\n\t   *\n\t   * @var object\n\t   */\n\t  scope: null,\n\t\n\t  /**\n\t   * A boolean to automatically start the state machine in the initial state\n\t   *\n\t   * @var boolean\n\t   */\n\t  start: true,\n\t\n\t  /**\n\t   * A string to indicate which state to start on; defaults to ''\n\t   *\n\t   * @var string\n\t   */\n\t  initial: '',\n\t\n\t  /**\n\t   * A string indicating the state to trigger a complete event; defaults to ''\n\t   *\n\t   * @var string\n\t   */\n\t  final: '',\n\t\n\t  /**\n\t   * A boolean to allow non-existent states and actions to be added to the handlers object; defaults to false (disallow)\n\t   *\n\t   * @var boolean\n\t   */\n\t  invalid: false,\n\t\n\t  /**\n\t   * A number indicating how to handle invalid or erroneous actions; defaults to 1 (warn)\n\t   *\n\t   *  - 0 : quiet\n\t   *  - 1 : console.warn()\n\t   *  - 2 : throw an error\n\t   *\n\t   * @var number\n\t   */\n\t  errors: 1,\n\t\n\t  /**\n\t   * The order to run transition callbacks in\n\t   *\n\t   * @type {string[]} type.target\n\t   */\n\t  order: null,\n\t\n\t  /**\n\t   * Sets defaults for various declarations\n\t   *\n\t   * Available options are:\n\t   *\n\t   * - action: (start|end)\n\t   * - state: (enter|leave)\n\t   *\n\t   * @type {Object}\n\t   */\n\t  defaults: null\n\t\n\t};\n\n/***/ },\n/* 8 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _ValueMap = __webpack_require__(9);\n\t\n\tvar _ValueMap2 = _interopRequireDefault(_ValueMap);\n\t\n\tvar _events = __webpack_require__(10);\n\t\n\tvar _utils = __webpack_require__(3);\n\t\n\tvar _HandlerParser = __webpack_require__(11);\n\t\n\tvar _HandlerParser2 = _interopRequireDefault(_HandlerParser);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction HandlerMap(fsm) {\n\t    this.fsm = fsm;\n\t    this.map = new _ValueMap2.default();\n\t}\n\t\n\tHandlerMap.prototype = {\n\t\n\t    fsm: null,\n\t\n\t    map: null,\n\t\n\t    /**\n\t     * Parse event handler grammar into a HandlerMeta structure\n\t     *\n\t     * @param   {string}        id      The handler id to parse, i.e. '@next', 'intro:end', 'change', etc\n\t     * @returns {HandlerMeta[]}\n\t     */\n\t    parse: function parse(id) {\n\t        return (0, _HandlerParser2.default)(id, this.fsm.config.defaults);\n\t    },\n\t\n\t    /**\n\t     * Directly add a new handler\n\t     *\n\t     * @param   {string}    path    A 'namespace.target.type' target path to add a handler to\n\t     * @param   {Function}  fn      A callback function\n\t     * @returns {HandlerMap}\n\t     */\n\t    add: function add(path, fn) {\n\t        // check handler is a function\n\t        if (!(0, _utils.isFunction)(fn)) {\n\t            throw new Error('Error assigning \"' + path + '\" handler; callback is not a function', fn);\n\t        }\n\t\n\t        this.map.insert(path, fn);\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Directly remove a handler target\n\t     *\n\t     * @param   {string}    path    A 'namespace.target.type' parent to a handler removed from\n\t     * @param   {Function}  fn      The instance of the callback function\n\t     * @returns {HandlerMap}\n\t     */\n\t    remove: function remove(path, fn) {\n\t        this.map.remove(path, fn);\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Get all handlers for a valid target path\n\t     *\n\t     * @param   {string}    path    A 'namespace.target.type' target path\n\t     * @returns {Function[]}        An array of callback functions\n\t     */\n\t    get: function get(path) {\n\t        return this.map.get(path);\n\t    },\n\t\n\t    /**\n\t     * Dispatch an event\n\t     *\n\t     * @param   {string}    path\n\t     * @param   {*}         value\n\t     * @returns {StateMachine}\n\t     */\n\t    trigger: function trigger(path) {\n\t        var _this = this;\n\t\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t        // create lookup path\n\t        var _path$match = path.match(/\\w+/g);\n\t\n\t        var _path$match2 = _slicedToArray(_path$match, 3);\n\t\n\t        var namespace = _path$match2[0];\n\t        var type = _path$match2[1];\n\t        var method = _path$match2[2];\n\t\n\t        // build event\n\t\n\t        var event = void 0;\n\t        if (/^system\\.(state|action)\\./.test(path)) {\n\t            event = type === 'state' ? new _events.StateEvent(method, value) : new _events.ActionEvent(method, value);\n\t        } else {\n\t            event = namespace === 'system' ? new _events.SystemEvent(type, value) : new _events.TransitionEvent(type);\n\t        }\n\t\n\t        // dispatch\n\t        var handlers = this.map.get(path);\n\t        if (handlers) {\n\t            handlers.map(function (fn) {\n\t                return fn(event, _this.fsm);\n\t            });\n\t        }\n\t    }\n\t\n\t};\n\t\n\texports.default = HandlerMap;\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.values = exports.remove = exports.indexOf = exports.has = exports.get = exports.set = undefined;\n\texports.default = ValueMap;\n\t\n\tvar _utils = __webpack_require__(3);\n\t\n\t/**\n\t * Utility class to create, modify and delete nested hashes and values\n\t *\n\t * @constructor\n\t */\n\tfunction ValueMap(data) {\n\t    this.data = data || {};\n\t}\n\t\n\tValueMap.prototype = {\n\t    data: null,\n\t\n\t    set: function set(path, value) {\n\t        _set(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    add: function add(path, value) {\n\t        _add(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    insert: function insert(path, value) {\n\t        _insert(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    get: function get(path) {\n\t        return _get(this.data, path);\n\t    },\n\t\n\t    has: function has(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        return _has(this.data, path, value);\n\t    },\n\t\n\t    indexOf: function indexOf(path, value) {\n\t        return _indexOf(this.data, path, value);\n\t    },\n\t\n\t    remove: function remove(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        _remove(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    keys: function keys(path) {\n\t        return Object.keys(_get(this.data, path));\n\t    },\n\t\n\t    values: function values(path) {\n\t        return _values(this.data, path);\n\t    }\n\t\n\t};\n\t\n\tfunction create(obj, keys) {\n\t    var key = void 0;\n\t    while (keys.length) {\n\t        key = keys.shift();\n\t        if (!(0, _utils.isObject)(obj[key])) {\n\t            obj[key] = {};\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    return obj;\n\t}\n\t\n\tfunction _set(obj, path, value) {\n\t    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n\t\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    obj[key] = value;\n\t}\n\t\n\texports.set = _set;\n\tfunction _add(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    obj[key].push(value);\n\t}\n\t\n\tfunction _insert(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    var parent = obj[key],\n\t        index = parent.indexOf(value);\n\t    if (index === -1) {\n\t        parent.push(value);\n\t    } else {\n\t        parent[index] = value;\n\t    }\n\t}\n\t\n\tfunction _get(obj, path) {\n\t    if ((0, _utils.isUndefined)(path) || path == '') {\n\t        return obj;\n\t    }\n\t\n\t    var key = void 0,\n\t        keys = String(path).split('.');\n\t    while (keys.length > 1) {\n\t        key = keys.shift();\n\t        if (!obj.hasOwnProperty(key)) {\n\t            return;\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    key = keys.shift();\n\t    return obj[key];\n\t}\n\t\n\texports.get = _get;\n\tfunction _has(obj, path, value) {\n\t    var parent = _get(obj, path);\n\t    return !!((0, _utils.isArray)(parent) && (0, _utils.isDefined)(value) ? parent.indexOf(value) !== -1 : (0, _utils.isUndefined)(value) ? (0, _utils.isDefined)(parent) : parent === value);\n\t}\n\t\n\texports.has = _has;\n\tfunction _indexOf(obj, path, value) {\n\t    var arr = _get(obj, path);\n\t    if ((0, _utils.isArray)(arr)) {\n\t        return arr.indexOf(value);\n\t    }\n\t    return -1;\n\t}\n\t\n\texports.indexOf = _indexOf;\n\tfunction _remove(obj, path, value) {\n\t    var parent = obj,\n\t        keys = String(path || '').split('.'),\n\t        key = keys.pop();\n\t\n\t    if (keys.length) {\n\t        parent = _get(obj, keys.join('.'));\n\t    }\n\t    if ((0, _utils.isDefined)(value) && (0, _utils.isArray)(parent[key])) {\n\t        var target = parent[key];\n\t        var index = target.indexOf(value);\n\t        if (index > -1) {\n\t            target.splice(index, 1);\n\t            if (target.length === 0) {\n\t                delete parent[key];\n\t            }\n\t            return true;\n\t        }\n\t        return false;\n\t    } else {\n\t        if ((0, _utils.isObject)(parent) && obj.hasOwnProperty(key)) {\n\t            delete parent[key];\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\t\n\texports.remove = _remove;\n\tfunction _values(obj, path) {\n\t    var values = [];\n\t    var target = _get(obj, path);\n\t    if ((0, _utils.isObject)(target)) {\n\t        for (var name in target) {\n\t            if (target.hasOwnProperty(name)) {\n\t                values.push(target[name]);\n\t            }\n\t        }\n\t    }\n\t    return values;\n\t}\n\texports.values = _values;\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ActionEvent = ActionEvent;\n\texports.StateEvent = StateEvent;\n\texports.SystemEvent = SystemEvent;\n\texports.TransitionEvent = TransitionEvent;\n\t// ------------------------------------------------------------------------------------------------\n\t// setup\n\t\n\t/**\n\t * @prop {string}       namespace   The Event namespace; i.e. state or action\n\t * @prop {string}       type        The Event type;      i.e. leave/enter (state) or start/end (action)\n\t * @prop {string}       target      The Event target;    i.e. intro (state), next (action), or * (all states or types)\n\t * @prop {Transition}   transition  The transition which generated the event\n\t */\n\tvar event = {\n\t    // properties\n\t    namespace: null,\n\t    type: null,\n\t    target: null,\n\t    transition: null\n\t};\n\t\n\tfunction initialize(event, namespace, type, target, transition) {\n\t    event.namespace = namespace;\n\t    event.type = type;\n\t    event.target = target;\n\t    event.transition = transition;\n\t}\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// ActionEvent\n\t\n\tfunction ActionEvent(type, target, transition) {\n\t    initialize(this, 'action', type, target, transition);\n\t}\n\tActionEvent.prototype = event;\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// StateEvent\n\t\n\tfunction StateEvent(type, target, transition) {\n\t    initialize(this, 'state', type, target, transition);\n\t}\n\tStateEvent.prototype = event;\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// SystemEvent\n\t\n\tfunction SystemEvent(type, value) {\n\t    this.type = type;\n\t    this.value = value;\n\t}\n\t\n\tSystemEvent.prototype = {\n\t    namespace: 'system',\n\t    type: '',\n\t    value: null\n\t};\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// TransitionEvent\n\t\n\tfunction TransitionEvent(type) {\n\t    this.type = type;\n\t}\n\t\n\tTransitionEvent.prototype = {\n\t    namespace: 'transition',\n\t    type: ''\n\t};\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = parse;\n\t\n\tvar _HandlerMeta = __webpack_require__(12);\n\t\n\tvar _HandlerMeta2 = _interopRequireDefault(_HandlerMeta);\n\t\n\tvar _Lexer = __webpack_require__(13);\n\t\n\tvar _Lexer2 = _interopRequireDefault(_Lexer);\n\t\n\tvar _utils = __webpack_require__(3);\n\t\n\tvar _errors = __webpack_require__(16);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// functions\n\t\n\tfunction isSystem(token) {\n\t    return (/^(start|change|complete|reset)$/.test(token)\n\t    );\n\t}\n\t\n\tfunction isTransition(token) {\n\t    return (/^(pause|resume|cancel)$/.test(token)\n\t    );\n\t}\n\t\n\tfunction expandGroups(input) {\n\t    var rx = /\\((.+?)\\)/;\n\t    var matches = input.match(rx);\n\t    if (matches) {\n\t        var group = matches[0];\n\t        var items = matches[1].match(/\\S+/g);\n\t        if (items) {\n\t            items = items.map(function (item) {\n\t                return input.replace(group, item);\n\t            });\n\t            if (rx.test(items[0])) {\n\t                return items.reduce(function (output, input) {\n\t                    return output.concat(expandGroups(input));\n\t                }, []);\n\t            }\n\t            return items;\n\t        }\n\t    }\n\t    return [input];\n\t}\n\t\n\tfunction addPath(path, namespace, target) {\n\t    results.push(new _HandlerMeta2.default(_id, path, namespace, target));\n\t    return true;\n\t}\n\t\n\tfunction addError(message, path) {\n\t    var error = new _errors.ParseError(message, path, _id);\n\t    results.push(error);\n\t    return false;\n\t}\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// export\n\t\n\t/**\n\t * Parses event handler id into a HandlerMeta results containing handler paths\n\t *\n\t * @param   {string}    id          The handler id to parse, i.e. '@next', 'intro:end', 'change', etc\n\t * @param   {Object}    defaults     A StateMachine instance to test for states and actions\n\t * @return  {HandlerMeta[]}\n\t */\n\tfunction parse(id, defaults) {\n\t    // pre-parse handler\n\t    id = (0, _utils.trim)(id);\n\t\n\t    // objects\n\t    _id = id;\n\t    _defaults = defaults;\n\t    results = [];\n\t\n\t    // parse\n\t    parser.parse(id, defaults);\n\t\n\t    // return\n\t    return results;\n\t}\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// objects\n\t\n\tvar results = void 0,\n\t    _defaults = void 0,\n\t    _id = void 0;\n\t\n\tvar patterns = {\n\t    // start pause intro\n\t    alias: /^(\\w+)$/,\n\t\n\t    // system.start state.add\n\t    namespaced: /^(system|transition|state|action)\\.(\\w+)$/,\n\t\n\t    // @next @quit\n\t    oneAction: /^@(\\w+)$/,\n\t\n\t    // @next:start @next:end\n\t    oneActionEvent: /^@(\\w+):(start|end)$/,\n\t\n\t    // :start :end\n\t    anyActionEvent: /^:(start|end)$/,\n\t\n\t    // intro form\n\t    oneState: /^#(\\w+)$/,\n\t\n\t    // intro:enter intro:leave\n\t    oneStateEvent: /^#?(\\w+):(leave|enter)$/,\n\t\n\t    // :enter :leave\n\t    anyStateEvent: /^:(enter|leave)$/,\n\t\n\t    // intro@next\n\t    oneStateAction: /^#?(\\w+)@(\\w+)$/\n\t};\n\t\n\tvar lexer = new _Lexer2.default(patterns);\n\t\n\tvar parser = {\n\t    /**\n\t     * Parses event handler id into HandlerMeta instance\n\t     *\n\t     * Resolving namespace, type and target properties\n\t     *\n\t     * @param   {string}        id\n\t     * @param   {Object}        defaults\n\t     */\n\t    parse: function parse(id, defaults) {\n\t        var _this = this;\n\t\n\t        // expand groups\n\t        var paths = expandGroups(id);\n\t\n\t        // process paths\n\t        paths.map(function (path) {\n\t            return _this.parsePath(path);\n\t        });\n\t    },\n\t\n\t\n\t    parsePath: function parsePath(path) {\n\t        var tokens = void 0;\n\t        try {\n\t            tokens = lexer.process(path);\n\t        } catch (error) {\n\t            return addError('Unrecognised pattern \"' + path + '\"', path);\n\t        }\n\t\n\t        if (tokens && tokens.length) {\n\t            // variables\n\t            var token = tokens.shift();\n\t            var fn = this[token.type];\n\t\n\t            // process\n\t            if (fn) {\n\t                return fn.apply(this, token.values);\n\t            }\n\t            return addError('Unknown token type \"' + token.type + '\"', path);\n\t        }\n\t    },\n\t\n\t    alias: function alias(value) {\n\t        if (isSystem(value)) {\n\t            return addPath('system.' + value, 'system');\n\t        }\n\t        if (isTransition(value)) {\n\t            return addPath('transition.' + value, 'transition');\n\t        }\n\t        return this.oneState(value);\n\t    },\n\t    namespaced: function namespaced(namespace, type) {\n\t        var path = namespace + '.' + type;\n\t\n\t        if (namespace === 'system' && isSystem(type) || namespace === 'transition' && isTransition(type)) {\n\t            return addPath(path, namespace);\n\t        }\n\t\n\t        if (/^(state|action)$/.test(namespace) && /^(add|remove)$/.test(type)) {\n\t            return addPath('system.' + path, 'system');\n\t        }\n\t\n\t        addError('Unrecognised type \"' + type + '\" for namespace \"' + namespace + '\"', _id);\n\t    },\n\t    oneState: function oneState(state) {\n\t        return addPath('state.' + state + '.' + _defaults.state, 'state', state);\n\t    },\n\t    oneAction: function oneAction(action) {\n\t        return addPath('action.' + action + '.' + _defaults.action, 'action', action);\n\t    },\n\t    anyActionEvent: function anyActionEvent(event) {\n\t        return addPath('action.*.' + event, 'action', '*');\n\t    },\n\t    oneActionEvent: function oneActionEvent(action, event) {\n\t        return addPath('action.' + action + '.' + event, 'action', action);\n\t    },\n\t    anyStateEvent: function anyStateEvent(event) {\n\t        return addPath('state.*.' + event, 'state', '*');\n\t    },\n\t    oneStateEvent: function oneStateEvent(state, event) {\n\t        return addPath('state.' + state + '.' + event, 'state', state);\n\t    },\n\t    oneStateAction: function oneStateAction(state, action) {\n\t        return addPath('state.' + state + '.' + action, 'state/action', state + '@' + action);\n\t    }\n\t};\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tfunction HandlerMeta(id, path) {\n\t    var namespace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\t    var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\t\n\t    this.id = id;\n\t    this.path = path;\n\t    if (namespace) {\n\t        this.namespace = namespace;\n\t    }\n\t    if (target) {\n\t        this.target = target;\n\t    }\n\t}\n\t\n\tHandlerMeta.prototype = {\n\t    id: '',\n\t    path: '',\n\t    namespace: '',\n\t    target: ''\n\t};\n\t\n\texports.default = HandlerMeta;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = Lexer;\n\t\n\tvar _Rule = __webpack_require__(14);\n\t\n\tvar _Rule2 = _interopRequireDefault(_Rule);\n\t\n\tvar _Token = __webpack_require__(15);\n\t\n\tvar _Token2 = _interopRequireDefault(_Token);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Simple Lexer class\n\t *\n\t * @param   {Object}    rules   A hash of id:RegExp values\n\t * @constructor\n\t */\n\tfunction Lexer(rules) {\n\t    var _this = this;\n\t\n\t    this.rules = [];\n\t    if (rules) {\n\t        Object.keys(rules).map(function (name) {\n\t            return _this.addRule(name, rules[name]);\n\t        });\n\t    }\n\t}\n\t\n\tLexer.prototype = {\n\t    /** @var {String} */\n\t    source: null,\n\t\n\t    /** @var {Rule[]} */\n\t    rules: null,\n\t\n\t    /** @var {Token[]} */\n\t    tokens: null,\n\t\n\t    /** @var {Number} */\n\t    index: 0,\n\t\n\t    /**\n\t     * Process a source string into an array of Tokens based on Rules\n\t     *\n\t     * @param source\n\t     * @returns {Token[]}\n\t     */\n\t    process: function process(source) {\n\t        this.source = source;\n\t        this.tokens = [];\n\t        this.index = 0;\n\t        this.next();\n\t        return this.tokens;\n\t    },\n\t\n\t    /**\n\t     * Adds a new rule\n\t     *\n\t     * @protected\n\t     * @param name\n\t     * @param rx\n\t     */\n\t    addRule: function addRule(name, rx) {\n\t        this.rules.push(new _Rule2.default(name, rx));\n\t    },\n\t\n\t    next: function next() {\n\t        var _this2 = this;\n\t\n\t        if (this.index < this.source.length) {\n\t            (function () {\n\t                var source = _this2.source.substr(_this2.index);\n\t                var state = _this2.rules.some(function (rule) {\n\t                    var matches = source.match(rule.rx);\n\t                    if (matches) {\n\t                        _this2.tokens.push(new _Token2.default(rule.name, matches));\n\t                        _this2.index += matches[0].length;\n\t                        return true;\n\t                    }\n\t                    return false;\n\t                });\n\t\n\t                // not matched\n\t                if (!state) {\n\t                    throw new LexerError('Unable to match source at position ' + _this2.index + ': \"' + source + '\"', _this2.source, _this2.index);\n\t                }\n\t\n\t                // match\n\t                _this2.next();\n\t            })();\n\t        }\n\t    }\n\t};\n\t\n\tfunction LexerError(message, source, index) {\n\t    this.message = message;\n\t    this.source = source;\n\t    this.index = index;\n\t}\n\t\n\tLexerError.prototype = new Error();\n\tLexerError.prototype.constructor = LexerError;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * A parsing rule, designed to match part of a string\n\t *\n\t * @param   {string}    name\n\t * @param   {RegExp}    rx\n\t */\n\tfunction Rule(name, rx) {\n\t  this.name = name;\n\t  this.rx = rx;\n\t}\n\t\n\texports.default = Rule;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * Token class, representing the type and value of part of a source string\n\t *\n\t * @param       {string}    type\n\t * @param       {string[]}  matches\n\t *\n\t * @property    {string}    type\n\t * @property    {string}    match\n\t * @property    {string[]}  values\n\t */\n\tfunction Token(type, matches) {\n\t  this.type = type;\n\t  this.match = matches[0];\n\t  this.values = matches.slice(1);\n\t}\n\t\n\texports.default = Token;\n\n/***/ },\n/* 16 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ParseError = ParseError;\n\tfunction ParseError(message, path, id) {\n\t    this.message = message;\n\t    this.path = path;\n\t    this.id = id;\n\t}\n\t\n\tParseError.prototype = Error.prototype;\n\tParseError.prototype.name = 'ParseError';\n\tParseError.prototype.constructor = ParseError;\n\n/***/ },\n/* 17 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _ValueMap = __webpack_require__(9);\n\t\n\tvar _ValueMap2 = _interopRequireDefault(_ValueMap);\n\t\n\tvar _TransitionParser = __webpack_require__(18);\n\t\n\tvar _TransitionParser2 = _interopRequireDefault(_TransitionParser);\n\t\n\tvar _utils = __webpack_require__(3);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction TransitionMap() {\n\t    this.map = new _ValueMap2.default();\n\t    this.states = [];\n\t    this.actions = [];\n\t}\n\t\n\tTransitionMap.prototype = {\n\t    // ------------------------------------------------------------------------------------------------\n\t    // properties\n\t\n\t    map: null,\n\t    states: null,\n\t    actions: null,\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // add and remove states\n\t\n\t    /**\n\t     * Add event handler parsing\n\t     *\n\t     * @param   {string}    tx\n\t     * @returns {TransitionMeta[]}\n\t     */\n\t    parse: function parse(tx) {\n\t        return (0, _TransitionParser2.default)(tx);\n\t    },\n\t\n\t    /**\n\t     * Adds a new transition\n\t     * \n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @returns {TransitionMap}\n\t     */\n\t    add: function add(action, from, to) {\n\t        // procss variables\n\t        action = (0, _utils.trim)(action);\n\t        from = (0, _utils.trim)(from);\n\t        to = typeof to === 'string' ? (0, _utils.trim)(to) : to;\n\t\n\t        // check for wildcards\n\t        if (to === '*') {\n\t            throw new Error('Transitioning to a wildcard doesn\\'t make sense');\n\t        }\n\t\n\t        // add transition\n\t        this.map.set(from + '.' + action, to);\n\t        return update(this);\n\t    },\n\t\n\t    /**\n\t     * Removes an existing state\n\t     *\n\t     * @param   {string}    state\n\t     * @returns {TransitionMap}\n\t     */\n\t    remove: function remove(state) {\n\t        // remove \"from\" state\n\t        this.map.remove(state);\n\t\n\t        // remove \"to\" states\n\t        var data = this.map.data;\n\t        for (var name in data) {\n\t            var from = data[name];\n\t            for (var action in from) {\n\t                if (from[action] === state) {\n\t                    delete from[action];\n\t                }\n\t            }\n\t        }\n\t\n\t        // update and return\n\t        return update(this);\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // accessors\n\t\n\t    /**\n\t     * Get all available actions (or action => states map) for a given state\n\t     *\n\t     * @param   {string}    from        Name of a state to get actions for\n\t     * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n\t     * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n\t     */\n\t    getActionsFrom: function getActionsFrom(from) {\n\t        var asMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        if (this.has(from) || this.has('*')) {\n\t            // get all available actions\n\t            var actions = this.map.get(from) || {};\n\t            var wildcard = this.map.get('*');\n\t            var output = Object.assign({}, actions);\n\t\n\t            // append wildcard actions\n\t            if (wildcard) {\n\t                for (var action in wildcard) {\n\t                    var value = wildcard[action];\n\t                    if (value !== from && !actions[action]) {\n\t                        output[action] = value;\n\t                    }\n\t                }\n\t            }\n\t\n\t            // return map or keys\n\t            return output ? asMap ? output : Object.keys(output) : [];\n\t        }\n\t        return [];\n\t    },\n\t\n\t    /**\n\t     * Get the first available action to move from one state to another (if there is one)\n\t     *\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @return  {string|null}\n\t     */\n\t    getActionFor: function getActionFor(from, to) {\n\t        var actions = this.map.get(from);\n\t        for (var action in actions) {\n\t            if (actions[action] === to) {\n\t                return action;\n\t            }\n\t        }\n\t        return null;\n\t    },\n\t\n\t    /**\n\t     * Get all available \"to\" states for a given state\n\t     *\n\t     * Loops over all actions and returns a unique array of \"to\" states\n\t     *\n\t     * @param   {string|null}    [from]     Optional name of a from state to get states for. Defaults to the current state\n\t     * @returns {string[]}                  An array of string states\n\t     */\n\t    getStatesFrom: function getStatesFrom(from) {\n\t        var _this = this;\n\t\n\t        if (this.hasState(from)) {\n\t            var _ret = function () {\n\t                var actions = _this.getActionsFrom(from, true);\n\t                return {\n\t                    v: Object.keys(actions).map(function (name) {\n\t                        return actions[name];\n\t                    })\n\t                };\n\t            }();\n\t\n\t            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t        }\n\t        return null;\n\t    },\n\t\n\t    /**\n\t     * Get the target \"to\" state from a \"from\" state via an \"action\"\n\t     *\n\t     * @param   {string}    from\n\t     * @param   {string}    action\n\t     * @returns {string}\n\t     */\n\t    getStateFor: function getStateFor(from, action) {\n\t        var states = this.getActionsFrom(from, true) || {};\n\t        return states[action];\n\t    },\n\t\n\t    /**\n\t     * Get all states within the system\n\t     *\n\t     * @return  {string[]}\n\t     */\n\t    getStates: function getStates() {\n\t        return [].concat(this.states);\n\t    },\n\t\n\t    /**\n\t     * Get all actions within the system\n\t     *\n\t     * @return  {string[]}\n\t     */\n\t    getActions: function getActions() {\n\t        return [].concat(this.actions);\n\t    },\n\t\n\t    /**\n\t     * General getter\n\t     *\n\t     * @param   {string}    path\n\t     * @return  {*}\n\t     */\n\t    get: function get() {\n\t        for (var _len = arguments.length, path = Array(_len), _key = 0; _key < _len; _key++) {\n\t            path[_key] = arguments[_key];\n\t        }\n\t\n\t        path = [].concat(_toConsumableArray(path)).join('.');\n\t        return this.map.get(path);\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // checks\n\t\n\t    /**\n\t     * Test if the given state exists within the system\n\t     *\n\t     * @param   {string}    state\n\t     * @returns {boolean}\n\t     */\n\t    hasState: function hasState(state) {\n\t        return this.states.indexOf(state) !== -1;\n\t    },\n\t\n\t    /**\n\t     * Test if the given action exists within the system\n\t     *\n\t     * @param   {string}    action\n\t     * @returns {boolean}\n\t     */\n\t    hasAction: function hasAction(action) {\n\t        return this.actions.indexOf(action) !== -1;\n\t    },\n\t\n\t    /**\n\t     * Test if the given transition exists within the system\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @returns {boolean}\n\t     */\n\t    hasTransition: function hasTransition(action, from, to) {\n\t        return this.map.get(from + '.' + action) === to;\n\t    },\n\t\n\t    /**\n\t     * Utility function to directly check if the composed ValueMap has the requested path\n\t     *\n\t     * Note this does NOT take into account the value of the target object; use hasTransition() for that\n\t     *\n\t     * @param   {string}    path    Pass a path using dot notation, i.e. 'a.next' or pass individual arguments, i.e. from, action, to\n\t     * @returns {boolean}\n\t     */\n\t    has: function has() {\n\t        for (var _len2 = arguments.length, path = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t            path[_key2] = arguments[_key2];\n\t        }\n\t\n\t        path = [].concat(_toConsumableArray(path)).join('.');\n\t        return !!path ? this.map.has(path) : false;\n\t    }\n\t\n\t};\n\t\n\tTransitionMap.prototype.constructor = TransitionMap;\n\t\n\t/**\n\t * Private utility function to update existing states and actions\n\t *\n\t * @param   {TransitionMap} target\n\t * @returns {TransitionMap}\n\t */\n\tfunction update(target) {\n\t    // variables\n\t    var actions = {};\n\t    var states = {};\n\t    var data = target.map.data;\n\t    var to;\n\t\n\t    // collate from states\n\t    for (var from in data) {\n\t        states[from] = true;\n\t        for (var action in data[from]) {\n\t            actions[action] = true;\n\t            to = data[from][action];\n\t            if (typeof to !== 'function') {\n\t                states[to] = true;\n\t            }\n\t        }\n\t    }\n\t\n\t    // update\n\t    target.states = Object.keys(states).filter(function (state) {\n\t        return state !== '*';\n\t    });\n\t    target.actions = Object.keys(actions);\n\t\n\t    // return\n\t    return target;\n\t}\n\t\n\texports.default = TransitionMap;\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.default = parse;\n\t\n\tvar _utils = __webpack_require__(3);\n\t\n\tvar _errors = __webpack_require__(16);\n\t\n\tvar _TransitionMeta = __webpack_require__(19);\n\t\n\tvar _TransitionMeta2 = _interopRequireDefault(_TransitionMeta);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// functions\n\t\n\tfunction getError(tx, message) {\n\t    return 'Invalid transition shorthand pattern \"' + tx + '\" - ' + message;\n\t}\n\t\n\tfunction add(transitions, action, from, to) {\n\t    transitions.push(new _TransitionMeta2.default(action, from, to));\n\t}\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// export\n\t\n\t/**\n\t * Parses/expands transition objects/strings into discrete transitions\n\t *\n\t * @returns {TransitionMeta[]}  An array of TransitionMeta instances\n\t */\n\tfunction parse(tx) {\n\t    if ((0, _utils.isString)(tx)) {\n\t        var _ret = function () {\n\t            // pre-process string\n\t            tx = tx.replace(/([|=:<>])/g, ' $1 ').replace(/\\s+/g, ' ').replace(/^\\s+|\\s+$/g, '');\n\t\n\t            // ensure string is valid\n\t            if (!/^\\w+ [:|=] [*\\w][\\w ]*[<>] [*\\w][\\w ]*/.test(tx)) {\n\t                throw new _errors.ParseError(getError(tx, 'cannot determine action and states'));\n\t            }\n\t\n\t            // initialize variables\n\t            var transitions = [],\n\t                matches = tx.match(/([*\\w ]+|[<>])/g),\n\t                action = matches.shift().replace(/\\s+/g, ''),\n\t                stack = [],\n\t                match = '',\n\t                op = '',\n\t                a = '',\n\t                b = '';\n\t\n\t            // process states\n\t            while (matches.length) {\n\t                // get the next match\n\t                match = matches.shift();\n\t                if (/[<>]/.test(match)) {\n\t                    op = match;\n\t                } else {\n\t                    match = match.match(/[*\\w]+/g);\n\t                    match = match.length === 1 ? match[0] : match;\n\t                    stack.push(match);\n\t                }\n\t\n\t                // process matches if stack is full\n\t                if (stack.length === 2) {\n\t                    var _ref = op === '<' ? [stack[1], stack[0]] : stack;\n\t\n\t                    var _ref2 = _slicedToArray(_ref, 2);\n\t\n\t                    a = _ref2[0];\n\t                    b = _ref2[1];\n\t\n\t                    if (Array.isArray(a) && Array.isArray(b)) {\n\t                        throw new _errors.ParseError(getError(tx, 'transitioning between 2 arrays doesn\\'t make sense'));\n\t                    }\n\t                    if (b === '*') {\n\t                        throw new _errors.ParseError(getError(tx, 'transitioning to a wildcard doesn\\'t make sense'));\n\t                    }\n\t                    if (Array.isArray(a)) {\n\t                        a.map(function (a) {\n\t                            return add(transitions, action, a, b);\n\t                        });\n\t                    } else if (Array.isArray(b)) {\n\t                        b.map(function (b) {\n\t                            return add(transitions, action, a, b);\n\t                        });\n\t                    } else {\n\t                        add(transitions, action, a, b);\n\t                    }\n\t\n\t                    // discard original match once processed\n\t                    stack.shift();\n\t                }\n\t            }\n\t\n\t            // return\n\t            return {\n\t                v: transitions\n\t            };\n\t        }();\n\t\n\t        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t    }\n\t\n\t    // return objects wrapped in an array\n\t    return [tx];\n\t}\n\n/***/ },\n/* 19 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tfunction TransitionMeta(action, from, to) {\n\t    this.action = action;\n\t    this.from = from;\n\t    this.to = to;\n\t}\n\t\n\texports.default = TransitionMeta;\n\n/***/ },\n/* 20 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _events = __webpack_require__(10);\n\t\n\tvar _utils = __webpack_require__(3);\n\t\n\t/**\n\t * Transition class\n\t *\n\t * Responsible for managing events in the flow from state to state.\n\t *\n\t * This adds all handlers for the current action start/end and state from/to to an array:\n\t *\n\t * - <namespace>.<target>.<type>[]\n\t *\n\t * So going from state \"a\" to state \"b\" with action \"next\" should build:\n\t *\n\t * - action.*.start[]\n\t * - action.next.start[]\n\t * - state.a.leave[]\n\t * - state.*.leave[]\n\t * - state.*.enter[]\n\t * - state.b.enter[]\n\t * - action.next.end[]\n\t * - action.*.end[]\n\t *\n\t * This can be changed by passing in an order array in fsm.config\n\t *\n\t * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n\t *\n\t * From a callback, you can:\n\t *\n\t * - return false to cancel the transition\n\t * - return true to pause the transition\n\t * - not return a value (the transition continues)\n\t *\n\t * TransitionMap can also be paused, resumed, or cancelled by calling\n\t * the appropriate method on, or from:\n\t *\n\t * - the event\n\t * - the transition\n\t * - the state machine\n\t *\n\t * Cancelled transitions will reset the FSM to the previous \"from\" state\n\t *\n\t * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          action\n\t * @param {string}          from\n\t * @param {string}          to\n\t */\n\tfunction Transition(fsm, action, from, to) {\n\t    this.fsm = fsm;\n\t    this.action = action;\n\t    this.from = from;\n\t    this.to = to;\n\t    this.clear();\n\t}\n\t\n\t/**\n\t * @prop {StateMachine}    fsm\n\t * @prop {string}          action\n\t * @prop {string}          from\n\t * @prop {string}          to\n\t * @prop {Function[]}      handlers\n\t */\n\tTransition.prototype = {\n\t    fsm: null,\n\t    action: '',\n\t    from: '',\n\t    to: '',\n\t    paused: false,\n\t    handlers: null,\n\t\n\t    clear: function clear() {\n\t        unpause(this);\n\t        this.handlers = [];\n\t    },\n\t\n\t    /**\n\t     * Execute the next event's callbacks\n\t     * @returns {*}\n\t     */\n\t    exec: function exec() {\n\t        if (!this.paused) {\n\t            if (this.handlers.length) {\n\t                var handler = this.handlers.shift();\n\t                var state = handler();\n\t                if (state === false) {\n\t                    return this.fsm.cancel();\n\t                }\n\t                if (state === true) {\n\t                    return this.fsm.pause();\n\t                }\n\t                this.exec();\n\t            } else {\n\t                this.fsm.end();\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t\n\t    pause: function pause() {\n\t        _pause(this);\n\t        return this;\n\t    },\n\t\n\t    resume: function resume() {\n\t        unpause(this);\n\t        return this.exec();\n\t    },\n\t\n\t    cancel: function cancel() {\n\t        this.paused = false;;\n\t        this.fsm.handlers.trigger('transition.cancel', false);\n\t    }\n\t\n\t};\n\t\n\tfunction _pause(transition) {\n\t    if (!transition.paused) {\n\t        transition.paused = true;\n\t        transition.fsm.handlers.trigger('transition.pause', true);\n\t    }\n\t}\n\t\n\tfunction unpause(transition) {\n\t    if (transition.paused) {\n\t        transition.paused = false;\n\t        transition.fsm.handlers.trigger('transition.resume', false);\n\t    }\n\t}\n\t\n\texports.default = {\n\t    /**\n\t     * Create the Transition object\n\t     *\n\t     * - Set up variables, and queue\n\t     * - Determine paths to relevant handlers\n\t     * - Build State and Action Event objects\n\t     * - Pre-bind all handlers\n\t     * - Append to queue\n\t     *\n\t     * @param {StateMachine}    fsm\n\t     * @param {string}          action\n\t     * @param {Array}           params\n\t     * @returns {Transition}\n\t     */\n\t    create: function create(fsm, action, params) {\n\t        // transition properties\n\t        var scope = fsm.config.scope;\n\t        var from = fsm.state;\n\t        var to = fsm.transitions.getStateFor(from, action);\n\t        var vars = { action: action, to: to, from: from };\n\t\n\t        // handle \"to\" being a function\n\t        if ((0, _utils.isFunction)(to)) {\n\t            to = to.apply(scope, params);\n\t            if (!fsm.transitions.hasState(to)) {\n\t                throw new Error('Invalid \"to\" state \"' + to + '\"');\n\t            }\n\t        }\n\t\n\t        // transition\n\t        var queue = [];\n\t        var transition = new Transition(fsm, action, from, to);\n\t\n\t        // build handlers array\n\t        fsm.config.order.map(function (path) {\n\t            // replace path tokens\n\t            path = path.replace(/{(\\w+)}/g, function (all, token) {\n\t                return vars[token];\n\t            });\n\t            var handlers = fsm.handlers.get(path);\n\t\n\t            // do it!\n\t            if (handlers) {\n\t                (function () {\n\t                    var _path$split = path.split('.');\n\t\n\t                    var _path$split2 = _slicedToArray(_path$split, 3);\n\t\n\t                    var namespace = _path$split2[0];\n\t                    var target = _path$split2[1];\n\t                    var type = _path$split2[2];\n\t\n\t                    handlers = handlers.map(function (handler) {\n\t                        // build event object\n\t                        var Event = namespace === 'state' ? _events.StateEvent : _events.ActionEvent;\n\t                        var event = new Event(type, target, transition);\n\t\n\t                        // pre-bind handlers, scopes and params\n\t                        // this way scope and params don't need to be passed around\n\t                        // and the call from Transition is always just `value = handler()`\n\t                        return function () {\n\t                            return handler.apply(scope, [event, fsm].concat(params));\n\t                        };\n\t                    });\n\t\n\t                    // add to queue\n\t                    queue = queue.concat(handlers);\n\t                })();\n\t            }\n\t        });\n\t\n\t        // return\n\t        transition.handlers = queue;\n\t        return transition;\n\t    },\n\t\n\t    force: function force(fsm, state) {\n\t        var transition = new Transition(fsm, '', fsm.state, state);\n\t        transition.paused = fsm.transition ? fsm.transition.paused : false;\n\t        return transition;\n\t    }\n\t\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** StateMachine.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 78f0aec4264f3a0fa36c\n **/","export function isObject (value)\n{\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport function isArray (value)\n{\n    return value instanceof Array;\n}\n\nexport function isString (value)\n{\n    return typeof value === 'string';\n}\n\nexport function isFunction(value)\n{\n    return value instanceof Function;\n}\n\nexport function isDefined (value)\n{\n    return typeof value !== 'undefined';\n}\n\nexport function isUndefined (value)\n{\n    return typeof value === 'undefined';\n}\n\nexport function trim (value)\n{\n    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n}\n\nexport function diff (a, b)\n{\n    var da = b.filter( v => a.indexOf(v) < 0 );\n    var db = a.filter( v => b.indexOf(v) < 0 );\n    return db.concat(da)\n}\n\nexport function toHash(values) {\n    return values.reduce(function (obj, value) {\n        obj[value] = true;\n        return obj;\n    }, {})\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/utils/utils.js\n **/","import Config from './core/classes/Config';\nimport HandlerMap from './core/maps/HandlerMap';\nimport TransitionMap from './core/maps/TransitionMap';\nimport Transition from './core/classes/Transition';\nimport { diff } from './core/utils/utils';\n\n\n/**\n * StateMachine constructor\n *\n * @param   {Object|null}    options\n * @constructor\n */\nfunction StateMachine (options)\n{\n    this.transitions    = new TransitionMap();\n    this.handlers       = new HandlerMap(this);\n    this.initialize(options);\n}\n\n/**\n * StateMachine prototype\n *\n * The property examples below illustrate a 4-state machine, with states:\n *\n * - intro > settings > summary > end\n *\n * And actions:\n *\n * - back | next | restart | finish\n */\nStateMachine.prototype =\n{\n    // -----------------------------------------------------------------------------------------------------------------\n    // properties\n\n        /**\n         * Configuration object\n         *\n         * @var {Config}\n         */\n        config      : null,\n\n        /**\n         * Map of all transitions\n         *\n         * @var {TransitionMap}\n         */\n        transitions : null,\n\n        /**\n         * Map of all handlers\n         *\n         * @var {HandlerMap}\n         */\n        handlers    : null,\n\n        /**\n         * Any active Transition object that is driving the state change\n         *\n         * @var {Transition}\n         */\n        transition  : null,\n\n        /**\n         * The current state\n         *\n         * @var {string}\n         */\n        state       : '',\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // private methods\n\n        /**\n         * Initialize the FSM with options\n         *\n         * @private\n         * @param options\n         */\n        initialize:function (options)\n        {\n            // state\n            this.state          = '';\n\n            // build config\n            let config  = new Config(options);\n            this.config = config;\n\n            // pre-process all transitions\n            let transitions = [];\n            if(Array.isArray(options.transitions))\n            {\n                options.transitions.map( tx =>\n                {\n                    transitions = transitions.concat(this.transitions.parse(tx));\n                });\n            }\n\n            // add transitions\n            transitions.map( transition =>\n            {\n                this.transitions.add(transition.action, transition.from, transition.to);\n            });\n\n            // get initial state (must be done after state collation)\n            if( ! config.initial )\n            {\n                config.initial = this.transitions.getStates()[0];\n            }\n\n            // add handlers\n            if(options.handlers)\n            {\n                for(let name in options.handlers)\n                {\n                    if(options.handlers.hasOwnProperty(name))\n                    {\n                        this.on(name, options.handlers[name]);\n                    }\n                }\n            }\n\n            // add methods\n            if(options.methods)\n            {\n                if(!this.config.scope)\n                {\n                    this.config.scope = this;\n                }\n                for(var name in options.methods)\n                {\n                    if(options.methods.hasOwnProperty(name) && !this.hasOwnProperty(name))\n                    {\n                        this[name] = options.methods[name];\n                    }\n                }\n            }\n\n            // start\n            if(this.config.start)\n            {\n                this.start();\n            }\n\n            // return\n            return this;\n        },\n\n        start: function ()\n        {\n            this.state = this.config.initial;\n            this.handlers.trigger('system.start');\n            if(this.state)\n            {\n                this.handlers.trigger('system.change', this.state);\n            }\n            return this;\n        },\n\n        /**\n         * Reset the FSM to the initial, or supplied, state\n         *\n         * @returns {StateMachine}\n         */\n        reset:function(initial = '')\n        {\n            let state = initial || this.config.initial;\n            this.handlers.trigger('system.reset');\n            if(this.transition)\n            {\n                this.transition.cancel();\n                delete this.transition;\n            }\n            if(this.state !== state)\n            {\n                this.state = state;\n                this.handlers.trigger('system.change', this.state);\n            }\n            return this;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // api\n\n        /**\n         * Attempt to run an action, resulting in a transition to a state\n         *\n         * @param   {string}    action\n         * @param   {*[]}       rest\n         * @returns {boolean}\n         */\n        do: function (action, ...rest)\n        {\n            if(this.canDo(action) && !this.isPaused())\n            {\n                this.transition = Transition.create(this, action, rest);\n                this.transition.exec();\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Attempt to go to a state\n         *\n         * Queries TransitionMap instance to see if a transition exists, then calls the related action if it does\n         *\n         * @param   {string}    state\n         * @param   {boolean}   [force]\n         * @returns {boolean}\n         */\n        go: function (state, force = false)\n        {\n            if(this.has(state))\n            {\n                if(force)\n                {\n                    if(this.transition)\n                    {\n                        this.transition.clear();\n                    }\n                    this.transition = Transition.force(this, state);\n                    return this.end();\n                }\n                var action = this.transitions.getActionFor(this.state, state);\n                if(action)\n                {\n                    return this.do(action);\n                }\n                this.config.errors > 0 && console.warn('No transition exists from \"%s\" to \"%s\"', this.state, state);\n                return false;\n            }\n            this.config.errors > 0 && console.warn('No such state \"%s\"', state);\n            return false;\n        },\n\n        /**\n         * Query transition map to see if a named action is available\n         *\n         * @param   {string}        action\n         * @returns {boolean}\n         */\n        canDo: function (action)\n        {\n            return this.transitions.getActionsFrom(this.state).indexOf(action) !== -1;\n        },\n\n        /**\n         * Query transition map to see if a state is available to go to\n         *\n         * @param to\n         * @return {boolean}\n         */\n        canGo: function (to)\n        {\n            return this.transitions.getActionFor(this.state, to) !== null;\n        },\n\n        /**\n         * Test if a state exists\n         *\n         * @param   {string}    state\n         * @return  {boolean}\n         */\n        has: function(state)\n        {\n            return this.transitions.hasState(state);\n        },\n\n        /**\n         * Test if the current state is the same as the supplied one\n         *\n         * @param   {string}    state       A state name to compare against the current state\n         * @returns {boolean}\n         */\n        is: function (state)\n        {\n            return state === this.state;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // flags\n\n        /**\n         * Test if the FSM has started\n         *\n         * @returns {boolean}\n         */\n        isStarted: function ()\n        {\n            return this.state !== '';\n        },\n\n        /**\n         * Test if the FSM is transitioning\n         *\n         * @returns {boolean}\n         */\n        isTransitioning: function ()\n        {\n            return !! this.transition;\n        },\n\n        /**\n         * Test if the FSM is paused (whilst transitioning)\n         *\n         * @returns {boolean}\n         */\n        isPaused: function ()\n        {\n            return this.transition\n                ? this.transition.paused\n                : false;\n        },\n\n        /**\n         * Test if the FSM is on the \"final\" state\n         *\n         * @returns {boolean}\n         */\n        isComplete: function ()\n        {\n            return this.state === this.config.final;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // transitions\n\n        /**\n         * Pause any current transition\n         *\n         * @returns {StateMachine}\n         */\n        pause: function ()\n        {\n            if(this.transition && !this.isPaused())\n            {\n                this.transition.pause();\n            }\n            return this;\n        },\n\n        /**\n         * Resume any current transition\n         *\n         * @returns {StateMachine}\n         */\n        resume: function ()\n        {\n            if(this.transition && this.isPaused())\n            {\n                this.transition.resume();\n            }\n            return this;\n        },\n\n        /**\n         * Cancel any current transition\n         *\n         * @returns {StateMachine}\n         */\n        cancel: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.from;\n                this.transition.cancel();\n                delete this.transition;\n            }\n            return this;\n        },\n\n        /**\n         * End any current transition, skipping remaining handlers\n         *\n         * @returns {StateMachine}\n         */\n        end: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.to;\n                this.transition.clear();\n                delete this.transition;\n                this.handlers.trigger('system.change', this.state);\n                if(this.isComplete())\n                {\n                    this.handlers.trigger('system.complete');\n                }\n            }\n            return this;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // actions\n\n        /**\n         * Add a transition\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        add: function (action, from, to)\n        {\n            // 1 argument: shorthand transition, i.e 'next : a > b'\n            if(arguments.length === 1)\n            {\n                var transitions = this.transitions.parse(action);\n                transitions.map( tx => this.add(tx.action, tx.from, tx.to));\n                return this;\n            }\n\n            // 3 arguments: longhand transition\n            updateTransitions(this, 'add', () => this.transitions.add(action, from, to) );\n            return this;\n        },\n\n        /**\n         * Remove a state\n         *\n         * @param   {string}    state\n         * @return  {StateMachine}\n         */\n        remove: function (state)\n        {\n            this.handlers.remove('state.' + state);\n            updateTransitions(this, 'remove', () => this.transitions.remove(state) );\n            return this;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // handlers\n\n        /**\n         * Add an event handler\n         *\n         * Event handler signatures are built from the following grammar:\n         *\n         * - token      foo\n         * - property   .foo\n         * - event      :foo\n         * - action     @foo\n         * - targets    (foo bar baz)\n         *\n         * For example:\n         *\n         * - change\n         * - transition.pause\n         * - next:end\n         * - (a b)@next\n         * - a@next\n         *\n         * The main event types are unique, so can be used without the namespace:\n         *\n         * - change\n         * - pause\n         * - complete\n         * - ...\n         *\n         * If your states and events are unique, they can also be used without qualification.\n         *\n         * See docs and demo for more information\n         *\n         * @param   {string}        id\n         * @param   {Function}      fn\n         * @return  {StateMachine}\n         */\n        on: function (id, fn)\n        {\n            this.parse(id, this.config.invalid, this.config.errors)\n                .forEach( meta => this.handlers.add(meta.path, fn) );\n            return this;\n        },\n\n        off: function (id, fn)\n        {\n            this.parse(id, this.config.invalid, this.config.errors)\n                .forEach( meta => this.handlers.remove(meta.path, fn) );\n            return this;\n        },\n\n    \n    // -----------------------------------------------------------------------------------------------------------------\n    // utilities\n\n        /**\n         * Parses a handler id string into HandlerMeta objects\n         *\n         * @param   {string}    id\n         * @param   {boolean}   invalid\n         * @param   {number}    errors\n         * @returns {HandlerMeta[]}\n         */\n        parse: function (id, invalid = false, errors = 0)\n        {\n            return this.handlers.parse(id).filter(result =>\n            {\n                // picks up unrecognised handlers, namespaces, etc\n                if(result instanceof Error)\n                {\n                    if(errors == 2)\n                    {\n                        throw result;\n                    }\n                    errors == 1 && console.warn(result.message);\n                    return false;\n                }\n\n                // picks up unrecognised states and actions\n                if(result.target !== '*')\n                {\n                    let error = '';\n\n                    if(result.namespace === 'state')\n                    {\n                        if(!this.transitions.hasState(result.target))\n                        {\n                            error = 'Unrecognised state \"' +result.target+ '\" in handler \"' +result.id+ '\"';\n                        }\n                    }\n                    else if(result.namespace === 'action')\n                    {\n                        if(!this.transitions.hasAction(result.target))\n                        {\n                            error = 'Unrecognised action \"' +result.target+ '\" in handler \"' +result.id+ '\"';\n                        }\n                    }\n                    else if(result.namespace === 'state/action')\n                    {\n                        // variables\n                        let [state, action] = result.target.split('@');\n\n                        // test for state and action\n                        if(!this.transitions.hasState(state))\n                        {\n                            error = 'Unrecognised state \"' +state+ '\" in handler \"' +result.id+ '\"';\n                        }\n                        if(!this.transitions.hasAction(action))\n                        {\n                            error = 'Unrecognised action \"' +action+ '\" in handler \"' +result.id+ '\"';\n                        }\n                    }\n\n                    // if we have an error, the result was not an existing state or action\n                    if(error)\n                    {\n                        if(errors == 2)\n                        {\n                            throw new Error(error);\n                        }\n                        errors == 1 && console.warn(error);\n                        return !!invalid;\n                    }\n                }\n\n                // must be valid\n                return true\n            });\n        },\n\n        trigger: function (id, ...rest)\n        {\n            this.handlers.parse(id).map( meta => this.handlers.trigger.apply(this.handlers, [meta.path, ...rest]) );\n            return this;\n        }\n\n};\n\nStateMachine.prototype.constructor = StateMachine;\n\nexport default StateMachine;\n\n\n// ---------------------------------------------------------------------------------------------------------------------\n// static methods\n\n    /**\n     * Factory method\n     *\n     * @param   options\n     * @returns {StateMachine}\n     */\n    StateMachine.create = function(options)\n    {\n        return new StateMachine(options);\n    };\n\n    /**\n     * Gets the default order events should be called in\n     * @returns {string[]}\n     */\n    StateMachine.getDefaultOrder = function ()\n    {\n        return [\n            'action.*.start',\n            'action.{action}.start',\n            'state.*.{action}',\n            'state.{from}.{action}',\n            'state.{from}.leave',\n            'state.*.leave',\n            'state.*.enter',\n            'state.{to}.enter',\n            'action.{action}.end',\n            'action.*.end'\n        ];\n    };\n\n\n// ---------------------------------------------------------------------------------------------------------------------\n// helper functions\n\n    /**\n     * Utility method to update transitions and dispatch events\n     *\n     * Saves duplicating the following code in both add() and remove() methods\n     *\n     * @param   {StateMachine}  fsm\n     * @param   {string}        method\n     * @param   {Function}      callback\n     */\n    function updateTransitions(fsm, method, callback)\n    {\n        var statesBefore    = fsm.transitions.getStates();\n        var actionsBefore   = fsm.transitions.getActions();\n        callback();\n        var statesAfter     = fsm.transitions.getStates();\n        var actionsAfter    = fsm.transitions.getActions();\n\n        // calculate differences\n        var states          = diff(statesBefore, statesAfter);\n        var actions         = diff(actionsBefore, actionsAfter);\n\n        // dispatch events\n        states.map ( state  => fsm.handlers.trigger('system.state.'  + method, state) );\n        actions.map( action => fsm.handlers.trigger('system.action.' + method, action) );\n    }\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/StateMachine.js\n **/","import StateMachine from '../../StateMachine';\n\nexport default function Config (options)\n{\n    'scope start initial final invalid errors'\n        .match(/\\w+/g)\n        .map( name =>\n        {\n            if(options.hasOwnProperty(name))\n            {\n                this[name] = options[name];\n            }\n        });\n\n    // order\n    this.order      = options.order || StateMachine.getDefaultOrder();\n\n    // defaults\n    this.defaults   = Object.assign({\n\n        // allow user to specify alternate triggers for event and action ids\n        action      :'start',\n        state       :'enter'\n\n    }, options.defaults);\n}\n\nConfig.prototype =\n{\n    /**\n     * An optional scope to run handler functions in\n     *\n     * @var object\n     */\n    scope       : null,\n\n    /**\n     * A boolean to automatically start the state machine in the initial state\n     *\n     * @var boolean\n     */\n    start       : true,\n\n    /**\n     * A string to indicate which state to start on; defaults to ''\n     *\n     * @var string\n     */\n    initial     : '',\n\n    /**\n     * A string indicating the state to trigger a complete event; defaults to ''\n     *\n     * @var string\n     */\n    final       : '',\n\n    /**\n     * A boolean to allow non-existent states and actions to be added to the handlers object; defaults to false (disallow)\n     *\n     * @var boolean\n     */\n    invalid     : false,\n\n    /**\n     * A number indicating how to handle invalid or erroneous actions; defaults to 1 (warn)\n     *\n     *  - 0 : quiet\n     *  - 1 : console.warn()\n     *  - 2 : throw an error\n     *\n     * @var number\n     */\n    errors      : 1,\n\n    /**\n     * The order to run transition callbacks in\n     *\n     * @type {string[]} type.target\n     */\n    order       : null,\n\n    /**\n     * Sets defaults for various declarations\n     *\n     * Available options are:\n     *\n     * - action: (start|end)\n     * - state: (enter|leave)\n     *\n     * @type {Object}\n     */\n    defaults    : null,\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/classes/Config.js\n **/","import ValueMap from './ValueMap';\nimport { SystemEvent, TransitionEvent, StateEvent, ActionEvent } from '../objects/events';\nimport { isFunction } from '../utils/utils';\n\nimport parseHandler from '../parsers/HandlerParser';\n\nfunction HandlerMap (fsm)\n{\n    this.fsm    = fsm;\n    this.map    = new ValueMap();\n}\n\nHandlerMap.prototype =\n{\n\n\tfsm: null,\n\n\tmap: null,\n\n    /**\n     * Parse event handler grammar into a HandlerMeta structure\n     *\n     * @param   {string}        id      The handler id to parse, i.e. '@next', 'intro:end', 'change', etc\n     * @returns {HandlerMeta[]}\n     */\n    parse: function (id)\n    {\n        return parseHandler(id, this.fsm.config.defaults);\n    },\n\n    /**\n     * Directly add a new handler\n     *\n     * @param   {string}    path    A 'namespace.target.type' target path to add a handler to\n     * @param   {Function}  fn      A callback function\n     * @returns {HandlerMap}\n     */\n    add: function (path, fn)\n    {\n        // check handler is a function\n        if(!isFunction(fn))\n        {\n            throw new Error('Error assigning \"' +path+ '\" handler; callback is not a function', fn);\n        }\n\n        this.map.insert(path, fn);\n        return this;\n    },\n\n    /**\n     * Directly remove a handler target\n     *\n     * @param   {string}    path    A 'namespace.target.type' parent to a handler removed from\n     * @param   {Function}  fn      The instance of the callback function\n     * @returns {HandlerMap}\n     */\n    remove: function (path, fn)\n    {\n        this.map.remove(path, fn);\n        return this;\n    },\n\n    /**\n     * Get all handlers for a valid target path\n     *\n     * @param   {string}    path    A 'namespace.target.type' target path\n     * @returns {Function[]}        An array of callback functions\n     */\n    get:function(path)\n    {\n        return this.map.get(path);\n    },\n\n    /**\n     * Dispatch an event\n     *\n     * @param   {string}    path\n     * @param   {*}         value\n     * @returns {StateMachine}\n     */\n    trigger: function (path, value = null)\n    {\n        // create lookup path\n        let [namespace, type, method] = path.match(/\\w+/g);\n\n        // build event\n        let event;\n        if(/^system\\.(state|action)\\./.test(path))\n        {\n            event = type === 'state'\n                ? new StateEvent(method, value)\n                : new ActionEvent(method, value);\n        }\n        else\n        {\n            event = namespace === 'system'\n                ? new SystemEvent(type, value)\n                : new TransitionEvent(type);\n        }\n\n        // dispatch\n        let handlers = this.map.get(path);\n        if(handlers)\n        {\n            handlers.map(fn => fn(event, this.fsm) );\n        }\n    }\n\n};\n\nexport default HandlerMap;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/HandlerMap.js\n **/","import {isObject, isArray, isDefined, isUndefined} from '../utils/utils';\n\n/**\n * Utility class to create, modify and delete nested hashes and values\n *\n * @constructor\n */\nexport default function ValueMap (data)\n{\n    this.data = data || {};\n}\n\nValueMap.prototype =\n{\n    data: null,\n\n    set: function (path, value)\n    {\n        set(this.data, path, value);\n        return this;\n    },\n\n    add:function(path, value)\n    {\n        add(this.data, path, value);\n        return this;\n    },\n\n    insert:function(path, value)\n    {\n        insert(this.data, path, value);\n        return this;\n    },\n\n    get:function(path)\n    {\n        return get(this.data, path);\n    },\n\n    has: function (path, value = undefined)\n    {\n        return has(this.data, path, value)\n    },\n\n    indexOf: function (path, value)\n    {\n        return indexOf(this.data, path, value)\n    },\n\n    remove: function (path, value = undefined)\n    {\n        remove(this.data, path, value);\n        return this;\n    },\n\n    keys:function(path)\n    {\n        return Object.keys(get(this.data, path));\n    },\n\n    values:function(path)\n    {\n        return values(this.data, path);\n    }\n\n};\n\nfunction create(obj, keys)\n{\n    let key;\n    while(keys.length)\n    {\n        key = keys.shift();\n        if( ! isObject(obj[key]) )\n        {\n            obj[key] = {};\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n\nexport function set(obj, path, value, index = -1)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    obj[key] = value;\n}\n\nfunction add(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    obj[key].push(value);\n}\n\nfunction insert(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    let parent = obj[key],\n        index = parent.indexOf(value);\n    if(index === -1)\n    {\n        parent.push(value);\n    }\n    else\n    {\n        parent[index] = value;\n    }\n}\n\nexport function get(obj, path)\n{\n    if(isUndefined(path) || path == '')\n    {\n        return obj;\n    }\n\n    let key,\n        keys = String(path).split('.');\n    while(keys.length > 1)\n    {\n        key = keys.shift();\n        if( ! obj.hasOwnProperty(key) )\n        {\n            return;\n        }\n        obj = obj[key];\n    }\n    key = keys.shift();\n    return obj[key];\n}\n\nexport function has(obj, path, value)\n{\n    let parent = get(obj, path);\n    return !! (isArray(parent) && isDefined(value)\n        ? parent.indexOf(value) !== -1\n        : isUndefined(value)\n            ? isDefined(parent)\n            : parent === value);\n}\n\nexport function indexOf (obj, path, value)\n{\n    let arr = get(obj, path);\n    if(isArray(arr))\n    {\n        return arr.indexOf(value);\n    }\n    return -1;\n}\n\nexport function remove(obj, path, value)\n{\n    let parent = obj,\n        keys = String(path || '').split('.'),\n        key = keys.pop();\n\n    if(keys.length)\n    {\n        parent = get(obj, keys.join('.'))\n    }\n    if(isDefined(value) && isArray(parent[key]))\n    {\n        let target = parent[key];\n        var index = target.indexOf(value);\n        if(index > -1)\n        {\n            target.splice(index, 1);\n            if(target.length === 0)\n            {\n                delete parent[key];\n            }\n            return true;\n        }\n        return false;\n    }\n    else\n    {\n        if(isObject(parent) && obj.hasOwnProperty(key))\n        {\n            delete parent[key];\n            return true;\n        }\n    }\n    return false\n}\n\nexport function values(obj, path)\n{\n    var values = [];\n    var target = get(obj, path);\n    if(isObject(target))\n    {\n        for(var name in target)\n        {\n            if(target.hasOwnProperty(name))\n            {\n                values.push(target[name]);\n            }\n        }\n    }\n    return values;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/ValueMap.js\n **/","// ------------------------------------------------------------------------------------------------\n// setup\n\n    /**\n     * @prop {string}       namespace   The Event namespace; i.e. state or action\n     * @prop {string}       type        The Event type;      i.e. leave/enter (state) or start/end (action)\n     * @prop {string}       target      The Event target;    i.e. intro (state), next (action), or * (all states or types)\n     * @prop {Transition}   transition  The transition which generated the event\n     */\n    let event =\n    {\n        // properties\n        namespace   : null,\n        type        : null,\n        target      : null,\n        transition          : null\n    };\n\n    function initialize (event, namespace, type, target, transition)\n    {\n        event.namespace     = namespace;\n        event.type          = type;\n        event.target        = target;\n        event.transition    = transition;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// ActionEvent\n\n    export function ActionEvent (type, target, transition)\n    {\n        initialize(this, 'action' ,type, target, transition);\n    }\n    ActionEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// StateEvent\n\n    export function StateEvent (type, target, transition)\n    {\n        initialize(this, 'state' ,type, target, transition);\n    }\n    StateEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// SystemEvent\n\n    export function SystemEvent (type, value)\n    {\n        this.type   = type;\n        this.value  = value;\n    }\n\n    SystemEvent.prototype =\n    {\n        namespace   : 'system',\n        type        : '',\n        value       : null\n    };\n\n\n// ------------------------------------------------------------------------------------------------\n// TransitionEvent\n\n    export function TransitionEvent (type)\n    {\n        this.type = type;\n    }\n\n    TransitionEvent.prototype =\n    {\n        namespace   : 'transition',\n        type        : ''\n    };\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/objects/events.js\n **/","import HandlerMeta from './HandlerMeta';\nimport Lexer from '../lexer/Lexer'\nimport { trim } from '../utils/utils';\nimport { ParseError } from '../objects/errors';\n\n\n// ------------------------------------------------------------------------------------------------\n// functions\n\n    function isSystem(token)\n    {\n        return /^(start|change|complete|reset)$/.test(token);\n    }\n\n    function isTransition(token)\n    {\n        return /^(pause|resume|cancel)$/.test(token);\n    }\n\n    function expandGroups (input)\n    {\n        var rx \t\t= /\\((.+?)\\)/;\n        var matches = input.match(rx);\n        if(matches)\n        {\n            var group = matches[0];\n            var items = matches[1].match(/\\S+/g);\n            if(items)\n            {\n                items = items.map(item => input.replace(group, item));\n                if(rx.test(items[0]))\n                {\n                    return items.reduce( (output, input) => {\n                        return output.concat(expandGroups(input));\n                    }, []);\n                }\n                return items;\n            }\n        }\n        return [input];\n    }\n\n    function addPath (path, namespace, target)\n    {\n        results.push(new HandlerMeta(_id, path, namespace, target));\n        return true;\n    }\n\n    function addError (message, path)\n    {\n        var error = new ParseError(message, path, _id);\n        results.push(error);\n        return false;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// export\n\n    /**\n     * Parses event handler id into a HandlerMeta results containing handler paths\n     *\n     * @param   {string}    id          The handler id to parse, i.e. '@next', 'intro:end', 'change', etc\n     * @param   {Object}    defaults     A StateMachine instance to test for states and actions\n     * @return  {HandlerMeta[]}\n     */\n    export default function parse(id, defaults)\n    {\n        // pre-parse handler\n        id          = trim(id);\n\n        // objects\n        _id         = id;\n        _defaults   = defaults;\n        results     = [];\n\n        // parse\n        parser.parse(id, defaults);\n\n        // return\n        return results;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// objects\n\n    let results,\n        _defaults,\n        _id;\n\n    var patterns  =\n    {\n        // start pause intro\n        alias               : /^(\\w+)$/,\n\n        // system.start state.add\n        namespaced          : /^(system|transition|state|action)\\.(\\w+)$/,\n\n        // @next @quit\n        oneAction           : /^@(\\w+)$/,\n\n        // @next:start @next:end\n        oneActionEvent      : /^@(\\w+):(start|end)$/,\n\n        // :start :end\n        anyActionEvent      : /^:(start|end)$/,\n\n        // intro form\n        oneState            : /^#(\\w+)$/,\n\n        // intro:enter intro:leave\n        oneStateEvent       : /^#?(\\w+):(leave|enter)$/,\n\n        // :enter :leave\n        anyStateEvent       : /^:(enter|leave)$/,\n\n        // intro@next\n        oneStateAction      : /^#?(\\w+)@(\\w+)$/\n    };\n\n    let lexer   = new Lexer(patterns);\n\n    var parser =\n    {\n        /**\n         * Parses event handler id into HandlerMeta instance\n         *\n         * Resolving namespace, type and target properties\n         *\n         * @param   {string}        id\n         * @param   {Object}        defaults\n         */\n        parse (id, defaults)\n        {\n            // expand groups\n            let paths   = expandGroups(id);\n\n            // process paths\n            paths.map( path => this.parsePath(path) );\n        },\n\n        parsePath:function(path)\n        {\n            let tokens;\n            try\n            {\n                tokens = lexer.process(path)\n            }\n            catch(error)\n            {\n                return addError('Unrecognised pattern \"' +path+ '\"', path);\n            }\n\n            if(tokens && tokens.length)\n            {\n                // variables\n                let token   = tokens.shift();\n                var fn      = this[token.type];\n\n                // process\n                if(fn)\n                {\n                    return fn.apply(this, token.values);\n                }\n                return addError('Unknown token type \"' +token.type+ '\"', path);\n            }\n        },\n\n        alias (value)\n        {\n            if (isSystem(value))\n            {\n                return addPath('system.' + value, 'system');\n            }\n            if (isTransition(value))\n            {\n                return addPath('transition.' + value, 'transition');\n            }\n            return this.oneState(value);\n        },\n\n        namespaced (namespace, type)\n        {\n            var path = namespace + '.' + type;\n\n            if(namespace === 'system' && isSystem(type) || namespace === 'transition' && isTransition(type))\n            {\n                return addPath(path, namespace);\n            }\n\n            if(/^(state|action)$/.test(namespace) && /^(add|remove)$/.test(type))\n            {\n                return addPath('system.' + path, 'system');\n            }\n\n            addError('Unrecognised type \"' +type+'\" for namespace \"' +namespace+ '\"', _id)\n        },\n\n        oneState (state)\n        {\n            return addPath('state.' + state + '.' + _defaults.state, 'state', state);\n        },\n\n        oneAction (action)\n        {\n            return addPath('action.' +action+ '.' +_defaults.action, 'action', action);\n        },\n\n        anyActionEvent (event)\n        {\n            return addPath('action.*.' + event, 'action', '*');\n        },\n\n        oneActionEvent (action, event)\n        {\n            return addPath('action.' +action+ '.' + event, 'action', action);\n        },\n\n        anyStateEvent (event)\n        {\n            return addPath('state.*.' + event, 'state', '*');\n        },\n\n        oneStateEvent (state, event)\n        {\n            return addPath('state.' +state+ '.' + event, 'state', state);\n        },\n\n        oneStateAction (state, action)\n        {\n            return addPath('state.' +state+ '.' + action, 'state/action', state + '@' + action);\n        }\n\n    };\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/HandlerParser.js\n **/","function HandlerMeta (id, path, namespace = '', target = '')\n{\n    this.id         = id;\n    this.path       = path;\n    if(namespace)\n    {\n        this.namespace  = namespace;\n    }\n    if(target)\n    {\n        this.target     = target;\n    }\n}\n\nHandlerMeta.prototype =\n{\n    id          : '',\n    path        : '',\n    namespace   : '',\n    target      : ''\n};\n\nexport default HandlerMeta;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/HandlerMeta.js\n **/","import Rule from './Rule';\nimport Token from './Token';\n\n/**\n * Simple Lexer class\n *\n * @param   {Object}    rules   A hash of id:RegExp values\n * @constructor\n */\nexport default function Lexer(rules)\n{\n    this.rules = [];\n    if(rules)\n    {\n        Object.keys(rules).map( name => this.addRule(name, rules[name]) );\n    }\n}\n\nLexer.prototype =\n{\n    /** @var {String} */\n    source  : null,\n\n    /** @var {Rule[]} */\n    rules   : null,\n\n    /** @var {Token[]} */\n    tokens  : null,\n\n    /** @var {Number} */\n    index   : 0,\n\n    /**\n     * Process a source string into an array of Tokens based on Rules\n     *\n     * @param source\n     * @returns {Token[]}\n     */\n    process:function(source)\n    {\n        this.source = source;\n        this.tokens = [];\n        this.index  = 0;\n        this.next();\n        return this.tokens;\n    },\n\n    /**\n     * Adds a new rule\n     *\n     * @protected\n     * @param name\n     * @param rx\n     */\n    addRule:function(name, rx)\n    {\n        this.rules.push(new Rule(name, rx));\n    },\n\n    next:function()\n    {\n        if(this.index < this.source.length)\n        {\n            let source  = this.source.substr(this.index);\n            let state = this.rules.some(rule =>\n            {\n                var matches = source.match(rule.rx);\n                if(matches)\n                {\n                    this.tokens.push(new Token(rule.name, matches));\n                    this.index += matches[0].length;\n                    return true;\n                }\n                return false;\n            });\n\n            // not matched\n            if(!state)\n            {\n                throw new LexerError('Unable to match source at position ' + this.index + ': \"' +source+'\"', this.source, this.index);\n            }\n\n            // match\n            this.next();\n        }\n    }\n};\n\nfunction LexerError(message, source, index)\n{\n    this.message = message;\n    this.source = source;\n    this.index = index;\n}\n\nLexerError.prototype = new Error;\nLexerError.prototype.constructor = LexerError;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/lexer/Lexer.js\n **/","/**\n * A parsing rule, designed to match part of a string\n *\n * @param   {string}    name\n * @param   {RegExp}    rx\n */\nfunction Rule(name, rx)\n{\n    this.name = name;\n    this.rx = rx;\n}\n\nexport default Rule;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/lexer/Rule.js\n **/","/**\n * Token class, representing the type and value of part of a source string\n *\n * @param       {string}    type\n * @param       {string[]}  matches\n *\n * @property    {string}    type\n * @property    {string}    match\n * @property    {string[]}  values\n */\nfunction Token(type, matches)\n{\n    this.type       = type;\n    this.match      = matches[0];\n    this.values     = matches.slice(1);\n}\n\nexport default Token;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/lexer/Token.js\n **/","export function ParseError(message, path, id)\n{\n    this.message = message;\n    this.path = path;\n    this.id = id;\n}\n\nParseError.prototype = Error.prototype;\nParseError.prototype.name = 'ParseError';\nParseError.prototype.constructor = ParseError;\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/objects/errors.js\n **/","import ValueMap from './ValueMap';\nimport parseTransition from '../parsers/TransitionParser'\nimport { trim } from '../utils/utils'\n\nfunction TransitionMap ()\n{\n    this.map        = new ValueMap();\n    this.states     = [];\n    this.actions    = [];\n}\n\nTransitionMap.prototype =\n{\n    // ------------------------------------------------------------------------------------------------\n    // properties\n\n        map     : null,\n        states  : null,\n        actions : null,\n\n\n    // ------------------------------------------------------------------------------------------------\n    // add and remove states\n\n        /**\n         * Add event handler parsing\n         *\n         * @param   {string}    tx\n         * @returns {TransitionMeta[]}\n         */\n        parse: function (tx)\n        {\n            return parseTransition(tx);\n        },\n\n        /**\n         * Adds a new transition\n         * \n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @returns {TransitionMap}\n         */\n        add: function (action, from, to)\n        {\n            // procss variables\n            action  = trim(action);\n            from    = trim(from);\n            to      = typeof to === 'string' ? trim(to) : to;\n\n            // check for wildcards\n            if(to === '*')\n            {\n                throw new Error('Transitioning to a wildcard doesn\\'t make sense');\n            }\n\n            // add transition\n            this.map.set(from + '.' + action, to);\n            return update(this);\n        },\n\n        /**\n         * Removes an existing state\n         *\n         * @param   {string}    state\n         * @returns {TransitionMap}\n         */\n        remove: function (state)\n        {\n            // remove \"from\" state\n            this.map.remove(state);\n\n            // remove \"to\" states\n            let data = this.map.data;\n            for(let name in data)\n            {\n                let from = data[name];\n                for(let action in from)\n                {\n                    if(from[action] === state)\n                    {\n                        delete from[action];\n                    }\n                }\n            }\n\n            // update and return\n            return update(this);\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // accessors\n\n        /**\n         * Get all available actions (or action => states map) for a given state\n         *\n         * @param   {string}    from        Name of a state to get actions for\n         * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n         * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n         */\n        getActionsFrom: function (from, asMap = false)\n        {\n            if(this.has(from) || this.has('*'))\n            {\n                // get all available actions\n                let actions     = this.map.get(from) || {};\n                let wildcard    = this.map.get('*');\n                let output      = Object.assign({}, actions);\n\n                // append wildcard actions\n                if(wildcard)\n                {\n                    for(var action in wildcard)\n                    {\n                        let value = wildcard[action];\n                        if(value !== from && !actions[action])\n                        {\n                            output[action] = value;\n                        }\n                    }\n                }\n\n                // return map or keys\n                return output\n                    ? asMap\n                        ? output\n                        : Object.keys(output)\n                    : [];\n            }\n            return [];\n        },\n\n        /**\n         * Get the first available action to move from one state to another (if there is one)\n         *\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {string|null}\n         */\n        getActionFor: function (from, to)\n        {\n            let actions = this.map.get(from);\n            for(let action in actions)\n            {\n                if(actions[action] === to)\n                {\n                    return action;\n                }\n            }\n            return null;\n        },\n\n        /**\n         * Get all available \"to\" states for a given state\n         *\n         * Loops over all actions and returns a unique array of \"to\" states\n         *\n         * @param   {string|null}    [from]     Optional name of a from state to get states for. Defaults to the current state\n         * @returns {string[]}                  An array of string states\n         */\n        getStatesFrom: function (from)\n        {\n            if(this.hasState(from))\n            {\n                let actions = this.getActionsFrom(from, true);\n                return Object.keys(actions).map( name => actions[name] );\n            }\n            return null;\n        },\n\n        /**\n         * Get the target \"to\" state from a \"from\" state via an \"action\"\n         *\n         * @param   {string}    from\n         * @param   {string}    action\n         * @returns {string}\n         */\n        getStateFor: function (from, action)\n        {\n            let states = this.getActionsFrom(from, true) || {};\n            return states[action];\n        },\n\n        /**\n         * Get all states within the system\n         *\n         * @return  {string[]}\n         */\n        getStates: function ()\n        {\n            return [].concat(this.states);\n        },\n\n        /**\n         * Get all actions within the system\n         *\n         * @return  {string[]}\n         */\n        getActions: function ()\n        {\n            return [].concat(this.actions);\n        },\n\n        /**\n         * General getter\n         *\n         * @param   {string}    path\n         * @return  {*}\n         */\n        get: function(...path)\n        {\n            path = [...path].join('.');\n            return this.map.get(path);\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // checks\n\n        /**\n         * Test if the given state exists within the system\n         *\n         * @param   {string}    state\n         * @returns {boolean}\n         */\n        hasState: function (state)\n        {\n            return this.states.indexOf(state) !== -1;\n        },\n\n        /**\n         * Test if the given action exists within the system\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        hasAction: function (action)\n        {\n            return this.actions.indexOf(action) !== -1;\n        },\n\n        /**\n         * Test if the given transition exists within the system\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @returns {boolean}\n         */\n        hasTransition: function (action, from, to)\n        {\n            return this.map.get(from + '.' + action) === to;\n        },\n\n        /**\n         * Utility function to directly check if the composed ValueMap has the requested path\n         *\n         * Note this does NOT take into account the value of the target object; use hasTransition() for that\n         *\n         * @param   {string}    path    Pass a path using dot notation, i.e. 'a.next' or pass individual arguments, i.e. from, action, to\n         * @returns {boolean}\n         */\n        has: function (...path)\n        {\n            path = [...path].join('.');\n            return !! path\n                ? this.map.has(path)\n                : false;\n        }\n\n};\n\nTransitionMap.prototype.constructor = TransitionMap;\n\n/**\n * Private utility function to update existing states and actions\n *\n * @param   {TransitionMap} target\n * @returns {TransitionMap}\n */\nfunction update(target)\n{\n    // variables\n    var actions     = {};\n    var states      = {};\n    var data        = target.map.data;\n    var to;\n\n    // collate from states\n    for(let from in data)\n    {\n        states[from] = true;\n        for(let action in data[from])\n        {\n            actions[action] = true;\n            to = data[from][action];\n            if(typeof to !== 'function')\n            {\n                states[to] = true;\n            }\n        }\n    }\n\n    // update\n    target.states  = Object.keys(states).filter(state => state !== '*');\n    target.actions = Object.keys(actions);\n\n    // return\n    return target;\n}\n\nexport default TransitionMap;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/TransitionMap.js\n **/","import { isString } from '../utils/utils';\nimport { ParseError } from '../objects/errors';\nimport TransitionMeta from './TransitionMeta';\n\n// ------------------------------------------------------------------------------------------------\n// functions\n\n    function getError(tx, message)\n    {\n        return 'Invalid transition shorthand pattern \"' +tx+ '\" - ' + message;\n    }\n\n    function add(transitions, action, from, to)\n    {\n        transitions.push(new TransitionMeta(action, from, to));\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// export\n\n    /**\n     * Parses/expands transition objects/strings into discrete transitions\n     *\n     * @returns {TransitionMeta[]}  An array of TransitionMeta instances\n     */\n    export default function parse (tx)\n    {\n        if(isString(tx))\n        {\n            // pre-process string\n            tx = tx\n                .replace(/([|=:<>])/g, ' $1 ')\n                .replace(/\\s+/g, ' ')\n                .replace(/^\\s+|\\s+$/g,'');\n\n            // ensure string is valid\n            if(!/^\\w+ [:|=] [*\\w][\\w ]*[<>] [*\\w][\\w ]*/.test(tx))\n            {\n                throw new ParseError(getError(tx, 'cannot determine action and states'));\n            }\n\n            // initialize variables\n            let transitions = [],\n                matches = tx.match(/([*\\w ]+|[<>])/g),\n                action  = matches.shift().replace(/\\s+/g, ''),\n                stack   = [],\n                match   = '',\n                op      = '',\n                a       = '',\n                b       = '';\n\n            // process states\n            while(matches.length)\n            {\n                // get the next match\n                match = matches.shift();\n                if(/[<>]/.test(match))\n                {\n                    op = match;\n                }\n                else\n                {\n                    match = match.match(/[*\\w]+/g);\n                    match = match.length === 1 ? match[0] : match;\n                    stack.push(match);\n                }\n\n                // process matches if stack is full\n                if(stack.length === 2)\n                {\n                    [a, b] = op === '<'\n                        ? [stack[1], stack[0]]\n                        : stack;\n                    if(Array.isArray(a) && Array.isArray(b))\n                    {\n                        throw new ParseError(getError(tx, 'transitioning between 2 arrays doesn\\'t make sense'));\n                    }\n                    if(b === '*')\n                    {\n                        throw new ParseError(getError(tx, 'transitioning to a wildcard doesn\\'t make sense'));\n                    }\n                    if(Array.isArray(a))\n                    {\n                        a.map( a => add(transitions, action, a, b) );\n                    }\n                    else if(Array.isArray(b))\n                    {\n                        b.map( b => add(transitions, action, a, b) );\n                    }\n                    else\n                    {\n                        add(transitions, action, a, b);\n                    }\n\n                    // discard original match once processed\n                    stack.shift();\n                }\n\n            }\n\n            // return\n            return transitions;\n        }\n\n        // return objects wrapped in an array\n        return [tx];\n    }\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/TransitionParser.js\n **/","function TransitionMeta(action, from, to)\n{\n    this.action = action;\n    this.from = from;\n    this.to = to;\n}\n\nexport default TransitionMeta;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/TransitionMeta.js\n **/","import { StateEvent, ActionEvent } from '../objects/events';\nimport { isFunction } from '../utils/utils';\n\n/**\n * Transition class\n *\n * Responsible for managing events in the flow from state to state.\n *\n * This adds all handlers for the current action start/end and state from/to to an array:\n *\n * - <namespace>.<target>.<type>[]\n *\n * So going from state \"a\" to state \"b\" with action \"next\" should build:\n *\n * - action.*.start[]\n * - action.next.start[]\n * - state.a.leave[]\n * - state.*.leave[]\n * - state.*.enter[]\n * - state.b.enter[]\n * - action.next.end[]\n * - action.*.end[]\n *\n * This can be changed by passing in an order array in fsm.config\n *\n * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n *\n * From a callback, you can:\n *\n * - return false to cancel the transition\n * - return true to pause the transition\n * - not return a value (the transition continues)\n *\n * TransitionMap can also be paused, resumed, or cancelled by calling\n * the appropriate method on, or from:\n *\n * - the event\n * - the transition\n * - the state machine\n *\n * Cancelled transitions will reset the FSM to the previous \"from\" state\n *\n * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n *\n * @param {StateMachine}    fsm\n * @param {string}          action\n * @param {string}          from\n * @param {string}          to\n */\nfunction Transition (fsm, action, from, to)\n{\n    this.fsm        = fsm;\n    this.action     = action;\n    this.from       = from;\n    this.to         = to;\n    this.clear();\n}\n\n/**\n * @prop {StateMachine}    fsm\n * @prop {string}          action\n * @prop {string}          from\n * @prop {string}          to\n * @prop {Function[]}      handlers\n */\nTransition.prototype =\n{\n    fsm         : null,\n    action      : '',\n    from        : '',\n    to          : '',\n    paused      : false,\n    handlers    : null,\n\n    clear: function ()\n    {\n        unpause(this);\n        this.handlers = [];\n    },\n\n    /**\n     * Execute the next event's callbacks\n     * @returns {*}\n     */\n\texec: function ()\n\t{\n\t    if( ! this.paused )\n        {\n            if(this.handlers.length)\n            {\n                var handler = this.handlers.shift();\n                var state = handler();\n                if(state === false)\n                {\n                    return this.fsm.cancel();\n                }\n                if(state === true)\n                {\n                    return this.fsm.pause();\n                }\n                this.exec();\n            }\n            else\n            {\n                this.fsm.end();\n            }\n        }\n        return this;\n\t},\n\n    pause: function ()\n    {\n        pause(this);\n        return this;\n    },\n\n    resume: function ()\n    {\n        unpause(this);\n        return this.exec();\n    },\n\n    cancel: function()\n    {\n        this.paused = false;;\n        this.fsm.handlers.trigger('transition.cancel', false);\n    }\n\n};\n\nfunction pause(transition)\n{\n    if(!transition.paused)\n    {\n        transition.paused = true;\n        transition.fsm.handlers.trigger('transition.pause', true);\n    }\n}\n\nfunction unpause(transition)\n{\n    if(transition.paused)\n    {\n        transition.paused = false;\n        transition.fsm.handlers.trigger('transition.resume', false);\n    }\n}\n\nexport default\n{\n    /**\n     * Create the Transition object\n     *\n     * - Set up variables, and queue\n     * - Determine paths to relevant handlers\n     * - Build State and Action Event objects\n     * - Pre-bind all handlers\n     * - Append to queue\n     *\n     * @param {StateMachine}    fsm\n     * @param {string}          action\n     * @param {Array}           params\n     * @returns {Transition}\n     */\n    create:function (fsm, action, params)\n    {\n        // transition properties\n        let scope   = fsm.config.scope;\n        let from    = fsm.state;\n        let to      = fsm.transitions.getStateFor(from, action);\n        let vars    = {action, to, from};\n\n        // handle \"to\" being a function\n        if(isFunction(to))\n        {\n            to = to.apply(scope, params);\n            if(!fsm.transitions.hasState(to))\n            {\n                throw new Error('Invalid \"to\" state \"' +to+ '\"');\n            }\n        }\n\n        // transition\n        let queue       = [];\n        let transition  = new Transition(fsm, action, from, to);\n\n        // build handlers array\n        fsm.config.order.map( path =>\n        {\n            // replace path tokens\n            path = path.replace(/{(\\w+)}/g, (all, token) => vars[token]);\n            let handlers = fsm.handlers.get(path);\n\n            // do it!\n            if(handlers)\n            {\n                let [namespace, target, type] = path.split('.');\n                handlers = handlers.map( handler =>\n                {\n                    // build event object\n                    let Event = namespace === 'state' ? StateEvent : ActionEvent;\n                    let event = new Event(type, target, transition);\n\n                    // pre-bind handlers, scopes and params\n                    // this way scope and params don't need to be passed around\n                    // and the call from Transition is always just `value = handler()`\n                    return function()\n                    {\n                        return handler.apply(scope, [event, fsm].concat(params));\n                    }\n                });\n\n                // add to queue\n                queue = queue.concat(handlers);\n            }\n        });\n\n        // return\n        transition.handlers = queue;\n        return transition;\n    },\n\n    force: function(fsm, state)\n    {\n        let transition = new Transition(fsm, '', fsm.state, state);\n        transition.paused = fsm.transition ? fsm.transition.paused : false;\n        return transition;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/classes/Transition.js\n **/"],"sourceRoot":""}