{"version":3,"sources":["webpack:///webpack/universalModuleDefinition?5ca6","webpack:///StateMachine.min.js","webpack:///webpack/bootstrap 50e9f9a6db545430895c?63bf","webpack:///./src/StateMachine.js","webpack:///./src/core/utils/utils.js?57f9","webpack:///./src/core/classes/Config.js","webpack:///./src/core/maps/HandlerMap.js","webpack:///./src/core/maps/ValueMap.js","webpack:///./src/core/objects/events.js","webpack:///./src/core/parsers/HandlerParser.js","webpack:///./src/core/parsers/HandlerMeta.js","webpack:///./src/core/lexer/Lexer.js","webpack:///./src/core/lexer/Rule.js","webpack:///./src/core/lexer/Token.js","webpack:///./src/core/objects/errors.js","webpack:///./src/core/maps/TransitionMap.js","webpack:///./src/core/parsers/TransitionParser.js","webpack:///./src/core/parsers/TransitionMeta.js","webpack:///./src/core/classes/Transition.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","StateMachine","options","transitions","_TransitionMap2","handlers","_HandlerMap2","initialize","updateTransitions","fsm","method","callback","statesBefore","getStates","actionsBefore","getActions","statesAfter","actionsAfter","states","_utils","diff","actions","map","state","trigger","action","Object","defineProperty","value","_slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","undefined","_s","_i","Symbol","iterator","next","done","push","length","err","Array","isArray","TypeError","_Config","_Config2","_HandlerMap","_TransitionMap","_Transition","_Transition2","prototype","config","transition","_this","tx","concat","parse","add","from","to","initial","name","hasOwnProperty","on","methods","scope","start","reset","arguments","cancel","do","canDo","isPaused","_len","rest","_key","create","exec","go","force","has","clear","end","getActionFor","errors","console","warn","getActionsFrom","indexOf","canGo","hasState","is","isStarted","isTransitioning","paused","isComplete","pause","resume","_this2","remove","_this3","fn","_this4","invalid","forEach","meta","path","off","_this5","_this6","filter","result","Error","message","target","error","namespace","hasAction","_result$target$split","split","_result$target$split2","_this7","_len2","_key2","apply","constructor","getDefaultOrder","isObject","toString","isString","isFunction","Function","isDefined","isUndefined","trim","String","replace","a","b","da","v","db","toHash","values","reduce","Config","match","order","defaults","assign","final","HandlerMap","_ValueMap2","_ValueMap","_events","_HandlerParser","_HandlerParser2","insert","get","_path$match","_path$match2","type","event","test","StateEvent","ActionEvent","SystemEvent","TransitionEvent","ValueMap","data","keys","key","shift","set","pop","parent","index","join","splice","_set","_get","_has","_indexOf","_remove","_values","isSystem","token","isTransition","expandGroups","input","rx","matches","group","items","item","output","addPath","results","_HandlerMeta2","_id","addError","_errors","ParseError","_defaults","parser","_HandlerMeta","_Lexer","_Lexer2","patterns","alias","namespaced","oneAction","oneActionEvent","anyActionEvent","oneState","oneStateEvent","anyStateEvent","oneStateAction","lexer","paths","parsePath","tokens","process","HandlerMeta","Lexer","rules","addRule","LexerError","source","_Rule","_Rule2","_Token","_Token2","substr","some","rule","Rule","Token","slice","_toConsumableArray","arr2","TransitionMap","update","_typeof","_TransitionParser","_TransitionParser2","asMap","wildcard","getStatesFrom","_ret","getStateFor","hasTransition","getError","_TransitionMeta2","stack","op","_ref","_ref2","_TransitionMeta","TransitionMeta","Transition","unpause","handler","params","vars","queue","all","_path$split","_path$split2","Event"],"mappings":"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","file":"StateMachine.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn \n\n\n/** WEBPACK FOOTER **\n ** webpack/universalModuleDefinition\n **/","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"StateMachine\"] = factory();\n\telse\n\t\troot[\"StateMachine\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _Config = __webpack_require__(5);\n\t\n\tvar _Config2 = _interopRequireDefault(_Config);\n\t\n\tvar _HandlerMap = __webpack_require__(6);\n\t\n\tvar _HandlerMap2 = _interopRequireDefault(_HandlerMap);\n\t\n\tvar _TransitionMap = __webpack_require__(15);\n\t\n\tvar _TransitionMap2 = _interopRequireDefault(_TransitionMap);\n\t\n\tvar _Transition = __webpack_require__(18);\n\t\n\tvar _Transition2 = _interopRequireDefault(_Transition);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * StateMachine constructor\n\t *\n\t * @param   {Object|null}    options\n\t * @constructor\n\t */\n\tfunction StateMachine(options) {\n\t    this.transitions = new _TransitionMap2.default();\n\t    this.handlers = new _HandlerMap2.default(this);\n\t    this.initialize(options);\n\t}\n\t\n\t/**\n\t * StateMachine prototype\n\t *\n\t * The property examples below illustrate a 4-state machine, with states:\n\t *\n\t * - intro > settings > summary > end\n\t *\n\t * And actions:\n\t *\n\t * - back | next | restart | finish\n\t */\n\tStateMachine.prototype = {\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // properties\n\t\n\t    /**\n\t     * Configuration object\n\t     *\n\t     * @var {Config}\n\t     */\n\t    config: null,\n\t\n\t    /**\n\t     * Map of all transitions\n\t     *\n\t     * @var {TransitionMap}\n\t     */\n\t    transitions: null,\n\t\n\t    /**\n\t     * Map of all handlers\n\t     *\n\t     * @var {HandlerMap}\n\t     */\n\t    handlers: null,\n\t\n\t    /**\n\t     * Any active Transition object that is driving the state change\n\t     *\n\t     * @var {Transition}\n\t     */\n\t    transition: null,\n\t\n\t    /**\n\t     * The current state\n\t     *\n\t     * @var {string}\n\t     */\n\t    state: '',\n\t\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // private methods\n\t\n\t    /**\n\t     * Initialize the FSM with a config object\n\t     *\n\t     * @private\n\t     * @param options\n\t     */\n\t    initialize: function initialize(options) {\n\t        var _this = this;\n\t\n\t        // state\n\t        this.state = '';\n\t\n\t        // build config\n\t        var config = new _Config2.default(options);\n\t        this.config = config;\n\t\n\t        // pre-process all transitions\n\t        var transitions = [];\n\t        if (Array.isArray(options.transitions)) {\n\t            options.transitions.map(function (tx) {\n\t                transitions = transitions.concat(_this.transitions.parse(tx));\n\t            });\n\t        }\n\t\n\t        // add transitions\n\t        transitions.map(function (transition) {\n\t            _this.transitions.add(transition.action, transition.from, transition.to);\n\t        });\n\t\n\t        // get initial state (must be done after state collation)\n\t        if (!config.initial) {\n\t            config.initial = this.transitions.getStates()[0];\n\t        }\n\t\n\t        // add handlers\n\t        if (options.handlers) {\n\t            for (var _name in options.handlers) {\n\t                if (options.handlers.hasOwnProperty(_name)) {\n\t                    this.on(_name, options.handlers[_name]);\n\t                }\n\t            }\n\t        }\n\t\n\t        // add methods\n\t        if (options.methods) {\n\t            if (!this.config.scope) {\n\t                this.config.scope = this;\n\t            }\n\t            for (var name in options.methods) {\n\t                if (options.methods.hasOwnProperty(name) && !this.hasOwnProperty(name)) {\n\t                    this[name] = options.methods[name];\n\t                }\n\t            }\n\t        }\n\t\n\t        // start\n\t        if (this.config.start) {\n\t            this.start();\n\t        }\n\t\n\t        // return\n\t        return this;\n\t    },\n\t\n\t    start: function start() {\n\t        this.state = this.config.initial;\n\t        this.handlers.trigger('system.start');\n\t        this.handlers.trigger('system.change', this.state);\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Reset the FSM to the initial, or supplied, state\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    reset: function reset() {\n\t        var initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';\n\t\n\t        var state = initial || this.config.initial;\n\t        this.handlers.trigger('system.reset');\n\t        if (this.transition) {\n\t            this.transition.cancel();\n\t            delete this.transition;\n\t        }\n\t        if (this.state !== state) {\n\t            this.state = state;\n\t            this.handlers.trigger('system.change', this.state);\n\t        }\n\t        return this;\n\t    },\n\t\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // api\n\t\n\t    /**\n\t     * Attempt to run an action, resulting in a transition to a state\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {*[]}       rest\n\t     * @returns {boolean}\n\t     */\n\t    do: function _do(action) {\n\t        if (this.canDo(action) && !this.isPaused()) {\n\t            for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t                rest[_key - 1] = arguments[_key];\n\t            }\n\t\n\t            this.transition = _Transition2.default.create(this, action, rest);\n\t            this.transition.exec();\n\t            return true;\n\t        }\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Attempt to go to a state\n\t     *\n\t     * Queries TransitionMap instance to see if a transition exists, then calls the related action if it does\n\t     *\n\t     * @param   {string}    state\n\t     * @param   {boolean}   [force]\n\t     * @returns {boolean}\n\t     */\n\t    go: function go(state) {\n\t        var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        if (this.has(state)) {\n\t            if (force) {\n\t                if (this.transition) {\n\t                    this.transition.clear();\n\t                }\n\t                this.transition = _Transition2.default.force(this, state);\n\t                return this.end();\n\t            }\n\t            var action = this.transitions.getActionFor(this.state, state);\n\t            if (action) {\n\t                return this.do(action);\n\t            }\n\t            this.config.errors > 0 && console.warn('No transition exists from \"%s\" to \"%s\"', this.state, state);\n\t            return false;\n\t        }\n\t        this.config.errors > 0 && console.warn('No such state \"%s\"', state);\n\t        return false;\n\t    },\n\t\n\t    /**\n\t     * Query transition map to see if a named action is available\n\t     *\n\t     * @param   {string}        action\n\t     * @returns {boolean}\n\t     */\n\t    canDo: function canDo(action) {\n\t        return this.transitions.getActionsFrom(this.state).indexOf(action) !== -1;\n\t    },\n\t\n\t    /**\n\t     * Query transition map to see if a state is available to go to\n\t     *\n\t     * @param to\n\t     * @return {boolean}\n\t     */\n\t    canGo: function canGo(to) {\n\t        return this.transitions.getActionFor(this.state, to) !== null;\n\t    },\n\t\n\t    /**\n\t     * Test if a state exists\n\t     *\n\t     * @param   {string}    state\n\t     * @return  {boolean}\n\t     */\n\t    has: function has(state) {\n\t        return this.transitions.hasState(state);\n\t    },\n\t\n\t    /**\n\t     * Test if the current state is the same as the supplied one\n\t     *\n\t     * @param   {string}    state       A state name to compare against the current state\n\t     * @returns {boolean}\n\t     */\n\t    is: function is(state) {\n\t        return state === this.state;\n\t    },\n\t\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // flags\n\t\n\t    /**\n\t     * Test if the FSM has started\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isStarted: function isStarted() {\n\t        return this.state !== '';\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is transitioning\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isTransitioning: function isTransitioning() {\n\t        return !!this.transition;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is paused (whilst transitioning)\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isPaused: function isPaused() {\n\t        return this.transition ? this.transition.paused : false;\n\t    },\n\t\n\t    /**\n\t     * Test if the FSM is on the \"final\" state\n\t     *\n\t     * @returns {boolean}\n\t     */\n\t    isComplete: function isComplete() {\n\t        return this.state === this.config.final;\n\t    },\n\t\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // transitions\n\t\n\t    /**\n\t     * Pause any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    pause: function pause() {\n\t        if (this.transition && !this.isPaused()) {\n\t            this.transition.pause();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Resume any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    resume: function resume() {\n\t        if (this.transition && this.isPaused()) {\n\t            this.transition.resume();\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Cancel any current transition\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    cancel: function cancel() {\n\t        if (this.transition) {\n\t            this.state = this.transition.from;\n\t            this.transition.cancel();\n\t            delete this.transition;\n\t        }\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * End any current transition, skipping remaining handlers\n\t     *\n\t     * @returns {StateMachine}\n\t     */\n\t    end: function end() {\n\t        if (this.transition) {\n\t            this.state = this.transition.to;\n\t            this.transition.clear();\n\t            delete this.transition;\n\t            this.handlers.trigger('system.change', this.state);\n\t            if (this.isComplete()) {\n\t                this.handlers.trigger('system.complete');\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // actions\n\t\n\t    /**\n\t     * Add a transition\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @return  {StateMachine}\n\t     */\n\t    add: function add(action, from, to) {\n\t        var _this2 = this;\n\t\n\t        // 1 argument: shorthand transition, i.e 'next : a > b'\n\t        if (arguments.length === 1) {\n\t            var transitions = this.transitions.parse(action);\n\t            transitions.map(function (tx) {\n\t                return _this2.add(tx.action, tx.from, tx.to);\n\t            });\n\t            return this;\n\t        }\n\t\n\t        // 3 arguments: longhand transition\n\t        updateTransitions(this, 'add', function () {\n\t            return _this2.transitions.add(action, from, to);\n\t        });\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Remove a state\n\t     *\n\t     * @param   {string}    state\n\t     * @return  {StateMachine}\n\t     */\n\t    remove: function remove(state) {\n\t        var _this3 = this;\n\t\n\t        this.handlers.remove('state.' + state);\n\t        updateTransitions(this, 'remove', function () {\n\t            return _this3.transitions.remove(state);\n\t        });\n\t        return this;\n\t    },\n\t\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // handlers\n\t\n\t    /**\n\t     * Add an event handler\n\t     *\n\t     * Event handler signatures are built from the following grammar:\n\t     *\n\t     * - token      foo\n\t     * - property   .foo\n\t     * - event      :foo\n\t     * - action     @foo\n\t     * - targets    (foo bar baz)\n\t     *\n\t     * For example:\n\t     *\n\t     * - change\n\t     * - transition.pause\n\t     * - next:end\n\t     * - (a b)@next\n\t     * - a@next\n\t     *\n\t     * The main event types are unique, so can be used without the namespace:\n\t     *\n\t     * - change\n\t     * - pause\n\t     * - complete\n\t     * - ...\n\t     *\n\t     * If your states and events are unique, they can also be used without qualification.\n\t     *\n\t     * See docs and demo for more information\n\t     *\n\t     * @param   {string}        id\n\t     * @param   {Function}      fn\n\t     * @return  {StateMachine}\n\t     */\n\t    on: function on(id, fn) {\n\t        var _this4 = this;\n\t\n\t        this.parse(id, this.config.invalid, this.config.errors).forEach(function (meta) {\n\t            return _this4.handlers.add(meta.path, fn);\n\t        });\n\t        return this;\n\t    },\n\t\n\t    off: function off(id, fn) {\n\t        var _this5 = this;\n\t\n\t        this.parse(id, this.config.invalid, this.config.errors).forEach(function (meta) {\n\t            return _this5.handlers.remove(meta.path, fn);\n\t        });\n\t        return this;\n\t    },\n\t\n\t    // -----------------------------------------------------------------------------------------------------------------\n\t    // utilities\n\t\n\t    /**\n\t     * Parses a handler id string into HandlerMeta objects\n\t     *\n\t     * @param   {string}    id\n\t     * @param   {boolean}   invalid\n\t     * @param   {number}    errors\n\t     * @returns {HandlerMeta[]}\n\t     */\n\t    parse: function parse(id) {\n\t        var _this6 = this;\n\t\n\t        var invalid = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t        var errors = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\t\n\t        return this.handlers.parse(id).filter(function (result) {\n\t            // picks up unrecognised handlers, namespaces, etc\n\t            if (result instanceof Error) {\n\t                if (errors == 2) {\n\t                    throw result;\n\t                }\n\t                errors == 1 && console.warn(result.message);\n\t                return false;\n\t            }\n\t\n\t            // picks up unrecognised states and actions\n\t            if (result.target !== '*') {\n\t                var error = '';\n\t\n\t                if (result.namespace === 'state') {\n\t                    if (!_this6.transitions.hasState(result.target)) {\n\t                        error = 'Unrecognised state \"' + result.target + '\" in handler \"' + result.id + '\"';\n\t                    }\n\t                } else if (result.namespace === 'action') {\n\t                    if (!_this6.transitions.hasAction(result.target)) {\n\t                        error = 'Unrecognised action \"' + result.target + '\" in handler \"' + result.id + '\"';\n\t                    }\n\t                } else if (result.namespace === 'state/action') {\n\t                    // variables\n\t                    var _result$target$split = result.target.split('@');\n\t\n\t                    var _result$target$split2 = _slicedToArray(_result$target$split, 2);\n\t\n\t                    var state = _result$target$split2[0];\n\t                    var action = _result$target$split2[1];\n\t\n\t                    // test for state and action\n\t\n\t                    if (!_this6.transitions.hasState(state)) {\n\t                        error = 'Unrecognised state \"' + state + '\" in handler \"' + result.id + '\"';\n\t                    }\n\t                    if (!_this6.transitions.hasAction(action)) {\n\t                        error = 'Unrecognised action \"' + action + '\" in handler \"' + result.id + '\"';\n\t                    }\n\t                }\n\t\n\t                // if we have an error, the result was not an existing state or action\n\t                if (error) {\n\t                    if (errors == 2) {\n\t                        throw new Error(error);\n\t                    }\n\t                    errors == 1 && console.warn(error);\n\t                    return !!invalid;\n\t                }\n\t            }\n\t\n\t            // must be valid\n\t            return true;\n\t        });\n\t    },\n\t\n\t    trigger: function trigger(id) {\n\t        var _this7 = this;\n\t\n\t        for (var _len2 = arguments.length, rest = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n\t            rest[_key2 - 1] = arguments[_key2];\n\t        }\n\t\n\t        this.handlers.parse(id).map(function (meta) {\n\t            return _this7.handlers.trigger.apply(_this7.handlers, [meta.path].concat(rest));\n\t        });\n\t        return this;\n\t    }\n\t\n\t};\n\t\n\tStateMachine.prototype.constructor = StateMachine;\n\t\n\texports.default = StateMachine;\n\t\n\t// ---------------------------------------------------------------------------------------------------------------------\n\t// static methods\n\t\n\t/**\n\t * Factory method\n\t *\n\t * @param   options\n\t * @returns {StateMachine}\n\t */\n\t\n\tStateMachine.create = function (options) {\n\t    return new StateMachine(options);\n\t};\n\t\n\t/**\n\t * Gets the default order events should be called in\n\t * @returns {string[]}\n\t */\n\tStateMachine.getDefaultOrder = function () {\n\t    return ['action.*.start', 'action.{action}.start', 'state.*.{action}', 'state.{from}.{action}', 'state.{from}.leave', 'state.*.leave', 'state.*.enter', 'state.{to}.enter', 'action.{action}.end', 'action.*.end'];\n\t};\n\t\n\t// ---------------------------------------------------------------------------------------------------------------------\n\t// helper functions\n\t\n\t/**\n\t * Utility method to update transitions and dispatch events\n\t *\n\t * Saves duplicating the following code in both add() and remove() methods\n\t *\n\t * @param   {StateMachine}  fsm\n\t * @param   {string}        method\n\t * @param   {Function}      callback\n\t */\n\tfunction updateTransitions(fsm, method, callback) {\n\t    var statesBefore = fsm.transitions.getStates();\n\t    var actionsBefore = fsm.transitions.getActions();\n\t    callback();\n\t    var statesAfter = fsm.transitions.getStates();\n\t    var actionsAfter = fsm.transitions.getActions();\n\t\n\t    // calculate differences\n\t    var states = (0, _utils.diff)(statesBefore, statesAfter);\n\t    var actions = (0, _utils.diff)(actionsBefore, actionsAfter);\n\t\n\t    // dispatch events\n\t    states.map(function (state) {\n\t        return fsm.handlers.trigger('system.state.' + method, state);\n\t    });\n\t    actions.map(function (action) {\n\t        return fsm.handlers.trigger('system.action.' + method, action);\n\t    });\n\t}\n\n/***/ },\n/* 1 */,\n/* 2 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.isObject = isObject;\n\texports.isArray = isArray;\n\texports.isString = isString;\n\texports.isFunction = isFunction;\n\texports.isDefined = isDefined;\n\texports.isUndefined = isUndefined;\n\texports.trim = trim;\n\texports.diff = diff;\n\texports.toHash = toHash;\n\tfunction isObject(value) {\n\t    return Object.prototype.toString.call(value) === '[object Object]';\n\t}\n\t\n\tfunction isArray(value) {\n\t    return value instanceof Array;\n\t}\n\t\n\tfunction isString(value) {\n\t    return typeof value === 'string';\n\t}\n\t\n\tfunction isFunction(value) {\n\t    return value instanceof Function;\n\t}\n\t\n\tfunction isDefined(value) {\n\t    return typeof value !== 'undefined';\n\t}\n\t\n\tfunction isUndefined(value) {\n\t    return typeof value === 'undefined';\n\t}\n\t\n\tfunction trim(value) {\n\t    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n\t}\n\t\n\tfunction diff(a, b) {\n\t    var da = b.filter(function (v) {\n\t        return a.indexOf(v) < 0;\n\t    });\n\t    var db = a.filter(function (v) {\n\t        return b.indexOf(v) < 0;\n\t    });\n\t    return db.concat(da);\n\t}\n\t\n\tfunction toHash(values) {\n\t    return values.reduce(function (obj, value) {\n\t        obj[value] = true;\n\t        return obj;\n\t    }, {});\n\t}\n\n/***/ },\n/* 3 */,\n/* 4 */,\n/* 5 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\texports.default = Config;\n\tfunction Config(options) {\n\t  var _this = this;\n\t\n\t  'scope start initial final invalid errors'.match(/\\w+/g).map(function (name) {\n\t    if (options.hasOwnProperty(name)) {\n\t      _this[name] = options[name];\n\t    }\n\t  });\n\t\n\t  // order\n\t  this.order = options.order || StateMachine.getDefaultOrder();\n\t\n\t  // defaults\n\t  this.defaults = Object.assign({\n\t\n\t    // allow user to specify alternate triggers for event and action ids\n\t    action: 'start',\n\t    state: 'enter'\n\t\n\t  }, options.defaults);\n\t}\n\t\n\tConfig.prototype = {\n\t  /**\n\t   * An optional scope to run handler functions in\n\t   *\n\t   * @var object\n\t   */\n\t  scope: null,\n\t\n\t  /**\n\t   * A boolean to automatically start the state machine in the initial state\n\t   *\n\t   * @var boolean\n\t   */\n\t  start: true,\n\t\n\t  /**\n\t   * A string to indicate which state to start on; defaults to ''\n\t   *\n\t   * @var string\n\t   */\n\t  initial: '',\n\t\n\t  /**\n\t   * A string indicating the state to trigger a complete event; defaults to ''\n\t   *\n\t   * @var string\n\t   */\n\t  final: '',\n\t\n\t  /**\n\t   * A boolean to allow non-existent states and actions to be added to the handlers object; defaults to false (disallow)\n\t   *\n\t   * @var boolean\n\t   */\n\t  invalid: false,\n\t\n\t  /**\n\t   * A number indicating how to handle invalid or erroneous actions; defaults to 1 (warn)\n\t   *\n\t   *  - 0 : quiet\n\t   *  - 1 : console.warn()\n\t   *  - 2 : throw an error\n\t   *\n\t   * @var number\n\t   */\n\t  errors: 1,\n\t\n\t  /**\n\t   * The order to run transition callbacks in\n\t   *\n\t   * @type {string[]} type.target\n\t   */\n\t  order: null,\n\t\n\t  /**\n\t   * Sets defaults for various declarations\n\t   *\n\t   * Available options are:\n\t   *\n\t   * - action: (start|end)\n\t   * - state: (enter|leave)\n\t   *\n\t   * @type {Object}\n\t   */\n\t  defaults: null\n\t\n\t};\n\n/***/ },\n/* 6 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _ValueMap = __webpack_require__(7);\n\t\n\tvar _ValueMap2 = _interopRequireDefault(_ValueMap);\n\t\n\tvar _events = __webpack_require__(8);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _HandlerParser = __webpack_require__(9);\n\t\n\tvar _HandlerParser2 = _interopRequireDefault(_HandlerParser);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction HandlerMap(fsm) {\n\t    this.fsm = fsm;\n\t    this.map = new _ValueMap2.default();\n\t}\n\t\n\tHandlerMap.prototype = {\n\t\n\t    fsm: null,\n\t\n\t    map: null,\n\t\n\t    /**\n\t     * Parse event handler grammar into a HandlerMeta structure\n\t     *\n\t     * @param   {string}        id      The handler id to parse, i.e. '@next', 'intro:end', 'change', etc\n\t     * @returns {HandlerMeta[]}\n\t     */\n\t    parse: function parse(id) {\n\t        return (0, _HandlerParser2.default)(id, this.fsm.config.defaults);\n\t    },\n\t\n\t    /**\n\t     * Directly add a new handler\n\t     *\n\t     * @param   {string}    path    A 'namespace.target.type' target path to add a handler to\n\t     * @param   {Function}  fn      A callback function\n\t     * @returns {HandlerMap}\n\t     */\n\t    add: function add(path, fn) {\n\t        // check handler is a function\n\t        if (!(0, _utils.isFunction)(fn)) {\n\t            throw new Error('Error assigning \"' + path + '\" handler; callback is not a function', fn);\n\t        }\n\t\n\t        this.map.insert(path, fn);\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Directly remove a handler target\n\t     *\n\t     * @param   {string}    path    A 'namespace.target.type' parent to a handler removed from\n\t     * @param   {Function}  fn      The instance of the callback function\n\t     * @returns {HandlerMap}\n\t     */\n\t    remove: function remove(path, fn) {\n\t        this.map.remove(path, fn);\n\t        return this;\n\t    },\n\t\n\t    /**\n\t     * Get all handlers for a valid target path\n\t     *\n\t     * @param   {string}    path    A 'namespace.target.type' target path\n\t     * @returns {Function[]}        An array of callback functions\n\t     */\n\t    get: function get(path) {\n\t        return this.map.get(path);\n\t    },\n\t\n\t    /**\n\t     * Dispatch an event\n\t     *\n\t     * @param   {string}    path\n\t     * @param   {*}         value\n\t     * @returns {StateMachine}\n\t     */\n\t    trigger: function trigger(path) {\n\t        var _this = this;\n\t\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n\t\n\t        // create lookup path\n\t        var _path$match = path.match(/\\w+/g);\n\t\n\t        var _path$match2 = _slicedToArray(_path$match, 3);\n\t\n\t        var namespace = _path$match2[0];\n\t        var type = _path$match2[1];\n\t        var method = _path$match2[2];\n\t\n\t        // build event\n\t\n\t        var event = void 0;\n\t        if (/^system\\.(state|action)\\./.test(path)) {\n\t            event = type === 'state' ? new _events.StateEvent(method, value) : new _events.ActionEvent(method, value);\n\t        } else {\n\t            event = namespace === 'system' ? new _events.SystemEvent(type, value) : new _events.TransitionEvent(type);\n\t        }\n\t\n\t        // dispatch\n\t        var handlers = this.map.get(path);\n\t        if (handlers) {\n\t            handlers.map(function (fn) {\n\t                return fn(event, _this.fsm);\n\t            });\n\t        }\n\t    }\n\t\n\t};\n\t\n\texports.default = HandlerMap;\n\n/***/ },\n/* 7 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.values = exports.remove = exports.indexOf = exports.has = exports.get = exports.set = undefined;\n\texports.default = ValueMap;\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\t/**\n\t * Utility class to create, modify and delete nested hashes and values\n\t *\n\t * @constructor\n\t */\n\tfunction ValueMap(data) {\n\t    this.data = data || {};\n\t}\n\t\n\tValueMap.prototype = {\n\t    data: null,\n\t\n\t    set: function set(path, value) {\n\t        _set(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    add: function add(path, value) {\n\t        _add(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    insert: function insert(path, value) {\n\t        _insert(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    get: function get(path) {\n\t        return _get(this.data, path);\n\t    },\n\t\n\t    has: function has(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        return _has(this.data, path, value);\n\t    },\n\t\n\t    indexOf: function indexOf(path, value) {\n\t        return _indexOf(this.data, path, value);\n\t    },\n\t\n\t    remove: function remove(path) {\n\t        var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;\n\t\n\t        _remove(this.data, path, value);\n\t        return this;\n\t    },\n\t\n\t    keys: function keys(path) {\n\t        return Object.keys(_get(this.data, path));\n\t    },\n\t\n\t    values: function values(path) {\n\t        return _values(this.data, path);\n\t    }\n\t\n\t};\n\t\n\tfunction create(obj, keys) {\n\t    var key = void 0;\n\t    while (keys.length) {\n\t        key = keys.shift();\n\t        if (!(0, _utils.isObject)(obj[key])) {\n\t            obj[key] = {};\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    return obj;\n\t}\n\t\n\tfunction _set(obj, path, value) {\n\t    var index = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;\n\t\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    obj[key] = value;\n\t}\n\t\n\texports.set = _set;\n\tfunction _add(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    obj[key].push(value);\n\t}\n\t\n\tfunction _insert(obj, path, value) {\n\t    var keys = String(path).split('.'),\n\t        key = keys.pop();\n\t    obj = create(obj, keys);\n\t    if (!(0, _utils.isArray)(obj[key])) {\n\t        obj[key] = [];\n\t    }\n\t    var parent = obj[key],\n\t        index = parent.indexOf(value);\n\t    if (index === -1) {\n\t        parent.push(value);\n\t    } else {\n\t        parent[index] = value;\n\t    }\n\t}\n\t\n\tfunction _get(obj, path) {\n\t    if ((0, _utils.isUndefined)(path) || path == '') {\n\t        return obj;\n\t    }\n\t\n\t    var key = void 0,\n\t        keys = String(path).split('.');\n\t    while (keys.length > 1) {\n\t        key = keys.shift();\n\t        if (!obj.hasOwnProperty(key)) {\n\t            return;\n\t        }\n\t        obj = obj[key];\n\t    }\n\t    key = keys.shift();\n\t    return obj[key];\n\t}\n\t\n\texports.get = _get;\n\tfunction _has(obj, path, value) {\n\t    var parent = _get(obj, path);\n\t    return !!((0, _utils.isArray)(parent) && (0, _utils.isDefined)(value) ? parent.indexOf(value) !== -1 : (0, _utils.isUndefined)(value) ? (0, _utils.isDefined)(parent) : parent === value);\n\t}\n\t\n\texports.has = _has;\n\tfunction _indexOf(obj, path, value) {\n\t    var arr = _get(obj, path);\n\t    if ((0, _utils.isArray)(arr)) {\n\t        return arr.indexOf(value);\n\t    }\n\t    return -1;\n\t}\n\t\n\texports.indexOf = _indexOf;\n\tfunction _remove(obj, path, value) {\n\t    var parent = obj,\n\t        keys = String(path || '').split('.'),\n\t        key = keys.pop();\n\t\n\t    if (keys.length) {\n\t        parent = _get(obj, keys.join('.'));\n\t    }\n\t    if ((0, _utils.isDefined)(value) && (0, _utils.isArray)(parent[key])) {\n\t        var target = parent[key];\n\t        var index = target.indexOf(value);\n\t        if (index > -1) {\n\t            target.splice(index, 1);\n\t            if (target.length === 0) {\n\t                delete parent[key];\n\t            }\n\t            return true;\n\t        }\n\t        return false;\n\t    } else {\n\t        if ((0, _utils.isObject)(parent) && obj.hasOwnProperty(key)) {\n\t            delete parent[key];\n\t            return true;\n\t        }\n\t    }\n\t    return false;\n\t}\n\t\n\texports.remove = _remove;\n\tfunction _values(obj, path) {\n\t    var values = [];\n\t    var target = _get(obj, path);\n\t    if ((0, _utils.isObject)(target)) {\n\t        for (var name in target) {\n\t            if (target.hasOwnProperty(name)) {\n\t                values.push(target[name]);\n\t            }\n\t        }\n\t    }\n\t    return values;\n\t}\n\texports.values = _values;\n\n/***/ },\n/* 8 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ActionEvent = ActionEvent;\n\texports.StateEvent = StateEvent;\n\texports.SystemEvent = SystemEvent;\n\texports.TransitionEvent = TransitionEvent;\n\t// ------------------------------------------------------------------------------------------------\n\t// setup\n\t\n\t/**\n\t * @prop {string}       namespace   The Event namespace; i.e. state or action\n\t * @prop {string}       type        The Event type;      i.e. leave/enter (state) or start/end (action)\n\t * @prop {string}       target      The Event target;    i.e. intro (state), next (action), or * (all states or types)\n\t * @prop {Transition}   transition  The transition which generated the event\n\t */\n\tvar event = {\n\t    // properties\n\t    namespace: null,\n\t    type: null,\n\t    target: null,\n\t    transition: null\n\t};\n\t\n\tfunction initialize(event, namespace, type, target, transition) {\n\t    event.namespace = namespace;\n\t    event.type = type;\n\t    event.target = target;\n\t    event.transition = transition;\n\t}\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// ActionEvent\n\t\n\tfunction ActionEvent(type, target, transition) {\n\t    initialize(this, 'action', type, target, transition);\n\t}\n\tActionEvent.prototype = event;\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// StateEvent\n\t\n\tfunction StateEvent(type, target, transition) {\n\t    initialize(this, 'state', type, target, transition);\n\t}\n\tStateEvent.prototype = event;\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// SystemEvent\n\t\n\tfunction SystemEvent(type, value) {\n\t    this.type = type;\n\t    this.value = value;\n\t}\n\t\n\tSystemEvent.prototype = {\n\t    namespace: 'system',\n\t    type: '',\n\t    value: null\n\t};\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// TransitionEvent\n\t\n\tfunction TransitionEvent(type) {\n\t    this.type = type;\n\t}\n\t\n\tTransitionEvent.prototype = {\n\t    namespace: 'transition',\n\t    type: ''\n\t};\n\n/***/ },\n/* 9 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = parse;\n\t\n\tvar _HandlerMeta = __webpack_require__(10);\n\t\n\tvar _HandlerMeta2 = _interopRequireDefault(_HandlerMeta);\n\t\n\tvar _Lexer = __webpack_require__(11);\n\t\n\tvar _Lexer2 = _interopRequireDefault(_Lexer);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _errors = __webpack_require__(14);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// functions\n\t\n\tfunction isSystem(token) {\n\t    return (/^(start|change|complete|reset)$/.test(token)\n\t    );\n\t}\n\t\n\tfunction isTransition(token) {\n\t    return (/^(pause|resume|cancel)$/.test(token)\n\t    );\n\t}\n\t\n\tfunction expandGroups(input) {\n\t    var rx = /\\((.+?)\\)/;\n\t    var matches = input.match(rx);\n\t    if (matches) {\n\t        var group = matches[0];\n\t        var items = matches[1].match(/\\S+/g);\n\t        if (items) {\n\t            items = items.map(function (item) {\n\t                return input.replace(group, item);\n\t            });\n\t            if (rx.test(items[0])) {\n\t                return items.reduce(function (output, input) {\n\t                    return output.concat(expandGroups(input));\n\t                }, []);\n\t            }\n\t            return items;\n\t        }\n\t    }\n\t    return [input];\n\t}\n\t\n\tfunction addPath(path, namespace, target) {\n\t    results.push(new _HandlerMeta2.default(_id, path, namespace, target));\n\t    return true;\n\t}\n\t\n\tfunction addError(message, path) {\n\t    var error = new _errors.ParseError(message, path, _id);\n\t    results.push(error);\n\t    return false;\n\t}\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// export\n\t\n\t/**\n\t * Parses event handler id into a HandlerMeta results containing handler paths\n\t *\n\t * @param   {string}    id          The handler id to parse, i.e. '@next', 'intro:end', 'change', etc\n\t * @param   {Object}    defaults     A StateMachine instance to test for states and actions\n\t * @return  {HandlerMeta[]}\n\t */\n\tfunction parse(id, defaults) {\n\t    // pre-parse handler\n\t    id = (0, _utils.trim)(id);\n\t\n\t    // objects\n\t    _id = id;\n\t    _defaults = defaults;\n\t    results = [];\n\t\n\t    // parse\n\t    parser.parse(id, defaults);\n\t\n\t    // return\n\t    return results;\n\t}\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// objects\n\t\n\tvar results = void 0,\n\t    _defaults = void 0,\n\t    _id = void 0;\n\t\n\tvar patterns = {\n\t    // start pause intro\n\t    alias: /^(\\w+)$/,\n\t\n\t    // system.start state.add\n\t    namespaced: /^(system|transition|state|action):(\\w+)$/,\n\t\n\t    // @next @quit\n\t    oneAction: /^@(\\w+)$/,\n\t\n\t    // @next:start @next:end\n\t    oneActionEvent: /^@(\\w+):(start|end)$/,\n\t\n\t    // :start :end\n\t    anyActionEvent: /^:(start|end)$/,\n\t\n\t    // intro form\n\t    oneState: /^#(\\w+)$/,\n\t\n\t    // intro:enter intro:leave\n\t    oneStateEvent: /^#?(\\w+):(leave|enter)$/,\n\t\n\t    // :enter :leave\n\t    anyStateEvent: /^:(enter|leave)$/,\n\t\n\t    // intro@next\n\t    oneStateAction: /^#?(\\w+)@(\\w+)$/\n\t};\n\t\n\tvar lexer = new _Lexer2.default(patterns);\n\t\n\tvar parser = {\n\t    /**\n\t     * Parses event handler id into HandlerMeta instance\n\t     *\n\t     * Resolving namespace, type and target properties\n\t     *\n\t     * @param   {string}        id\n\t     * @param   {Object}        defaults\n\t     */\n\t    parse: function parse(id, defaults) {\n\t        var _this = this;\n\t\n\t        // expand groups\n\t        var paths = expandGroups(id);\n\t\n\t        // process paths\n\t        paths.map(function (path) {\n\t            return _this.parsePath(path);\n\t        });\n\t    },\n\t\n\t\n\t    parsePath: function parsePath(path) {\n\t        var tokens = void 0;\n\t        try {\n\t            tokens = lexer.process(path);\n\t        } catch (error) {\n\t            return addError('Unrecognised pattern \"' + path + '\"', path);\n\t        }\n\t\n\t        if (tokens && tokens.length) {\n\t            // variables\n\t            var token = tokens.shift();\n\t            var fn = this[token.type];\n\t\n\t            // process\n\t            if (fn) {\n\t                return fn.apply(this, token.values);\n\t            }\n\t            return addError('Unknown token type \"' + token.type + '\"', path);\n\t        }\n\t    },\n\t\n\t    alias: function alias(value) {\n\t        if (isSystem(value)) {\n\t            return addPath('system.' + value, 'system');\n\t        }\n\t        if (isTransition(value)) {\n\t            return addPath('transition.' + value, 'transition');\n\t        }\n\t        return this.oneState(value);\n\t    },\n\t    namespaced: function namespaced(namespace, type) {\n\t        var path = namespace + '.' + type;\n\t\n\t        if (namespace === 'system' && isSystem(type) || namespace === 'transition' && isTransition(type)) {\n\t            return addPath(path, namespace);\n\t        }\n\t\n\t        if (/^(state|action)$/.test(namespace) && /^(add|remove)$/.test(type)) {\n\t            return addPath('system.' + path, 'system');\n\t        }\n\t\n\t        addError('Unrecognised type \"' + type + '\" for namespace \"' + namespace + '\"', _id);\n\t    },\n\t    oneState: function oneState(state) {\n\t        return addPath('state.' + state + '.' + _defaults.state, 'state', state);\n\t    },\n\t    oneAction: function oneAction(action) {\n\t        return addPath('action.' + action + '.' + _defaults.action, 'action', action);\n\t    },\n\t    anyActionEvent: function anyActionEvent(event) {\n\t        return addPath('action.*.' + event, 'action', '*');\n\t    },\n\t    oneActionEvent: function oneActionEvent(action, event) {\n\t        return addPath('action.' + action + '.' + event, 'action', action);\n\t    },\n\t    anyStateEvent: function anyStateEvent(event) {\n\t        return addPath('state.*.' + event, 'state', '*');\n\t    },\n\t    oneStateEvent: function oneStateEvent(state, event) {\n\t        return addPath('state.' + state + '.' + event, 'state', state);\n\t    },\n\t    oneStateAction: function oneStateAction(state, action) {\n\t        return addPath('state.' + state + '.' + action, 'state/action', state + '@' + action);\n\t    }\n\t};\n\n/***/ },\n/* 10 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tfunction HandlerMeta(id, path) {\n\t    var namespace = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '';\n\t    var target = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '';\n\t\n\t    this.id = id;\n\t    this.path = path;\n\t    if (namespace) {\n\t        this.namespace = namespace;\n\t    }\n\t    if (target) {\n\t        this.target = target;\n\t    }\n\t}\n\t\n\tHandlerMeta.prototype = {\n\t    id: '',\n\t    path: '',\n\t    namespace: '',\n\t    target: ''\n\t};\n\t\n\texports.default = HandlerMeta;\n\n/***/ },\n/* 11 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.default = Lexer;\n\t\n\tvar _Rule = __webpack_require__(12);\n\t\n\tvar _Rule2 = _interopRequireDefault(_Rule);\n\t\n\tvar _Token = __webpack_require__(13);\n\t\n\tvar _Token2 = _interopRequireDefault(_Token);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t/**\n\t * Simple Lexer class\n\t *\n\t * @param   {Object}    rules   A hash of id:RegExp values\n\t * @constructor\n\t */\n\tfunction Lexer(rules) {\n\t    var _this = this;\n\t\n\t    this.rules = [];\n\t    if (rules) {\n\t        Object.keys(rules).map(function (name) {\n\t            return _this.addRule(name, rules[name]);\n\t        });\n\t    }\n\t}\n\t\n\tLexer.prototype = {\n\t    /** @var {String} */\n\t    source: null,\n\t\n\t    /** @var {Rule[]} */\n\t    rules: null,\n\t\n\t    /** @var {Token[]} */\n\t    tokens: null,\n\t\n\t    /** @var {Number} */\n\t    index: 0,\n\t\n\t    /**\n\t     * Process a source string into an array of Tokens based on Rules\n\t     *\n\t     * @param source\n\t     * @returns {Token[]}\n\t     */\n\t    process: function process(source) {\n\t        this.source = source;\n\t        this.tokens = [];\n\t        this.index = 0;\n\t        this.next();\n\t        return this.tokens;\n\t    },\n\t\n\t    /**\n\t     * Adds a new rule\n\t     *\n\t     * @protected\n\t     * @param name\n\t     * @param rx\n\t     */\n\t    addRule: function addRule(name, rx) {\n\t        this.rules.push(new _Rule2.default(name, rx));\n\t    },\n\t\n\t    next: function next() {\n\t        var _this2 = this;\n\t\n\t        if (this.index < this.source.length) {\n\t            (function () {\n\t                var source = _this2.source.substr(_this2.index);\n\t                var state = _this2.rules.some(function (rule) {\n\t                    var matches = source.match(rule.rx);\n\t                    if (matches) {\n\t                        _this2.tokens.push(new _Token2.default(rule.name, matches));\n\t                        _this2.index += matches[0].length;\n\t                        return true;\n\t                    }\n\t                    return false;\n\t                });\n\t\n\t                // not matched\n\t                if (!state) {\n\t                    throw new LexerError('Unable to match source at position ' + _this2.index + ': \"' + source + '\"', _this2.source, _this2.index);\n\t                }\n\t\n\t                // match\n\t                _this2.next();\n\t            })();\n\t        }\n\t    }\n\t};\n\t\n\tfunction LexerError(message, source, index) {\n\t    this.message = message;\n\t    this.source = source;\n\t    this.index = index;\n\t}\n\t\n\tLexerError.prototype = new Error();\n\tLexerError.prototype.constructor = LexerError;\n\n/***/ },\n/* 12 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * A parsing rule, designed to match part of a string\n\t *\n\t * @param   {string}    name\n\t * @param   {RegExp}    rx\n\t */\n\tfunction Rule(name, rx) {\n\t  this.name = name;\n\t  this.rx = rx;\n\t}\n\t\n\texports.default = Rule;\n\n/***/ },\n/* 13 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t  value: true\n\t});\n\t/**\n\t * Token class, representing the type and value of part of a source string\n\t *\n\t * @param       {string}    type\n\t * @param       {string[]}  matches\n\t *\n\t * @property    {string}    type\n\t * @property    {string}    match\n\t * @property    {string[]}  values\n\t */\n\tfunction Token(type, matches) {\n\t  this.type = type;\n\t  this.match = matches[0];\n\t  this.values = matches.slice(1);\n\t}\n\t\n\texports.default = Token;\n\n/***/ },\n/* 14 */\n/***/ function(module, exports) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.ParseError = ParseError;\n\tfunction ParseError(message, path, id) {\n\t    this.message = message;\n\t    this.path = path;\n\t    this.id = id;\n\t}\n\t\n\tParseError.prototype = Error.prototype;\n\tParseError.prototype.name = 'ParseError';\n\tParseError.prototype.constructor = ParseError;\n\n/***/ },\n/* 15 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _ValueMap = __webpack_require__(7);\n\t\n\tvar _ValueMap2 = _interopRequireDefault(_ValueMap);\n\t\n\tvar _TransitionParser = __webpack_require__(16);\n\t\n\tvar _TransitionParser2 = _interopRequireDefault(_TransitionParser);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\t\n\tfunction TransitionMap() {\n\t    this.map = new _ValueMap2.default();\n\t    this.states = [];\n\t    this.actions = [];\n\t}\n\t\n\tTransitionMap.prototype = {\n\t    // ------------------------------------------------------------------------------------------------\n\t    // properties\n\t\n\t    map: null,\n\t    states: null,\n\t    actions: null,\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // add and remove states\n\t\n\t    /**\n\t     * Add event handler parsing\n\t     *\n\t     * @param   {string}    tx\n\t     * @returns {TransitionMeta[]}\n\t     */\n\t    parse: function parse(tx) {\n\t        return (0, _TransitionParser2.default)(tx);\n\t    },\n\t\n\t    /**\n\t     * Adds a new transition\n\t     * \n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @returns {TransitionMap}\n\t     */\n\t    add: function add(action, from, to) {\n\t        // procss variables\n\t        action = (0, _utils.trim)(action);\n\t        from = (0, _utils.trim)(from);\n\t        to = typeof to === 'string' ? (0, _utils.trim)(to) : to;\n\t\n\t        // check for wildcards\n\t        if (to === '*') {\n\t            throw new Error('Transitioning to a wildcard doesn\\'t make sense');\n\t        }\n\t\n\t        // add transition\n\t        this.map.set(from + '.' + action, to);\n\t        return update(this);\n\t    },\n\t\n\t    /**\n\t     * Removes an existing state\n\t     *\n\t     * @param   {string}    state\n\t     * @returns {TransitionMap}\n\t     */\n\t    remove: function remove(state) {\n\t        // remove \"from\" state\n\t        this.map.remove(state);\n\t\n\t        // remove \"to\" states\n\t        var data = this.map.data;\n\t        for (var name in data) {\n\t            var from = data[name];\n\t            for (var action in from) {\n\t                if (from[action] === state) {\n\t                    delete from[action];\n\t                }\n\t            }\n\t        }\n\t\n\t        // update and return\n\t        return update(this);\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // accessors\n\t\n\t    /**\n\t     * Get all available actions (or action => states map) for a given state\n\t     *\n\t     * @param   {string}    from        Name of a state to get actions for\n\t     * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n\t     * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n\t     */\n\t    getActionsFrom: function getActionsFrom(from) {\n\t        var asMap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\t\n\t        if (this.has(from) || this.has('*')) {\n\t            // get all available actions\n\t            var actions = this.map.get(from) || {};\n\t            var wildcard = this.map.get('*');\n\t            var output = Object.assign({}, actions);\n\t\n\t            // append wildcard actions\n\t            if (wildcard) {\n\t                for (var action in wildcard) {\n\t                    var value = wildcard[action];\n\t                    if (value !== from && !actions[action]) {\n\t                        output[action] = value;\n\t                    }\n\t                }\n\t            }\n\t\n\t            // return map or keys\n\t            return output ? asMap ? output : Object.keys(output) : [];\n\t        }\n\t        return [];\n\t    },\n\t\n\t    /**\n\t     * Get the first available action to move from one state to another (if there is one)\n\t     *\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @return  {string|null}\n\t     */\n\t    getActionFor: function getActionFor(from, to) {\n\t        var actions = this.map.get(from);\n\t        for (var action in actions) {\n\t            if (actions[action] === to) {\n\t                return action;\n\t            }\n\t        }\n\t        return null;\n\t    },\n\t\n\t    /**\n\t     * Get all available \"to\" states for a given state\n\t     *\n\t     * Loops over all actions and returns a unique array of \"to\" states\n\t     *\n\t     * @param   {string|null}    [from]     Optional name of a from state to get states for. Defaults to the current state\n\t     * @returns {string[]}                  An array of string states\n\t     */\n\t    getStatesFrom: function getStatesFrom(from) {\n\t        var _this = this;\n\t\n\t        if (this.hasState(from)) {\n\t            var _ret = function () {\n\t                var actions = _this.getActionsFrom(from, true);\n\t                return {\n\t                    v: Object.keys(actions).map(function (name) {\n\t                        return actions[name];\n\t                    })\n\t                };\n\t            }();\n\t\n\t            if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t        }\n\t        return null;\n\t    },\n\t\n\t    /**\n\t     * Get the target \"to\" state from a \"from\" state via an \"action\"\n\t     *\n\t     * @param   {string}    from\n\t     * @param   {string}    action\n\t     * @returns {string}\n\t     */\n\t    getStateFor: function getStateFor(from, action) {\n\t        var states = this.getActionsFrom(from, true) || {};\n\t        return states[action];\n\t    },\n\t\n\t    /**\n\t     * Get all states within the system\n\t     *\n\t     * @return  {string[]}\n\t     */\n\t    getStates: function getStates() {\n\t        return [].concat(this.states);\n\t    },\n\t\n\t    /**\n\t     * Get all actions within the system\n\t     *\n\t     * @return  {string[]}\n\t     */\n\t    getActions: function getActions() {\n\t        return [].concat(this.actions);\n\t    },\n\t\n\t    /**\n\t     * General getter\n\t     *\n\t     * @param   {string}    path\n\t     * @return  {*}\n\t     */\n\t    get: function get() {\n\t        for (var _len = arguments.length, path = Array(_len), _key = 0; _key < _len; _key++) {\n\t            path[_key] = arguments[_key];\n\t        }\n\t\n\t        path = [].concat(_toConsumableArray(path)).join('.');\n\t        return this.map.get(path);\n\t    },\n\t\n\t    // ------------------------------------------------------------------------------------------------\n\t    // checks\n\t\n\t    /**\n\t     * Test if the given state exists within the system\n\t     *\n\t     * @param   {string}    state\n\t     * @returns {boolean}\n\t     */\n\t    hasState: function hasState(state) {\n\t        return this.states.indexOf(state) !== -1;\n\t    },\n\t\n\t    /**\n\t     * Test if the given action exists within the system\n\t     *\n\t     * @param   {string}    action\n\t     * @returns {boolean}\n\t     */\n\t    hasAction: function hasAction(action) {\n\t        return this.actions.indexOf(action) !== -1;\n\t    },\n\t\n\t    /**\n\t     * Test if the given transition exists within the system\n\t     *\n\t     * @param   {string}    action\n\t     * @param   {string}    from\n\t     * @param   {string}    to\n\t     * @returns {boolean}\n\t     */\n\t    hasTransition: function hasTransition(action, from, to) {\n\t        return this.map.get(from + '.' + action) === to;\n\t    },\n\t\n\t    /**\n\t     * Utility function to directly check if the composed ValueMap has the requested path\n\t     *\n\t     * Note this does NOT take into account the value of the target object; use hasTransition() for that\n\t     *\n\t     * @param   {string}    path    Pass a path using dot notation, i.e. 'a.next' or pass individual arguments, i.e. from, action, to\n\t     * @returns {boolean}\n\t     */\n\t    has: function has() {\n\t        for (var _len2 = arguments.length, path = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n\t            path[_key2] = arguments[_key2];\n\t        }\n\t\n\t        path = [].concat(_toConsumableArray(path)).join('.');\n\t        return !!path ? this.map.has(path) : false;\n\t    }\n\t\n\t};\n\t\n\tTransitionMap.prototype.constructor = TransitionMap;\n\t\n\t/**\n\t * Private utility function to update existing states and actions\n\t *\n\t * @param   {TransitionMap} target\n\t * @returns {TransitionMap}\n\t */\n\tfunction update(target) {\n\t    // variables\n\t    var actions = {};\n\t    var states = {};\n\t    var data = target.map.data;\n\t    var to;\n\t\n\t    // collate from states\n\t    for (var from in data) {\n\t        states[from] = true;\n\t        for (var action in data[from]) {\n\t            actions[action] = true;\n\t            to = data[from][action];\n\t            if (typeof to !== 'function') {\n\t                states[to] = true;\n\t            }\n\t        }\n\t    }\n\t\n\t    // update\n\t    target.states = Object.keys(states).filter(function (state) {\n\t        return state !== '*';\n\t    });\n\t    target.actions = Object.keys(actions);\n\t\n\t    // return\n\t    return target;\n\t}\n\t\n\texports.default = TransitionMap;\n\n/***/ },\n/* 16 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\texports.default = parse;\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\tvar _errors = __webpack_require__(14);\n\t\n\tvar _TransitionMeta = __webpack_require__(17);\n\t\n\tvar _TransitionMeta2 = _interopRequireDefault(_TransitionMeta);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// functions\n\t\n\tfunction getError(tx, message) {\n\t    return 'Invalid transition shorthand pattern \"' + tx + '\" - ' + message;\n\t}\n\t\n\tfunction add(transitions, action, from, to) {\n\t    transitions.push(new _TransitionMeta2.default(action, from, to));\n\t}\n\t\n\t// ------------------------------------------------------------------------------------------------\n\t// export\n\t\n\t/**\n\t * Parses/expands transition objects/strings into discrete transitions\n\t *\n\t * @returns {TransitionMeta[]}  An array of TransitionMeta instances\n\t */\n\tfunction parse(tx) {\n\t    if ((0, _utils.isString)(tx)) {\n\t        var _ret = function () {\n\t            // pre-process string\n\t            tx = tx.replace(/([|=:<>])/g, ' $1 ').replace(/\\s+/g, ' ').replace(/^\\s+|\\s+$/g, '');\n\t\n\t            // ensure string is valid\n\t            if (!/^\\w+ [:|=] [*\\w][\\w ]*[<>] [*\\w][\\w ]*/.test(tx)) {\n\t                throw new _errors.ParseError(getError(tx, 'cannot determine action and states'));\n\t            }\n\t\n\t            // initialize variables\n\t            var transitions = [],\n\t                matches = tx.match(/([*\\w ]+|[<>])/g),\n\t                action = matches.shift().replace(/\\s+/g, ''),\n\t                stack = [],\n\t                match = '',\n\t                op = '',\n\t                a = '',\n\t                b = '';\n\t\n\t            // process states\n\t            while (matches.length) {\n\t                // get the next match\n\t                match = matches.shift();\n\t                if (/[<>]/.test(match)) {\n\t                    op = match;\n\t                } else {\n\t                    match = match.match(/[*\\w]+/g);\n\t                    match = match.length === 1 ? match[0] : match;\n\t                    stack.push(match);\n\t                }\n\t\n\t                // process matches if stack is full\n\t                if (stack.length === 2) {\n\t                    var _ref = op === '<' ? [stack[1], stack[0]] : stack;\n\t\n\t                    var _ref2 = _slicedToArray(_ref, 2);\n\t\n\t                    a = _ref2[0];\n\t                    b = _ref2[1];\n\t\n\t                    if (Array.isArray(a) && Array.isArray(b)) {\n\t                        throw new _errors.ParseError(getError(tx, 'transitioning between 2 arrays doesn\\'t make sense'));\n\t                    }\n\t                    if (b === '*') {\n\t                        throw new _errors.ParseError(getError(tx, 'transitioning to a wildcard doesn\\'t make sense'));\n\t                    }\n\t                    if (Array.isArray(a)) {\n\t                        a.map(function (a) {\n\t                            return add(transitions, action, a, b);\n\t                        });\n\t                    } else if (Array.isArray(b)) {\n\t                        b.map(function (b) {\n\t                            return add(transitions, action, a, b);\n\t                        });\n\t                    } else {\n\t                        add(transitions, action, a, b);\n\t                    }\n\t\n\t                    // discard original match once processed\n\t                    stack.shift();\n\t                }\n\t            }\n\t\n\t            // return\n\t            return {\n\t                v: transitions\n\t            };\n\t        }();\n\t\n\t        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n\t    }\n\t\n\t    // return objects wrapped in an array\n\t    return [tx];\n\t}\n\n/***/ },\n/* 17 */\n/***/ function(module, exports) {\n\n\t\"use strict\";\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\tfunction TransitionMeta(action, from, to) {\n\t    this.action = action;\n\t    this.from = from;\n\t    this.to = to;\n\t}\n\t\n\texports.default = TransitionMeta;\n\n/***/ },\n/* 18 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\t\n\tvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"]) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); } }; }();\n\t\n\tvar _events = __webpack_require__(8);\n\t\n\tvar _utils = __webpack_require__(2);\n\t\n\t/**\n\t * Transition class\n\t *\n\t * Responsible for managing events in the flow from state to state.\n\t *\n\t * This adds all handlers for the current action start/end and state from/to to an array:\n\t *\n\t * - <namespace>.<target>.<type>[]\n\t *\n\t * So going from state \"a\" to state \"b\" with action \"next\" should build:\n\t *\n\t * - action.*.start[]\n\t * - action.next.start[]\n\t * - state.a.leave[]\n\t * - state.*.leave[]\n\t * - state.*.enter[]\n\t * - state.b.enter[]\n\t * - action.next.end[]\n\t * - action.*.end[]\n\t *\n\t * This can be changed by passing in an order array in fsm.config\n\t *\n\t * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n\t *\n\t * From a callback, you can:\n\t *\n\t * - return false to cancel the transition\n\t * - return true to pause the transition\n\t * - not return a value (the transition continues)\n\t *\n\t * TransitionMap can also be paused, resumed, or cancelled by calling\n\t * the appropriate method on, or from:\n\t *\n\t * - the event\n\t * - the transition\n\t * - the state machine\n\t *\n\t * Cancelled transitions will reset the FSM to the previous \"from\" state\n\t *\n\t * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n\t *\n\t * @param {StateMachine}    fsm\n\t * @param {string}          action\n\t * @param {string}          from\n\t * @param {string}          to\n\t */\n\tfunction Transition(fsm, action, from, to) {\n\t    this.fsm = fsm;\n\t    this.action = action;\n\t    this.from = from;\n\t    this.to = to;\n\t    this.clear();\n\t}\n\t\n\t/**\n\t * @prop {StateMachine}    fsm\n\t * @prop {string}          action\n\t * @prop {string}          from\n\t * @prop {string}          to\n\t * @prop {Function[]}      handlers\n\t */\n\tTransition.prototype = {\n\t    fsm: null,\n\t    action: '',\n\t    from: '',\n\t    to: '',\n\t    paused: false,\n\t    handlers: null,\n\t\n\t    clear: function clear() {\n\t        unpause(this);\n\t        this.handlers = [];\n\t    },\n\t\n\t    /**\n\t     * Execute the next event's callbacks\n\t     * @returns {*}\n\t     */\n\t    exec: function exec() {\n\t        if (!this.paused) {\n\t            if (this.handlers.length) {\n\t                var handler = this.handlers.shift();\n\t                var state = handler();\n\t                if (state === false) {\n\t                    return this.fsm.cancel();\n\t                }\n\t                if (state === true) {\n\t                    return this.fsm.pause();\n\t                }\n\t                this.exec();\n\t            } else {\n\t                this.fsm.end();\n\t            }\n\t        }\n\t        return this;\n\t    },\n\t\n\t    pause: function pause() {\n\t        _pause(this);\n\t        return this;\n\t    },\n\t\n\t    resume: function resume() {\n\t        unpause(this);\n\t        return this.exec();\n\t    },\n\t\n\t    cancel: function cancel() {\n\t        this.paused = false;;\n\t        this.fsm.handlers.trigger('transition.cancel', false);\n\t    }\n\t\n\t};\n\t\n\tfunction _pause(transition) {\n\t    if (!transition.paused) {\n\t        transition.paused = true;\n\t        transition.fsm.handlers.trigger('transition.pause', true);\n\t    }\n\t}\n\t\n\tfunction unpause(transition) {\n\t    if (transition.paused) {\n\t        transition.paused = false;\n\t        transition.fsm.handlers.trigger('transition.resume', false);\n\t    }\n\t}\n\t\n\texports.default = {\n\t    /**\n\t     * Create the Transition object\n\t     *\n\t     * - Set up variables, and queue\n\t     * - Determine paths to relevant handlers\n\t     * - Build State and Action Event objects\n\t     * - Pre-bind all handlers\n\t     * - Append to queue\n\t     *\n\t     * @param {StateMachine}    fsm\n\t     * @param {string}          action\n\t     * @param {Array}           params\n\t     * @returns {Transition}\n\t     */\n\t    create: function create(fsm, action, params) {\n\t        // transition properties\n\t        var scope = fsm.config.scope;\n\t        var from = fsm.state;\n\t        var to = fsm.transitions.getStateFor(from, action);\n\t        var vars = { action: action, to: to, from: from };\n\t\n\t        // handle \"to\" being a function\n\t        if ((0, _utils.isFunction)(to)) {\n\t            to = to.apply(scope, params);\n\t            if (!fsm.transitions.hasState(to)) {\n\t                throw new Error('Invalid \"to\" state \"' + to + '\"');\n\t            }\n\t        }\n\t\n\t        // transition\n\t        var queue = [];\n\t        var transition = new Transition(fsm, action, from, to);\n\t\n\t        // build handlers array\n\t        fsm.config.order.map(function (path) {\n\t            // replace path tokens\n\t            path = path.replace(/{(\\w+)}/g, function (all, token) {\n\t                return vars[token];\n\t            });\n\t            var handlers = fsm.handlers.get(path);\n\t\n\t            // do it!\n\t            if (handlers) {\n\t                (function () {\n\t                    var _path$split = path.split('.');\n\t\n\t                    var _path$split2 = _slicedToArray(_path$split, 3);\n\t\n\t                    var namespace = _path$split2[0];\n\t                    var target = _path$split2[1];\n\t                    var type = _path$split2[2];\n\t\n\t                    handlers = handlers.map(function (handler) {\n\t                        // build event object\n\t                        var Event = namespace === 'state' ? _events.StateEvent : _events.ActionEvent;\n\t                        var event = new Event(type, target, transition);\n\t\n\t                        // pre-bind handlers, scopes and params\n\t                        // this way scope and params don't need to be passed around\n\t                        // and the call from Transition is always just `value = handler()`\n\t                        return function () {\n\t                            return handler.apply(scope, [event, fsm].concat(params));\n\t                        };\n\t                    });\n\t\n\t                    // add to queue\n\t                    queue = queue.concat(handlers);\n\t                })();\n\t            }\n\t        });\n\t\n\t        // return\n\t        transition.handlers = queue;\n\t        return transition;\n\t    },\n\t\n\t    force: function force(fsm, state) {\n\t        var transition = new Transition(fsm, '', fsm.state, state);\n\t        transition.paused = fsm.transition ? fsm.transition.paused : false;\n\t        return transition;\n\t    }\n\t\n\t};\n\n/***/ }\n/******/ ])\n});\n;\n\n\n/** WEBPACK FOOTER **\n ** StateMachine.min.js\n **/"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n/** WEBPACK FOOTER **\n ** webpack/bootstrap 50e9f9a6db545430895c\n **/","import Config from './core/classes/Config';\nimport HandlerMap from './core/maps/HandlerMap';\nimport TransitionMap from './core/maps/TransitionMap';\nimport Transition from './core/classes/Transition';\nimport { diff } from './core/utils/utils';\n\n\n/**\n * StateMachine constructor\n *\n * @param   {Object|null}    options\n * @constructor\n */\nfunction StateMachine (options)\n{\n    this.transitions    = new TransitionMap();\n    this.handlers       = new HandlerMap(this);\n    this.initialize(options);\n}\n\n/**\n * StateMachine prototype\n *\n * The property examples below illustrate a 4-state machine, with states:\n *\n * - intro > settings > summary > end\n *\n * And actions:\n *\n * - back | next | restart | finish\n */\nStateMachine.prototype =\n{\n    // -----------------------------------------------------------------------------------------------------------------\n    // properties\n\n        /**\n         * Configuration object\n         *\n         * @var {Config}\n         */\n        config      : null,\n\n        /**\n         * Map of all transitions\n         *\n         * @var {TransitionMap}\n         */\n        transitions : null,\n\n        /**\n         * Map of all handlers\n         *\n         * @var {HandlerMap}\n         */\n        handlers    : null,\n\n        /**\n         * Any active Transition object that is driving the state change\n         *\n         * @var {Transition}\n         */\n        transition  : null,\n\n        /**\n         * The current state\n         *\n         * @var {string}\n         */\n        state       : '',\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // private methods\n\n        /**\n         * Initialize the FSM with a config object\n         *\n         * @private\n         * @param options\n         */\n        initialize:function (options)\n        {\n            // state\n            this.state          = '';\n\n            // build config\n            let config  = new Config(options);\n            this.config = config;\n\n            // pre-process all transitions\n            let transitions = [];\n            if(Array.isArray(options.transitions))\n            {\n                options.transitions.map( tx =>\n                {\n                    transitions = transitions.concat(this.transitions.parse(tx));\n                });\n            }\n\n            // add transitions\n            transitions.map( transition =>\n            {\n                this.transitions.add(transition.action, transition.from, transition.to);\n            });\n\n            // get initial state (must be done after state collation)\n            if( ! config.initial )\n            {\n                config.initial = this.transitions.getStates()[0];\n            }\n\n            // add handlers\n            if(options.handlers)\n            {\n                for(let name in options.handlers)\n                {\n                    if(options.handlers.hasOwnProperty(name))\n                    {\n                        this.on(name, options.handlers[name]);\n                    }\n                }\n            }\n\n            // add methods\n            if(options.methods)\n            {\n                if(!this.config.scope)\n                {\n                    this.config.scope = this;\n                }\n                for(var name in options.methods)\n                {\n                    if(options.methods.hasOwnProperty(name) && !this.hasOwnProperty(name))\n                    {\n                        this[name] = options.methods[name];\n                    }\n                }\n            }\n\n            // start\n            if(this.config.start)\n            {\n                this.start();\n            }\n\n            // return\n            return this;\n        },\n\n        start: function ()\n        {\n            this.state = this.config.initial;\n            this.handlers.trigger('system.start');\n            this.handlers.trigger('system.change', this.state);\n            return this;\n        },\n\n        /**\n         * Reset the FSM to the initial, or supplied, state\n         *\n         * @returns {StateMachine}\n         */\n        reset:function(initial = '')\n        {\n            let state = initial || this.config.initial;\n            this.handlers.trigger('system.reset');\n            if(this.transition)\n            {\n                this.transition.cancel();\n                delete this.transition;\n            }\n            if(this.state !== state)\n            {\n                this.state = state;\n                this.handlers.trigger('system.change', this.state);\n            }\n            return this;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // api\n\n        /**\n         * Attempt to run an action, resulting in a transition to a state\n         *\n         * @param   {string}    action\n         * @param   {*[]}       rest\n         * @returns {boolean}\n         */\n        do: function (action, ...rest)\n        {\n            if(this.canDo(action) && !this.isPaused())\n            {\n                this.transition = Transition.create(this, action, rest);\n                this.transition.exec();\n                return true;\n            }\n            return false;\n        },\n\n        /**\n         * Attempt to go to a state\n         *\n         * Queries TransitionMap instance to see if a transition exists, then calls the related action if it does\n         *\n         * @param   {string}    state\n         * @param   {boolean}   [force]\n         * @returns {boolean}\n         */\n        go: function (state, force = false)\n        {\n            if(this.has(state))\n            {\n                if(force)\n                {\n                    if(this.transition)\n                    {\n                        this.transition.clear();\n                    }\n                    this.transition = Transition.force(this, state);\n                    return this.end();\n                }\n                var action = this.transitions.getActionFor(this.state, state);\n                if(action)\n                {\n                    return this.do(action);\n                }\n                this.config.errors > 0 && console.warn('No transition exists from \"%s\" to \"%s\"', this.state, state);\n                return false;\n            }\n            this.config.errors > 0 && console.warn('No such state \"%s\"', state);\n            return false;\n        },\n\n        /**\n         * Query transition map to see if a named action is available\n         *\n         * @param   {string}        action\n         * @returns {boolean}\n         */\n        canDo: function (action)\n        {\n            return this.transitions.getActionsFrom(this.state).indexOf(action) !== -1;\n        },\n\n        /**\n         * Query transition map to see if a state is available to go to\n         *\n         * @param to\n         * @return {boolean}\n         */\n        canGo: function (to)\n        {\n            return this.transitions.getActionFor(this.state, to) !== null;\n        },\n\n        /**\n         * Test if a state exists\n         *\n         * @param   {string}    state\n         * @return  {boolean}\n         */\n        has: function(state)\n        {\n            return this.transitions.hasState(state);\n        },\n\n        /**\n         * Test if the current state is the same as the supplied one\n         *\n         * @param   {string}    state       A state name to compare against the current state\n         * @returns {boolean}\n         */\n        is: function (state)\n        {\n            return state === this.state;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // flags\n\n        /**\n         * Test if the FSM has started\n         *\n         * @returns {boolean}\n         */\n        isStarted: function ()\n        {\n            return this.state !== '';\n        },\n\n        /**\n         * Test if the FSM is transitioning\n         *\n         * @returns {boolean}\n         */\n        isTransitioning: function ()\n        {\n            return !! this.transition;\n        },\n\n        /**\n         * Test if the FSM is paused (whilst transitioning)\n         *\n         * @returns {boolean}\n         */\n        isPaused: function ()\n        {\n            return this.transition\n                ? this.transition.paused\n                : false;\n        },\n\n        /**\n         * Test if the FSM is on the \"final\" state\n         *\n         * @returns {boolean}\n         */\n        isComplete: function ()\n        {\n            return this.state === this.config.final;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // transitions\n\n        /**\n         * Pause any current transition\n         *\n         * @returns {StateMachine}\n         */\n        pause: function ()\n        {\n            if(this.transition && !this.isPaused())\n            {\n                this.transition.pause();\n            }\n            return this;\n        },\n\n        /**\n         * Resume any current transition\n         *\n         * @returns {StateMachine}\n         */\n        resume: function ()\n        {\n            if(this.transition && this.isPaused())\n            {\n                this.transition.resume();\n            }\n            return this;\n        },\n\n        /**\n         * Cancel any current transition\n         *\n         * @returns {StateMachine}\n         */\n        cancel: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.from;\n                this.transition.cancel();\n                delete this.transition;\n            }\n            return this;\n        },\n\n        /**\n         * End any current transition, skipping remaining handlers\n         *\n         * @returns {StateMachine}\n         */\n        end: function ()\n        {\n            if(this.transition)\n            {\n                this.state = this.transition.to;\n                this.transition.clear();\n                delete this.transition;\n                this.handlers.trigger('system.change', this.state);\n                if(this.isComplete())\n                {\n                    this.handlers.trigger('system.complete');\n                }\n            }\n            return this;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // actions\n\n        /**\n         * Add a transition\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {StateMachine}\n         */\n        add: function (action, from, to)\n        {\n            // 1 argument: shorthand transition, i.e 'next : a > b'\n            if(arguments.length === 1)\n            {\n                var transitions = this.transitions.parse(action);\n                transitions.map( tx => this.add(tx.action, tx.from, tx.to));\n                return this;\n            }\n\n            // 3 arguments: longhand transition\n            updateTransitions(this, 'add', () => this.transitions.add(action, from, to) );\n            return this;\n        },\n\n        /**\n         * Remove a state\n         *\n         * @param   {string}    state\n         * @return  {StateMachine}\n         */\n        remove: function (state)\n        {\n            this.handlers.remove('state.' + state);\n            updateTransitions(this, 'remove', () => this.transitions.remove(state) );\n            return this;\n        },\n\n\n    // -----------------------------------------------------------------------------------------------------------------\n    // handlers\n\n        /**\n         * Add an event handler\n         *\n         * Event handler signatures are built from the following grammar:\n         *\n         * - token      foo\n         * - property   .foo\n         * - event      :foo\n         * - action     @foo\n         * - targets    (foo bar baz)\n         *\n         * For example:\n         *\n         * - change\n         * - transition.pause\n         * - next:end\n         * - (a b)@next\n         * - a@next\n         *\n         * The main event types are unique, so can be used without the namespace:\n         *\n         * - change\n         * - pause\n         * - complete\n         * - ...\n         *\n         * If your states and events are unique, they can also be used without qualification.\n         *\n         * See docs and demo for more information\n         *\n         * @param   {string}        id\n         * @param   {Function}      fn\n         * @return  {StateMachine}\n         */\n        on: function (id, fn)\n        {\n            this.parse(id, this.config.invalid, this.config.errors)\n                .forEach( meta => this.handlers.add(meta.path, fn) );\n            return this;\n        },\n\n        off: function (id, fn)\n        {\n            this.parse(id, this.config.invalid, this.config.errors)\n                .forEach( meta => this.handlers.remove(meta.path, fn) );\n            return this;\n        },\n\n    \n    // -----------------------------------------------------------------------------------------------------------------\n    // utilities\n\n        /**\n         * Parses a handler id string into HandlerMeta objects\n         *\n         * @param   {string}    id\n         * @param   {boolean}   invalid\n         * @param   {number}    errors\n         * @returns {HandlerMeta[]}\n         */\n        parse: function (id, invalid = false, errors = 0)\n        {\n            return this.handlers.parse(id).filter(result =>\n            {\n                // picks up unrecognised handlers, namespaces, etc\n                if(result instanceof Error)\n                {\n                    if(errors == 2)\n                    {\n                        throw result;\n                    }\n                    errors == 1 && console.warn(result.message);\n                    return false;\n                }\n\n                // picks up unrecognised states and actions\n                if(result.target !== '*')\n                {\n                    let error = '';\n\n                    if(result.namespace === 'state')\n                    {\n                        if(!this.transitions.hasState(result.target))\n                        {\n                            error = 'Unrecognised state \"' +result.target+ '\" in handler \"' +result.id+ '\"';\n                        }\n                    }\n                    else if(result.namespace === 'action')\n                    {\n                        if(!this.transitions.hasAction(result.target))\n                        {\n                            error = 'Unrecognised action \"' +result.target+ '\" in handler \"' +result.id+ '\"';\n                        }\n                    }\n                    else if(result.namespace === 'state/action')\n                    {\n                        // variables\n                        let [state, action] = result.target.split('@');\n\n                        // test for state and action\n                        if(!this.transitions.hasState(state))\n                        {\n                            error = 'Unrecognised state \"' +state+ '\" in handler \"' +result.id+ '\"';\n                        }\n                        if(!this.transitions.hasAction(action))\n                        {\n                            error = 'Unrecognised action \"' +action+ '\" in handler \"' +result.id+ '\"';\n                        }\n                    }\n\n                    // if we have an error, the result was not an existing state or action\n                    if(error)\n                    {\n                        if(errors == 2)\n                        {\n                            throw new Error(error);\n                        }\n                        errors == 1 && console.warn(error);\n                        return !!invalid;\n                    }\n                }\n\n                // must be valid\n                return true\n            });\n        },\n\n        trigger: function (id, ...rest)\n        {\n            this.handlers.parse(id).map( meta => this.handlers.trigger.apply(this.handlers, [meta.path, ...rest]) );\n            return this;\n        }\n\n};\n\nStateMachine.prototype.constructor = StateMachine;\n\nexport default StateMachine;\n\n\n// ---------------------------------------------------------------------------------------------------------------------\n// static methods\n\n    /**\n     * Factory method\n     *\n     * @param   options\n     * @returns {StateMachine}\n     */\n    StateMachine.create = function(options)\n    {\n        return new StateMachine(options);\n    };\n\n    /**\n     * Gets the default order events should be called in\n     * @returns {string[]}\n     */\n    StateMachine.getDefaultOrder = function ()\n    {\n        return [\n            'action.*.start',\n            'action.{action}.start',\n            'state.*.{action}',\n            'state.{from}.{action}',\n            'state.{from}.leave',\n            'state.*.leave',\n            'state.*.enter',\n            'state.{to}.enter',\n            'action.{action}.end',\n            'action.*.end'\n        ];\n    };\n\n\n// ---------------------------------------------------------------------------------------------------------------------\n// helper functions\n\n    /**\n     * Utility method to update transitions and dispatch events\n     *\n     * Saves duplicating the following code in both add() and remove() methods\n     *\n     * @param   {StateMachine}  fsm\n     * @param   {string}        method\n     * @param   {Function}      callback\n     */\n    function updateTransitions(fsm, method, callback)\n    {\n        var statesBefore    = fsm.transitions.getStates();\n        var actionsBefore   = fsm.transitions.getActions();\n        callback();\n        var statesAfter     = fsm.transitions.getStates();\n        var actionsAfter    = fsm.transitions.getActions();\n\n        // calculate differences\n        var states          = diff(statesBefore, statesAfter);\n        var actions         = diff(actionsBefore, actionsAfter);\n\n        // dispatch events\n        states.map ( state  => fsm.handlers.trigger('system.state.'  + method, state) );\n        actions.map( action => fsm.handlers.trigger('system.action.' + method, action) );\n    }\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/StateMachine.js\n **/","export function isObject (value)\n{\n    return Object.prototype.toString.call(value) === '[object Object]';\n}\n\nexport function isArray (value)\n{\n    return value instanceof Array;\n}\n\nexport function isString (value)\n{\n    return typeof value === 'string';\n}\n\nexport function isFunction(value)\n{\n    return value instanceof Function;\n}\n\nexport function isDefined (value)\n{\n    return typeof value !== 'undefined';\n}\n\nexport function isUndefined (value)\n{\n    return typeof value === 'undefined';\n}\n\nexport function trim (value)\n{\n    return String(value || '').replace(/^\\s+|\\s+$/g, '');\n}\n\nexport function diff (a, b)\n{\n    var da = b.filter( v => a.indexOf(v) < 0 );\n    var db = a.filter( v => b.indexOf(v) < 0 );\n    return db.concat(da)\n}\n\nexport function toHash(values) {\n    return values.reduce(function (obj, value) {\n        obj[value] = true;\n        return obj;\n    }, {})\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/utils/utils.js\n **/","export default function Config (options)\n{\n    'scope start initial final invalid errors'\n        .match(/\\w+/g)\n        .map( name =>\n        {\n            if(options.hasOwnProperty(name))\n            {\n                this[name] = options[name];\n            }\n        });\n\n    // order\n    this.order      = options.order || StateMachine.getDefaultOrder();\n\n    // defaults\n    this.defaults   = Object.assign({\n\n        // allow user to specify alternate triggers for event and action ids\n        action      :'start',\n        state       :'enter'\n\n    }, options.defaults);\n}\n\nConfig.prototype =\n{\n    /**\n     * An optional scope to run handler functions in\n     *\n     * @var object\n     */\n    scope       : null,\n\n    /**\n     * A boolean to automatically start the state machine in the initial state\n     *\n     * @var boolean\n     */\n    start       : true,\n\n    /**\n     * A string to indicate which state to start on; defaults to ''\n     *\n     * @var string\n     */\n    initial     : '',\n\n    /**\n     * A string indicating the state to trigger a complete event; defaults to ''\n     *\n     * @var string\n     */\n    final       : '',\n\n    /**\n     * A boolean to allow non-existent states and actions to be added to the handlers object; defaults to false (disallow)\n     *\n     * @var boolean\n     */\n    invalid     : false,\n\n    /**\n     * A number indicating how to handle invalid or erroneous actions; defaults to 1 (warn)\n     *\n     *  - 0 : quiet\n     *  - 1 : console.warn()\n     *  - 2 : throw an error\n     *\n     * @var number\n     */\n    errors      : 1,\n\n    /**\n     * The order to run transition callbacks in\n     *\n     * @type {string[]} type.target\n     */\n    order       : null,\n\n    /**\n     * Sets defaults for various declarations\n     *\n     * Available options are:\n     *\n     * - action: (start|end)\n     * - state: (enter|leave)\n     *\n     * @type {Object}\n     */\n    defaults    : null,\n\n};\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/classes/Config.js\n **/","import ValueMap from './ValueMap';\nimport { SystemEvent, TransitionEvent, StateEvent, ActionEvent } from '../objects/events';\nimport { isFunction } from '../utils/utils';\n\nimport parseHandler from '../parsers/HandlerParser';\n\nfunction HandlerMap (fsm)\n{\n    this.fsm    = fsm;\n    this.map    = new ValueMap();\n}\n\nHandlerMap.prototype =\n{\n\n\tfsm: null,\n\n\tmap: null,\n\n    /**\n     * Parse event handler grammar into a HandlerMeta structure\n     *\n     * @param   {string}        id      The handler id to parse, i.e. '@next', 'intro:end', 'change', etc\n     * @returns {HandlerMeta[]}\n     */\n    parse: function (id)\n    {\n        return parseHandler(id, this.fsm.config.defaults);\n    },\n\n    /**\n     * Directly add a new handler\n     *\n     * @param   {string}    path    A 'namespace.target.type' target path to add a handler to\n     * @param   {Function}  fn      A callback function\n     * @returns {HandlerMap}\n     */\n    add: function (path, fn)\n    {\n        // check handler is a function\n        if(!isFunction(fn))\n        {\n            throw new Error('Error assigning \"' +path+ '\" handler; callback is not a function', fn);\n        }\n\n        this.map.insert(path, fn);\n        return this;\n    },\n\n    /**\n     * Directly remove a handler target\n     *\n     * @param   {string}    path    A 'namespace.target.type' parent to a handler removed from\n     * @param   {Function}  fn      The instance of the callback function\n     * @returns {HandlerMap}\n     */\n    remove: function (path, fn)\n    {\n        this.map.remove(path, fn);\n        return this;\n    },\n\n    /**\n     * Get all handlers for a valid target path\n     *\n     * @param   {string}    path    A 'namespace.target.type' target path\n     * @returns {Function[]}        An array of callback functions\n     */\n    get:function(path)\n    {\n        return this.map.get(path);\n    },\n\n    /**\n     * Dispatch an event\n     *\n     * @param   {string}    path\n     * @param   {*}         value\n     * @returns {StateMachine}\n     */\n    trigger: function (path, value = null)\n    {\n        // create lookup path\n        let [namespace, type, method] = path.match(/\\w+/g);\n\n        // build event\n        let event;\n        if(/^system\\.(state|action)\\./.test(path))\n        {\n            event = type === 'state'\n                ? new StateEvent(method, value)\n                : new ActionEvent(method, value);\n        }\n        else\n        {\n            event = namespace === 'system'\n                ? new SystemEvent(type, value)\n                : new TransitionEvent(type);\n        }\n\n        // dispatch\n        let handlers = this.map.get(path);\n        if(handlers)\n        {\n            handlers.map(fn => fn(event, this.fsm) );\n        }\n    }\n\n};\n\nexport default HandlerMap;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/HandlerMap.js\n **/","import {isObject, isArray, isDefined, isUndefined} from '../utils/utils';\n\n/**\n * Utility class to create, modify and delete nested hashes and values\n *\n * @constructor\n */\nexport default function ValueMap (data)\n{\n    this.data = data || {};\n}\n\nValueMap.prototype =\n{\n    data: null,\n\n    set: function (path, value)\n    {\n        set(this.data, path, value);\n        return this;\n    },\n\n    add:function(path, value)\n    {\n        add(this.data, path, value);\n        return this;\n    },\n\n    insert:function(path, value)\n    {\n        insert(this.data, path, value);\n        return this;\n    },\n\n    get:function(path)\n    {\n        return get(this.data, path);\n    },\n\n    has: function (path, value = undefined)\n    {\n        return has(this.data, path, value)\n    },\n\n    indexOf: function (path, value)\n    {\n        return indexOf(this.data, path, value)\n    },\n\n    remove: function (path, value = undefined)\n    {\n        remove(this.data, path, value);\n        return this;\n    },\n\n    keys:function(path)\n    {\n        return Object.keys(get(this.data, path));\n    },\n\n    values:function(path)\n    {\n        return values(this.data, path);\n    }\n\n};\n\nfunction create(obj, keys)\n{\n    let key;\n    while(keys.length)\n    {\n        key = keys.shift();\n        if( ! isObject(obj[key]) )\n        {\n            obj[key] = {};\n        }\n        obj = obj[key];\n    }\n    return obj;\n}\n\nexport function set(obj, path, value, index = -1)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    obj[key] = value;\n}\n\nfunction add(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    obj[key].push(value);\n}\n\nfunction insert(obj, path, value)\n{\n    let keys = String(path).split('.'),\n        key  = keys.pop();\n    obj = create(obj, keys);\n    if( ! isArray(obj[key]) )\n    {\n        obj[key] = [];\n    }\n    let parent = obj[key],\n        index = parent.indexOf(value);\n    if(index === -1)\n    {\n        parent.push(value);\n    }\n    else\n    {\n        parent[index] = value;\n    }\n}\n\nexport function get(obj, path)\n{\n    if(isUndefined(path) || path == '')\n    {\n        return obj;\n    }\n\n    let key,\n        keys = String(path).split('.');\n    while(keys.length > 1)\n    {\n        key = keys.shift();\n        if( ! obj.hasOwnProperty(key) )\n        {\n            return;\n        }\n        obj = obj[key];\n    }\n    key = keys.shift();\n    return obj[key];\n}\n\nexport function has(obj, path, value)\n{\n    let parent = get(obj, path);\n    return !! (isArray(parent) && isDefined(value)\n        ? parent.indexOf(value) !== -1\n        : isUndefined(value)\n            ? isDefined(parent)\n            : parent === value);\n}\n\nexport function indexOf (obj, path, value)\n{\n    let arr = get(obj, path);\n    if(isArray(arr))\n    {\n        return arr.indexOf(value);\n    }\n    return -1;\n}\n\nexport function remove(obj, path, value)\n{\n    let parent = obj,\n        keys = String(path || '').split('.'),\n        key = keys.pop();\n\n    if(keys.length)\n    {\n        parent = get(obj, keys.join('.'))\n    }\n    if(isDefined(value) && isArray(parent[key]))\n    {\n        let target = parent[key];\n        var index = target.indexOf(value);\n        if(index > -1)\n        {\n            target.splice(index, 1);\n            if(target.length === 0)\n            {\n                delete parent[key];\n            }\n            return true;\n        }\n        return false;\n    }\n    else\n    {\n        if(isObject(parent) && obj.hasOwnProperty(key))\n        {\n            delete parent[key];\n            return true;\n        }\n    }\n    return false\n}\n\nexport function values(obj, path)\n{\n    var values = [];\n    var target = get(obj, path);\n    if(isObject(target))\n    {\n        for(var name in target)\n        {\n            if(target.hasOwnProperty(name))\n            {\n                values.push(target[name]);\n            }\n        }\n    }\n    return values;\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/ValueMap.js\n **/","// ------------------------------------------------------------------------------------------------\n// setup\n\n    /**\n     * @prop {string}       namespace   The Event namespace; i.e. state or action\n     * @prop {string}       type        The Event type;      i.e. leave/enter (state) or start/end (action)\n     * @prop {string}       target      The Event target;    i.e. intro (state), next (action), or * (all states or types)\n     * @prop {Transition}   transition  The transition which generated the event\n     */\n    let event =\n    {\n        // properties\n        namespace   : null,\n        type        : null,\n        target      : null,\n        transition          : null\n    };\n\n    function initialize (event, namespace, type, target, transition)\n    {\n        event.namespace     = namespace;\n        event.type          = type;\n        event.target        = target;\n        event.transition    = transition;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// ActionEvent\n\n    export function ActionEvent (type, target, transition)\n    {\n        initialize(this, 'action' ,type, target, transition);\n    }\n    ActionEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// StateEvent\n\n    export function StateEvent (type, target, transition)\n    {\n        initialize(this, 'state' ,type, target, transition);\n    }\n    StateEvent.prototype = event;\n\n\n// ------------------------------------------------------------------------------------------------\n// SystemEvent\n\n    export function SystemEvent (type, value)\n    {\n        this.type   = type;\n        this.value  = value;\n    }\n\n    SystemEvent.prototype =\n    {\n        namespace   : 'system',\n        type        : '',\n        value       : null\n    };\n\n\n// ------------------------------------------------------------------------------------------------\n// TransitionEvent\n\n    export function TransitionEvent (type)\n    {\n        this.type = type;\n    }\n\n    TransitionEvent.prototype =\n    {\n        namespace   : 'transition',\n        type        : ''\n    };\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/objects/events.js\n **/","import HandlerMeta from './HandlerMeta';\nimport Lexer from '../lexer/Lexer'\nimport { trim } from '../utils/utils';\nimport { ParseError } from '../objects/errors';\n\n\n// ------------------------------------------------------------------------------------------------\n// functions\n\n    function isSystem(token)\n    {\n        return /^(start|change|complete|reset)$/.test(token);\n    }\n\n    function isTransition(token)\n    {\n        return /^(pause|resume|cancel)$/.test(token);\n    }\n\n    function expandGroups (input)\n    {\n        var rx \t\t= /\\((.+?)\\)/;\n        var matches = input.match(rx);\n        if(matches)\n        {\n            var group = matches[0];\n            var items = matches[1].match(/\\S+/g);\n            if(items)\n            {\n                items = items.map(item => input.replace(group, item));\n                if(rx.test(items[0]))\n                {\n                    return items.reduce( (output, input) => {\n                        return output.concat(expandGroups(input));\n                    }, []);\n                }\n                return items;\n            }\n        }\n        return [input];\n    }\n\n    function addPath (path, namespace, target)\n    {\n        results.push(new HandlerMeta(_id, path, namespace, target));\n        return true;\n    }\n\n    function addError (message, path)\n    {\n        var error = new ParseError(message, path, _id);\n        results.push(error);\n        return false;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// export\n\n    /**\n     * Parses event handler id into a HandlerMeta results containing handler paths\n     *\n     * @param   {string}    id          The handler id to parse, i.e. '@next', 'intro:end', 'change', etc\n     * @param   {Object}    defaults     A StateMachine instance to test for states and actions\n     * @return  {HandlerMeta[]}\n     */\n    export default function parse(id, defaults)\n    {\n        // pre-parse handler\n        id          = trim(id);\n\n        // objects\n        _id         = id;\n        _defaults   = defaults;\n        results     = [];\n\n        // parse\n        parser.parse(id, defaults);\n\n        // return\n        return results;\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// objects\n\n    let results,\n        _defaults,\n        _id;\n\n    var patterns  =\n    {\n        // start pause intro\n        alias               : /^(\\w+)$/,\n\n        // system.start state.add\n        namespaced          : /^(system|transition|state|action):(\\w+)$/,\n\n        // @next @quit\n        oneAction           : /^@(\\w+)$/,\n\n        // @next:start @next:end\n        oneActionEvent      : /^@(\\w+):(start|end)$/,\n\n        // :start :end\n        anyActionEvent      : /^:(start|end)$/,\n\n        // intro form\n        oneState            : /^#(\\w+)$/,\n\n        // intro:enter intro:leave\n        oneStateEvent       : /^#?(\\w+):(leave|enter)$/,\n\n        // :enter :leave\n        anyStateEvent       : /^:(enter|leave)$/,\n\n        // intro@next\n        oneStateAction      : /^#?(\\w+)@(\\w+)$/\n    };\n\n    let lexer   = new Lexer(patterns);\n\n    var parser =\n    {\n        /**\n         * Parses event handler id into HandlerMeta instance\n         *\n         * Resolving namespace, type and target properties\n         *\n         * @param   {string}        id\n         * @param   {Object}        defaults\n         */\n        parse (id, defaults)\n        {\n            // expand groups\n            let paths   = expandGroups(id);\n\n            // process paths\n            paths.map( path => this.parsePath(path) );\n        },\n\n        parsePath:function(path)\n        {\n            let tokens;\n            try\n            {\n                tokens = lexer.process(path)\n            }\n            catch(error)\n            {\n                return addError('Unrecognised pattern \"' +path+ '\"', path);\n            }\n\n            if(tokens && tokens.length)\n            {\n                // variables\n                let token   = tokens.shift();\n                var fn      = this[token.type];\n\n                // process\n                if(fn)\n                {\n                    return fn.apply(this, token.values);\n                }\n                return addError('Unknown token type \"' +token.type+ '\"', path);\n            }\n        },\n\n        alias (value)\n        {\n            if (isSystem(value))\n            {\n                return addPath('system.' + value, 'system');\n            }\n            if (isTransition(value))\n            {\n                return addPath('transition.' + value, 'transition');\n            }\n            return this.oneState(value);\n        },\n\n        namespaced (namespace, type)\n        {\n            var path = namespace + '.' + type;\n\n            if(namespace === 'system' && isSystem(type) || namespace === 'transition' && isTransition(type))\n            {\n                return addPath(path, namespace);\n            }\n\n            if(/^(state|action)$/.test(namespace) && /^(add|remove)$/.test(type))\n            {\n                return addPath('system.' + path, 'system');\n            }\n\n            addError('Unrecognised type \"' +type+'\" for namespace \"' +namespace+ '\"', _id)\n        },\n\n        oneState (state)\n        {\n            return addPath('state.' + state + '.' + _defaults.state, 'state', state);\n        },\n\n        oneAction (action)\n        {\n            return addPath('action.' +action+ '.' +_defaults.action, 'action', action);\n        },\n\n        anyActionEvent (event)\n        {\n            return addPath('action.*.' + event, 'action', '*');\n        },\n\n        oneActionEvent (action, event)\n        {\n            return addPath('action.' +action+ '.' + event, 'action', action);\n        },\n\n        anyStateEvent (event)\n        {\n            return addPath('state.*.' + event, 'state', '*');\n        },\n\n        oneStateEvent (state, event)\n        {\n            return addPath('state.' +state+ '.' + event, 'state', state);\n        },\n\n        oneStateAction (state, action)\n        {\n            return addPath('state.' +state+ '.' + action, 'state/action', state + '@' + action);\n        }\n\n    };\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/HandlerParser.js\n **/","function HandlerMeta (id, path, namespace = '', target = '')\n{\n    this.id         = id;\n    this.path       = path;\n    if(namespace)\n    {\n        this.namespace  = namespace;\n    }\n    if(target)\n    {\n        this.target     = target;\n    }\n}\n\nHandlerMeta.prototype =\n{\n    id          : '',\n    path        : '',\n    namespace   : '',\n    target      : ''\n};\n\nexport default HandlerMeta;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/HandlerMeta.js\n **/","import Rule from './Rule';\nimport Token from './Token';\n\n/**\n * Simple Lexer class\n *\n * @param   {Object}    rules   A hash of id:RegExp values\n * @constructor\n */\nexport default function Lexer(rules)\n{\n    this.rules = [];\n    if(rules)\n    {\n        Object.keys(rules).map( name => this.addRule(name, rules[name]) );\n    }\n}\n\nLexer.prototype =\n{\n    /** @var {String} */\n    source  : null,\n\n    /** @var {Rule[]} */\n    rules   : null,\n\n    /** @var {Token[]} */\n    tokens  : null,\n\n    /** @var {Number} */\n    index   : 0,\n\n    /**\n     * Process a source string into an array of Tokens based on Rules\n     *\n     * @param source\n     * @returns {Token[]}\n     */\n    process:function(source)\n    {\n        this.source = source;\n        this.tokens = [];\n        this.index  = 0;\n        this.next();\n        return this.tokens;\n    },\n\n    /**\n     * Adds a new rule\n     *\n     * @protected\n     * @param name\n     * @param rx\n     */\n    addRule:function(name, rx)\n    {\n        this.rules.push(new Rule(name, rx));\n    },\n\n    next:function()\n    {\n        if(this.index < this.source.length)\n        {\n            let source  = this.source.substr(this.index);\n            let state = this.rules.some(rule =>\n            {\n                var matches = source.match(rule.rx);\n                if(matches)\n                {\n                    this.tokens.push(new Token(rule.name, matches));\n                    this.index += matches[0].length;\n                    return true;\n                }\n                return false;\n            });\n\n            // not matched\n            if(!state)\n            {\n                throw new LexerError('Unable to match source at position ' + this.index + ': \"' +source+'\"', this.source, this.index);\n            }\n\n            // match\n            this.next();\n        }\n    }\n};\n\nfunction LexerError(message, source, index)\n{\n    this.message = message;\n    this.source = source;\n    this.index = index;\n}\n\nLexerError.prototype = new Error;\nLexerError.prototype.constructor = LexerError;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/lexer/Lexer.js\n **/","/**\n * A parsing rule, designed to match part of a string\n *\n * @param   {string}    name\n * @param   {RegExp}    rx\n */\nfunction Rule(name, rx)\n{\n    this.name = name;\n    this.rx = rx;\n}\n\nexport default Rule;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/lexer/Rule.js\n **/","/**\n * Token class, representing the type and value of part of a source string\n *\n * @param       {string}    type\n * @param       {string[]}  matches\n *\n * @property    {string}    type\n * @property    {string}    match\n * @property    {string[]}  values\n */\nfunction Token(type, matches)\n{\n    this.type       = type;\n    this.match      = matches[0];\n    this.values     = matches.slice(1);\n}\n\nexport default Token;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/lexer/Token.js\n **/","export function ParseError(message, path, id)\n{\n    this.message = message;\n    this.path = path;\n    this.id = id;\n}\n\nParseError.prototype = Error.prototype;\nParseError.prototype.name = 'ParseError';\nParseError.prototype.constructor = ParseError;\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/objects/errors.js\n **/","import ValueMap from './ValueMap';\nimport parseTransition from '../parsers/TransitionParser'\nimport { trim } from '../utils/utils'\n\nfunction TransitionMap ()\n{\n    this.map        = new ValueMap();\n    this.states     = [];\n    this.actions    = [];\n}\n\nTransitionMap.prototype =\n{\n    // ------------------------------------------------------------------------------------------------\n    // properties\n\n        map     : null,\n        states  : null,\n        actions : null,\n\n\n    // ------------------------------------------------------------------------------------------------\n    // add and remove states\n\n        /**\n         * Add event handler parsing\n         *\n         * @param   {string}    tx\n         * @returns {TransitionMeta[]}\n         */\n        parse: function (tx)\n        {\n            return parseTransition(tx);\n        },\n\n        /**\n         * Adds a new transition\n         * \n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @returns {TransitionMap}\n         */\n        add: function (action, from, to)\n        {\n            // procss variables\n            action  = trim(action);\n            from    = trim(from);\n            to      = typeof to === 'string' ? trim(to) : to;\n\n            // check for wildcards\n            if(to === '*')\n            {\n                throw new Error('Transitioning to a wildcard doesn\\'t make sense');\n            }\n\n            // add transition\n            this.map.set(from + '.' + action, to);\n            return update(this);\n        },\n\n        /**\n         * Removes an existing state\n         *\n         * @param   {string}    state\n         * @returns {TransitionMap}\n         */\n        remove: function (state)\n        {\n            // remove \"from\" state\n            this.map.remove(state);\n\n            // remove \"to\" states\n            let data = this.map.data;\n            for(let name in data)\n            {\n                let from = data[name];\n                for(let action in from)\n                {\n                    if(from[action] === state)\n                    {\n                        delete from[action];\n                    }\n                }\n            }\n\n            // update and return\n            return update(this);\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // accessors\n\n        /**\n         * Get all available actions (or action => states map) for a given state\n         *\n         * @param   {string}    from        Name of a state to get actions for\n         * @param   {boolean}   [asMap]     Optional boolean to return a Object of action:state properties. Defaults to false\n         * @returns {string[]|Object}       An array of string actions, or a hash of action:states\n         */\n        getActionsFrom: function (from, asMap = false)\n        {\n            if(this.has(from) || this.has('*'))\n            {\n                // get all available actions\n                let actions     = this.map.get(from) || {};\n                let wildcard    = this.map.get('*');\n                let output      = Object.assign({}, actions);\n\n                // append wildcard actions\n                if(wildcard)\n                {\n                    for(var action in wildcard)\n                    {\n                        let value = wildcard[action];\n                        if(value !== from && !actions[action])\n                        {\n                            output[action] = value;\n                        }\n                    }\n                }\n\n                // return map or keys\n                return output\n                    ? asMap\n                        ? output\n                        : Object.keys(output)\n                    : [];\n            }\n            return [];\n        },\n\n        /**\n         * Get the first available action to move from one state to another (if there is one)\n         *\n         * @param   {string}    from\n         * @param   {string}    to\n         * @return  {string|null}\n         */\n        getActionFor: function (from, to)\n        {\n            let actions = this.map.get(from);\n            for(let action in actions)\n            {\n                if(actions[action] === to)\n                {\n                    return action;\n                }\n            }\n            return null;\n        },\n\n        /**\n         * Get all available \"to\" states for a given state\n         *\n         * Loops over all actions and returns a unique array of \"to\" states\n         *\n         * @param   {string|null}    [from]     Optional name of a from state to get states for. Defaults to the current state\n         * @returns {string[]}                  An array of string states\n         */\n        getStatesFrom: function (from)\n        {\n            if(this.hasState(from))\n            {\n                let actions = this.getActionsFrom(from, true);\n                return Object.keys(actions).map( name => actions[name] );\n            }\n            return null;\n        },\n\n        /**\n         * Get the target \"to\" state from a \"from\" state via an \"action\"\n         *\n         * @param   {string}    from\n         * @param   {string}    action\n         * @returns {string}\n         */\n        getStateFor: function (from, action)\n        {\n            let states = this.getActionsFrom(from, true) || {};\n            return states[action];\n        },\n\n        /**\n         * Get all states within the system\n         *\n         * @return  {string[]}\n         */\n        getStates: function ()\n        {\n            return [].concat(this.states);\n        },\n\n        /**\n         * Get all actions within the system\n         *\n         * @return  {string[]}\n         */\n        getActions: function ()\n        {\n            return [].concat(this.actions);\n        },\n\n        /**\n         * General getter\n         *\n         * @param   {string}    path\n         * @return  {*}\n         */\n        get:function(...path)\n        {\n            path = [...path].join('.');\n            return this.map.get(path);\n        },\n\n\n    // ------------------------------------------------------------------------------------------------\n    // checks\n\n        /**\n         * Test if the given state exists within the system\n         *\n         * @param   {string}    state\n         * @returns {boolean}\n         */\n        hasState: function (state)\n        {\n            return this.states.indexOf(state) !== -1;\n        },\n\n        /**\n         * Test if the given action exists within the system\n         *\n         * @param   {string}    action\n         * @returns {boolean}\n         */\n        hasAction: function (action)\n        {\n            return this.actions.indexOf(action) !== -1;\n        },\n\n        /**\n         * Test if the given transition exists within the system\n         *\n         * @param   {string}    action\n         * @param   {string}    from\n         * @param   {string}    to\n         * @returns {boolean}\n         */\n        hasTransition: function (action, from, to)\n        {\n            return this.map.get(from + '.' + action) === to;\n        },\n\n        /**\n         * Utility function to directly check if the composed ValueMap has the requested path\n         *\n         * Note this does NOT take into account the value of the target object; use hasTransition() for that\n         *\n         * @param   {string}    path    Pass a path using dot notation, i.e. 'a.next' or pass individual arguments, i.e. from, action, to\n         * @returns {boolean}\n         */\n        has: function (...path)\n        {\n            path = [...path].join('.');\n            return !! path\n                ? this.map.has(path)\n                : false;\n        }\n\n};\n\nTransitionMap.prototype.constructor = TransitionMap;\n\n/**\n * Private utility function to update existing states and actions\n *\n * @param   {TransitionMap} target\n * @returns {TransitionMap}\n */\nfunction update(target)\n{\n    // variables\n    var actions     = {};\n    var states      = {};\n    var data        = target.map.data;\n    var to;\n\n    // collate from states\n    for(let from in data)\n    {\n        states[from] = true;\n        for(let action in data[from])\n        {\n            actions[action] = true;\n            to = data[from][action];\n            if(typeof to !== 'function')\n            {\n                states[to] = true;\n            }\n        }\n    }\n\n    // update\n    target.states  = Object.keys(states).filter(state => state !== '*');\n    target.actions = Object.keys(actions);\n\n    // return\n    return target;\n}\n\nexport default TransitionMap;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/maps/TransitionMap.js\n **/","import { isString } from '../utils/utils';\nimport { ParseError } from '../objects/errors';\nimport TransitionMeta from './TransitionMeta';\n\n// ------------------------------------------------------------------------------------------------\n// functions\n\n    function getError(tx, message)\n    {\n        return 'Invalid transition shorthand pattern \"' +tx+ '\" - ' + message;\n    }\n\n    function add(transitions, action, from, to)\n    {\n        transitions.push(new TransitionMeta(action, from, to));\n    }\n\n\n// ------------------------------------------------------------------------------------------------\n// export\n\n    /**\n     * Parses/expands transition objects/strings into discrete transitions\n     *\n     * @returns {TransitionMeta[]}  An array of TransitionMeta instances\n     */\n    export default function parse (tx)\n    {\n        if(isString(tx))\n        {\n            // pre-process string\n            tx = tx\n                .replace(/([|=:<>])/g, ' $1 ')\n                .replace(/\\s+/g, ' ')\n                .replace(/^\\s+|\\s+$/g,'');\n\n            // ensure string is valid\n            if(!/^\\w+ [:|=] [*\\w][\\w ]*[<>] [*\\w][\\w ]*/.test(tx))\n            {\n                throw new ParseError(getError(tx, 'cannot determine action and states'));\n            }\n\n            // initialize variables\n            let transitions = [],\n                matches = tx.match(/([*\\w ]+|[<>])/g),\n                action  = matches.shift().replace(/\\s+/g, ''),\n                stack   = [],\n                match   = '',\n                op      = '',\n                a       = '',\n                b       = '';\n\n            // process states\n            while(matches.length)\n            {\n                // get the next match\n                match = matches.shift();\n                if(/[<>]/.test(match))\n                {\n                    op = match;\n                }\n                else\n                {\n                    match = match.match(/[*\\w]+/g);\n                    match = match.length === 1 ? match[0] : match;\n                    stack.push(match);\n                }\n\n                // process matches if stack is full\n                if(stack.length === 2)\n                {\n                    [a, b] = op === '<'\n                        ? [stack[1], stack[0]]\n                        : stack;\n                    if(Array.isArray(a) && Array.isArray(b))\n                    {\n                        throw new ParseError(getError(tx, 'transitioning between 2 arrays doesn\\'t make sense'));\n                    }\n                    if(b === '*')\n                    {\n                        throw new ParseError(getError(tx, 'transitioning to a wildcard doesn\\'t make sense'));\n                    }\n                    if(Array.isArray(a))\n                    {\n                        a.map( a => add(transitions, action, a, b) );\n                    }\n                    else if(Array.isArray(b))\n                    {\n                        b.map( b => add(transitions, action, a, b) );\n                    }\n                    else\n                    {\n                        add(transitions, action, a, b);\n                    }\n\n                    // discard original match once processed\n                    stack.shift();\n                }\n\n            }\n\n            // return\n            return transitions;\n        }\n\n        // return objects wrapped in an array\n        return [tx];\n    }\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/TransitionParser.js\n **/","function TransitionMeta(action, from, to)\n{\n    this.action = action;\n    this.from = from;\n    this.to = to;\n}\n\nexport default TransitionMeta;\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/parsers/TransitionMeta.js\n **/","import { StateEvent, ActionEvent } from '../objects/events';\nimport { isFunction } from '../utils/utils';\n\n/**\n * Transition class\n *\n * Responsible for managing events in the flow from state to state.\n *\n * This adds all handlers for the current action start/end and state from/to to an array:\n *\n * - <namespace>.<target>.<type>[]\n *\n * So going from state \"a\" to state \"b\" with action \"next\" should build:\n *\n * - action.*.start[]\n * - action.next.start[]\n * - state.a.leave[]\n * - state.*.leave[]\n * - state.*.enter[]\n * - state.b.enter[]\n * - action.next.end[]\n * - action.*.end[]\n *\n * This can be changed by passing in an order array in fsm.config\n *\n * Event handlers will receive an Event object, along with any passed parameters (from do()) as ...rest parameters.\n *\n * From a callback, you can:\n *\n * - return false to cancel the transition\n * - return true to pause the transition\n * - not return a value (the transition continues)\n *\n * TransitionMap can also be paused, resumed, or cancelled by calling\n * the appropriate method on, or from:\n *\n * - the event\n * - the transition\n * - the state machine\n *\n * Cancelled transitions will reset the FSM to the previous \"from\" state\n *\n * When the last callback has fired, the main FSM's end() handler will be called and the state will updated\n *\n * @param {StateMachine}    fsm\n * @param {string}          action\n * @param {string}          from\n * @param {string}          to\n */\nfunction Transition (fsm, action, from, to)\n{\n    this.fsm        = fsm;\n    this.action     = action;\n    this.from       = from;\n    this.to         = to;\n    this.clear();\n}\n\n/**\n * @prop {StateMachine}    fsm\n * @prop {string}          action\n * @prop {string}          from\n * @prop {string}          to\n * @prop {Function[]}      handlers\n */\nTransition.prototype =\n{\n    fsm         : null,\n    action      : '',\n    from        : '',\n    to          : '',\n    paused      : false,\n    handlers    : null,\n\n    clear: function ()\n    {\n        unpause(this);\n        this.handlers = [];\n    },\n\n    /**\n     * Execute the next event's callbacks\n     * @returns {*}\n     */\n\texec: function ()\n\t{\n\t    if( ! this.paused )\n        {\n            if(this.handlers.length)\n            {\n                var handler = this.handlers.shift();\n                var state = handler();\n                if(state === false)\n                {\n                    return this.fsm.cancel();\n                }\n                if(state === true)\n                {\n                    return this.fsm.pause();\n                }\n                this.exec();\n            }\n            else\n            {\n                this.fsm.end();\n            }\n        }\n        return this;\n\t},\n\n    pause: function ()\n    {\n        pause(this);\n        return this;\n    },\n\n    resume: function ()\n    {\n        unpause(this);\n        return this.exec();\n    },\n\n    cancel: function()\n    {\n        this.paused = false;;\n        this.fsm.handlers.trigger('transition.cancel', false);\n    }\n\n};\n\nfunction pause(transition)\n{\n    if(!transition.paused)\n    {\n        transition.paused = true;\n        transition.fsm.handlers.trigger('transition.pause', true);\n    }\n}\n\nfunction unpause(transition)\n{\n    if(transition.paused)\n    {\n        transition.paused = false;\n        transition.fsm.handlers.trigger('transition.resume', false);\n    }\n}\n\nexport default\n{\n    /**\n     * Create the Transition object\n     *\n     * - Set up variables, and queue\n     * - Determine paths to relevant handlers\n     * - Build State and Action Event objects\n     * - Pre-bind all handlers\n     * - Append to queue\n     *\n     * @param {StateMachine}    fsm\n     * @param {string}          action\n     * @param {Array}           params\n     * @returns {Transition}\n     */\n    create:function (fsm, action, params)\n    {\n        // transition properties\n        let scope   = fsm.config.scope;\n        let from    = fsm.state;\n        let to      = fsm.transitions.getStateFor(from, action);\n        let vars    = {action, to, from};\n\n        // handle \"to\" being a function\n        if(isFunction(to))\n        {\n            to = to.apply(scope, params);\n            if(!fsm.transitions.hasState(to))\n            {\n                throw new Error('Invalid \"to\" state \"' +to+ '\"');\n            }\n        }\n\n        // transition\n        let queue       = [];\n        let transition  = new Transition(fsm, action, from, to);\n\n        // build handlers array\n        fsm.config.order.map( path =>\n        {\n            // replace path tokens\n            path = path.replace(/{(\\w+)}/g, (all, token) => vars[token]);\n            let handlers = fsm.handlers.get(path);\n\n            // do it!\n            if(handlers)\n            {\n                let [namespace, target, type] = path.split('.');\n                handlers = handlers.map( handler =>\n                {\n                    // build event object\n                    let Event = namespace === 'state' ? StateEvent : ActionEvent;\n                    let event = new Event(type, target, transition);\n\n                    // pre-bind handlers, scopes and params\n                    // this way scope and params don't need to be passed around\n                    // and the call from Transition is always just `value = handler()`\n                    return function()\n                    {\n                        return handler.apply(scope, [event, fsm].concat(params));\n                    }\n                });\n\n                // add to queue\n                queue = queue.concat(handlers);\n            }\n        });\n\n        // return\n        transition.handlers = queue;\n        return transition;\n    },\n\n    force: function(fsm, state)\n    {\n        let transition = new Transition(fsm, '', fsm.state, state);\n        transition.paused = fsm.transition ? fsm.transition.paused : false;\n        return transition;\n    }\n\n}\n\n\n\n/** WEBPACK FOOTER **\n ** ./~/eslint-loader!./src/core/classes/Transition.js\n **/"],"sourceRoot":""}